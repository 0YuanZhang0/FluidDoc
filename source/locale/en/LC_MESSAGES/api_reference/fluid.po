# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, paddle-dev@baidu.com
# This file is distributed under the same license as the PaddlePaddle Fluid
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PaddlePaddle Fluid 0.13.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-15 16:34+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../source/api_reference/fluid.rst:6
msgid "fluid"
msgstr ""

#: ../../source/api_reference/fluid.rst:11
msgid "Block"
msgstr ""

#: of paddle.fluid.Block.clone_variable:1
msgid ""
"Clone a variable into current block. :param var: the variable to be "
"cloned."
msgstr ""

#: of paddle.fluid.Block.clone_variable paddle.fluid.Block.copy_param_info_from
#: paddle.fluid.Program.copy_data_info_from
#: paddle.fluid.Program.copy_param_info_from paddle.fluid.Variable.astype
#: paddle.fluid.channel_recv paddle.fluid.channel_send
#: paddle.fluid.create_lod_tensor paddle.fluid.create_random_int_lodtensor
#: paddle.fluid.default_main_program paddle.fluid.default_startup_program
#: paddle.fluid.fetch_var paddle.fluid.get_var paddle.fluid.make_channel
#: paddle.fluid.memory_optimize paddle.fluid.program_guard
#: paddle.fluid.switch_main_program paddle.fluid.switch_startup_program
msgid "返回"
msgstr ""

#: of paddle.fluid.Block.clone_variable:4
msgid "The new  variable cloned from 'var' in current block."
msgstr ""

#: of paddle.fluid.Block.copy_param_info_from:1
msgid ""
"Copy the information of parameters from the other block :param other: the"
" other block :type other: Block"
msgstr ""

#: of paddle.fluid.Block.copy_param_info_from:5
#: paddle.fluid.Program.copy_data_info_from:5
#: paddle.fluid.Program.copy_param_info_from:5 paddle.fluid.program_guard:15
msgid "None"
msgstr ""

#: of paddle.fluid.Block.rename_var:1
msgid "Rename variable in vars and ops' inputs and outputs"
msgstr ""

#: of paddle.fluid.Block.sync_with_cpp:1
msgid "Sync from the desc on the c++ end."
msgstr ""

#: of paddle.fluid.Block.sync_with_cpp:3
msgid ""
"This method is used to synchronize the c++ desc instance generated by "
"backward."
msgstr ""

#: of paddle.fluid.Block.to_string:1 paddle.fluid.Operator.to_string:1
#: paddle.fluid.Program.to_string:1
msgid ""
"To debug string. :param throw_on_error: raise exception when self is not "
"initialized"
msgstr ""

#: of paddle.fluid.Block.to_string:3 paddle.fluid.Operator.to_string:3
#: paddle.fluid.Program.to_string:3
msgid "when throw_on_error is True"
msgstr ""

#: of paddle.fluid.Block.to_string paddle.fluid.Executor.run
#: paddle.fluid.Inferencer.infer paddle.fluid.ParallelExecutor.run
#: paddle.fluid.Program.clone paddle.fluid.Program.to_string
#: paddle.fluid.Trainer paddle.fluid.Trainer.test paddle.fluid.Trainer.train
#: paddle.fluid.Variable paddle.fluid.Variable.to_string
#: paddle.fluid.channel_close paddle.fluid.channel_recv
#: paddle.fluid.channel_send paddle.fluid.create_lod_tensor
#: paddle.fluid.create_random_int_lodtensor paddle.fluid.fetch_var
#: paddle.fluid.make_channel paddle.fluid.memory_optimize
#: paddle.fluid.program_guard paddle.fluid.switch_main_program
msgid "参数"
msgstr ""

#: of paddle.fluid.Block.to_string:5 paddle.fluid.Program.to_string:5
#: paddle.fluid.Variable.to_string:6
msgid ""
"more details about variables and parameters (e.g. trainable, "
"optimize_attr, ...) will be printed when with_details is True"
msgstr ""

#: of paddle.fluid.Block.to_string:9 paddle.fluid.Operator.to_string:6
#: paddle.fluid.Program.to_string:9 paddle.fluid.Variable.to_string:10
msgid "Returns(str): The debug string."
msgstr ""

#: ../../source/api_reference/fluid.rst:20 of paddle.fluid.get_var:8
msgid "Variable"
msgstr ""

#: of paddle.fluid.Variable:1
msgid ""
"Python variable. Every input and output of an operator is a variable. "
"Every variable belongs to a block. The variable has a name and two "
"variables in different blocks could have the same name."
msgstr ""

#: of paddle.fluid.Variable:5
msgid ""
"There are many kinds of variables. Please reference the framework.proto "
"for details."
msgstr ""

#: of paddle.fluid.Variable:8
msgid ""
"Notes: The constructor of Variable should not be invoked directly. Please"
" use `Block.create_var` to create a variable."
msgstr ""

#: of paddle.fluid.Variable:16
msgid ""
"The associated block. It will be passed by `Block.create_var` "
"automatically."
msgstr ""

#: of paddle.fluid.Variable:19
msgid "Variable type. Please reference the framework.proto for details."
msgstr ""

#: of paddle.fluid.Variable:22
msgid ""
"The shape of variable. -1 means the batch size. Some kinds of variable do"
" not contain shape, just set it to None."
msgstr ""

#: of paddle.fluid.Variable:25
msgid "The data type of variable."
msgstr ""

#: of paddle.fluid.Variable:27
msgid "The level of lod tensor. 0 means it is not a time series data."
msgstr ""

#: of paddle.fluid.Variable:30
msgid "The capacity of Channel variable. Ignored for other types."
msgstr ""

#: of paddle.fluid.Variable:33
msgid "True if the variable should be saved as check point. Defaults to False."
msgstr ""

#: of paddle.fluid.Variable:36
msgid ""
"True if the variable will stop to calculate gradients when backward. "
"Defaults to False."
msgstr ""

#: of paddle.fluid.Variable.astype:1
msgid ""
"Cast a variable to a specified data type. NOTE: The variable must be a "
"Tensor :param self: The source variable :type self: Variable :param "
"dtype: The target dtype"
msgstr ""

#: of paddle.fluid.Variable.astype:7
msgid "Variable with new dtype"
msgstr ""

#: of paddle.fluid.Variable.to_string:1
msgid "Get debug string."
msgstr ""

#: of paddle.fluid.Variable.to_string:3
msgid "True if raise an exception when self is not intialized."
msgstr ""

#: ../../source/api_reference/fluid.rst:29
msgid "Program"
msgstr ""

#: of paddle.fluid.Program.clone:1
msgid "Clone the Program object"
msgstr ""

#: of paddle.fluid.Program.clone:3
msgid ""
"Set for_test to False when we want to clone the program for training. Set"
" for_test to True when we want to clone the program for testing."
msgstr ""

#: of paddle.fluid.Program.clone:6
msgid ""
"Some operators, such as batch_norm and drop_out ops, behave differently "
"in training and testing. If for_test is True, the is_test attributes in "
"these operators will be set to True for testing purposes, otherwise, they"
" remain unchanged."
msgstr ""

#: of paddle.fluid.Program.clone:12
msgid "Returns(Program):"
msgstr ""

#: of paddle.fluid.Program.clone:13
msgid "The cloned Program object."
msgstr ""

#: of paddle.fluid.Program.copy_data_info_from:1
msgid ""
"Copy the information of data variables from other program. :param other: "
"Other program :type other: Program"
msgstr ""

#: of paddle.fluid.Program.copy_param_info_from:1
msgid ""
"Copy the information of parameters from other program. :param other: "
"Other program :type other: Program"
msgstr ""

#: ../../source/api_reference/fluid.rst:38
msgid "Operator"
msgstr ""

#: of paddle.fluid.Operator:1
msgid ""
"Python Operator class. The operator represents the build in instructions "
"in a Block. Users can use the build in instructions to describe their "
"neural network."
msgstr ""

#: of paddle.fluid.Operator.all_attrs:1
msgid "Get the attribute dict Returns(dict): The Operator's attribute dict"
msgstr ""

#: of paddle.fluid.Operator.attr:1
msgid "Get attribute by name :param name: the attribute name :type name: str"
msgstr ""

#: of paddle.fluid.Operator.attr:5
msgid "Returns(bool|int|str|float|list): The attribute value. The return value"
msgstr ""

#: of paddle.fluid.Operator.attr:6
msgid "can be any valid attribute type."
msgstr ""

#: of paddle.fluid.Operator.attr_names:1
msgid "Get all attribute names Returns(list): The list of attribute name"
msgstr ""

#: of paddle.fluid.Operator.attr_type:1
msgid ""
"Get the type of attribute by attribute name :param name: the attribute "
"name :type name: str"
msgstr ""

#: of paddle.fluid.Operator.attr_type:5
msgid "Returns(core.AttrType): the attribute type"
msgstr ""

#: of paddle.fluid.Operator.block_attr:1
msgid ""
"Get the block attribute by name :param name: the attribute name :type "
"name: str"
msgstr ""

#: of paddle.fluid.Operator.block_attr:5
msgid "Returns(int): the block index"
msgstr ""

#: of paddle.fluid.Operator.has_attr:1
msgid ""
"operator has the attribute with name or not. :param name: the attribute "
"name :type name: str"
msgstr ""

#: of paddle.fluid.Operator.has_attr:5
msgid "Returns(bool): True if has this attribute."
msgstr ""

#: of paddle.fluid.Operator.idx:1
msgid ""
"Return the array index of current operator. Returns(int): The array index"
" in block.ops array :raises: :exc:`ValueError` -- when the operator is "
"not found."
msgstr ""

#: of paddle.fluid.Operator.input:1
msgid ""
"Get input arguments by the input parameter name :param name: The input "
"parameter name :type name: str"
msgstr ""

#: of paddle.fluid.Operator.input:5 paddle.fluid.Operator.output:5
msgid "Returns(list): return the list of argument names associated with the"
msgstr ""

#: of paddle.fluid.Operator.input:6 paddle.fluid.Operator.output:6
msgid "specific parameter name."
msgstr ""

#: of paddle.fluid.Operator.input_names:1
msgid ""
"Get all input parameter names Returns(list): return a list of input "
"parameter names"
msgstr ""

#: of paddle.fluid.Operator.output:1
msgid ""
"Get output arguments by the output parameter name :param name: The output"
" parameter name :type name: str"
msgstr ""

#: of paddle.fluid.Operator.output_names:1
msgid ""
"Get all output parameter names Returns(list): return a list of output "
"parameter names"
msgstr ""

#: ../../source/api_reference/fluid.rst:47
msgid "default_startup_program"
msgstr ""

#: of paddle.fluid.default_startup_program:1
msgid ""
"Get default startup program. In startup program, Paddle will initialize "
"parameters, initialize nccl handle, etc."
msgstr ""

#: of paddle.fluid.default_startup_program:4
msgid "startup program"
msgstr ""

#: of paddle.fluid.channel_recv paddle.fluid.channel_send
#: paddle.fluid.default_main_program paddle.fluid.default_startup_program
#: paddle.fluid.make_channel paddle.fluid.switch_main_program
#: paddle.fluid.switch_startup_program
msgid "返回类型"
msgstr ""

#: ../../source/api_reference/fluid.rst:55
msgid "default_main_program"
msgstr ""

#: of paddle.fluid.default_main_program:1
msgid ""
"Get default main program. The main program is used for training or "
"testing."
msgstr ""

#: of paddle.fluid.default_main_program:3
msgid "main program"
msgstr ""

#: ../../source/api_reference/fluid.rst:63
msgid "program_guard"
msgstr ""

#: of paddle.fluid.program_guard:1
msgid "Switch program with `with` statement"
msgstr ""

#: of paddle.fluid.channel_close:7 paddle.fluid.channel_recv:17
#: paddle.fluid.channel_send:21 paddle.fluid.make_channel:29
#: paddle.fluid.program_guard:3
msgid "Examples"
msgstr ""

#: of paddle.fluid.program_guard:9
msgid "New main program inside `with` statement"
msgstr ""

#: of paddle.fluid.program_guard:11
msgid ""
"New startup program inside `with` statement. None means do not change "
"startup program."
msgstr ""

#: ../../source/api_reference/fluid.rst:71
msgid "switch_startup_program"
msgstr ""

#: of paddle.fluid.switch_startup_program:1
msgid ""
"Switch the startup program to a new program :param program: The new "
"startup program :type program: Program"
msgstr ""

#: of paddle.fluid.switch_startup_program:5
msgid "The previous startup program"
msgstr ""

#: ../../source/api_reference/fluid.rst:79
msgid "switch_main_program"
msgstr ""

#: of paddle.fluid.switch_main_program:1
msgid "Switch the main program to a new program."
msgstr ""

#: of paddle.fluid.switch_main_program:3
msgid "The new main program"
msgstr ""

#: of paddle.fluid.switch_main_program:6
msgid "The previous main program"
msgstr ""

#: ../../source/api_reference/fluid.rst:87
msgid "get_var"
msgstr ""

#: of paddle.fluid.get_var:1
msgid ""
"Get a variable by name from the global block of a program :param name: "
"name of the variable :type name: str :param program: program object."
msgstr ""

#: of paddle.fluid.get_var:5
msgid "If None, default_global_program() will be used."
msgstr ""

#: ../../source/api_reference/fluid.rst:95
msgid "Executor"
msgstr ""

#: of paddle.fluid.Executor.run:1
msgid ""
"Run program by this Executor. Feed data by feed map, fetch result by "
"fetch_list."
msgstr ""

#: of paddle.fluid.Executor.run:3
msgid ""
"Python executor takes a program, add feed operators and fetch operators "
"to this program according to feed map and fetch_list. Feed map provides "
"input data for the program. fetch_list provides the variables(or names) "
"that user want to get after program run. Note: the executor will run all "
"operators in the program but not only the operators dependent by the "
"fetch_list"
msgstr ""

#: of paddle.fluid.Executor.run:8
msgid ""
"the program that need to run, if not provied, then default_main_program "
"will be used."
msgstr ""

#: of paddle.fluid.Executor.run:9
msgid "feed variable map, e.g. {\"image\": ImageData, \"label\": LableData}"
msgstr ""

#: of paddle.fluid.Executor.run:10
msgid ""
"a list of variable or variable names that user want to get, run will "
"return them according"
msgstr ""

#: of paddle.fluid.Executor.run:11
msgid ""
"to this list. :param feed_var_name: the name for the input variable of "
"feed Operator. :param fetch_var_name: the name for the output variable of"
" feed Operator. :param scope: the scope used to run this program, you can"
" switch it to different scope. default is global_scope :param "
"return_numpy: if convert the fetched tensor to numpy :param "
"use_program_cache: set use_program_cache to true if program not changed "
"compare to the last step. :return: result according to fetch_list."
msgstr ""

#: ../../source/api_reference/fluid.rst:104
msgid "global_scope"
msgstr ""

#: ../../source/api_reference/fluid.rst:112
msgid "scope_guard"
msgstr ""

#: ../../source/api_reference/fluid.rst:120
msgid "switch_scope"
msgstr ""

#: ../../source/api_reference/fluid.rst:128
msgid "fetch_var"
msgstr ""

#: of paddle.fluid.fetch_var:1
msgid ""
"Fetch the value of the variable with the given name from the given scope "
":param name: name of the variable. Typically, only persistable variables"
msgstr ""

#: of paddle.fluid.fetch_var:3
msgid "can be found in the scope used for running the program."
msgstr ""

#: of paddle.fluid.fetch_var:5
msgid ""
"scope object. It should be the scope where you pass to Executor.run() "
"when running your program. If None, global_scope() will be used."
msgstr ""

#: of paddle.fluid.fetch_var:9
msgid "whether convert the tensor to numpy.ndarray"
msgstr ""

#: of paddle.fluid.fetch_var:12
msgid "LodTensor|numpy.ndarray"
msgstr ""

#: ../../source/api_reference/fluid.rst:136
msgid "Go"
msgstr ""

#: ../../source/api_reference/fluid.rst:145
msgid "make_channel"
msgstr ""

#: of paddle.fluid.make_channel:1
msgid ""
"Helps implementation of a concurrent program by creating a \"channel\" of"
" a defined data type. Channels allow for the passing of data in "
"concurrent scenarios - such as when using threads to divide computation. "
"Channels can be used to \"send\" and \"receive\" such data concurrently."
msgstr ""

#: of paddle.fluid.make_channel:6
msgid ""
"There are two kinds of channels: unbuffered and buffered. Unbuffered "
"channels have no capacity - and thus, block on send and only unblock only"
" once what they have sent has been received."
msgstr ""

#: of paddle.fluid.make_channel:10
msgid ""
"On the other hand, buffered channels are initialized with a capacity - "
"and do not block on sends."
msgstr ""

#: of paddle.fluid.make_channel:13
msgid ""
"Use this method in combination with `channel_send`, `channel_recv`, "
"`channel_close`, and `Go` to design a concurrent Paddle program."
msgstr ""

#: of paddle.fluid.make_channel:16
msgid "Data type of the data sent in the channel."
msgstr ""

#: of paddle.fluid.make_channel:19
msgid "Size of the channel. Defaults to 0 for"
msgstr ""

#: of paddle.fluid.make_channel:23
msgid ""
"The channel variable that can be used to send an receive data           "
"of the defined dtype."
msgstr ""

#: of paddle.fluid.make_channel:25
msgid "The channel variable that can be used to send an receive data"
msgstr ""

#: of paddle.fluid.make_channel:26
msgid "of the defined dtype."
msgstr ""

#: ../../source/api_reference/fluid.rst:153
msgid "channel_send"
msgstr ""

#: of paddle.fluid.channel_send:1
msgid ""
"Sends a value through a channel variable. Used by an unbuffered or "
"buffered channel to pass data from within or to a concurrent Go block, "
"where `channel_recv` to used to get the passed value."
msgstr ""

#: of paddle.fluid.channel_close:3 paddle.fluid.channel_recv:6
#: paddle.fluid.channel_send:5
msgid "Channel variable created using"
msgstr ""

#: of paddle.fluid.channel_send:8
msgid "Value to send to channel"
msgstr ""

#: of paddle.fluid.channel_send:10
msgid "Copy data while channel send. If False, then data"
msgstr ""

#: of paddle.fluid.channel_send:15
msgid ""
"The boolean status on whether or not the channel           successfully "
"sent the passed value."
msgstr ""

#: of paddle.fluid.channel_send:17
msgid "The boolean status on whether or not the channel"
msgstr ""

#: of paddle.fluid.channel_send:18
msgid "successfully sent the passed value."
msgstr ""

#: ../../source/api_reference/fluid.rst:161
msgid "channel_recv"
msgstr ""

#: of paddle.fluid.channel_recv:1
msgid ""
"Receives a value through a channel variable. Used by an unbuffered or "
"buffered channel within a concurrent Go block to get data from originally"
" sent using `channel_send`, or from outside such a block where "
"`channel_send` is used to send the value."
msgstr ""

#: of paddle.fluid.channel_recv:9
msgid "Variable to set as a result of running channel_recv_op"
msgstr ""

#: of paddle.fluid.channel_recv:12
msgid ""
"The received value from the channel. Variable: The boolean status on "
"whether or not the channel           successfully received the passed "
"value."
msgstr ""

#: of paddle.fluid.channel_recv:12
msgid ""
"The received value from the channel. Variable: The boolean status on "
"whether or not the channel"
msgstr ""

#: of paddle.fluid.channel_recv:14
msgid "successfully received the passed value."
msgstr ""

#: ../../source/api_reference/fluid.rst:169
msgid "channel_close"
msgstr ""

#: of paddle.fluid.channel_close:1
msgid "Closes a channel created using `make_channel`."
msgstr ""

#: ../../source/api_reference/fluid.rst:177
msgid "Select"
msgstr ""

#: of paddle.fluid.Select.case:1
msgid "Create a new block for this condition."
msgstr ""

#: of paddle.fluid.Select.default:1
msgid "Create a default case block for this condition."
msgstr ""

#: ../../source/api_reference/fluid.rst:186
msgid "Trainer"
msgstr ""

#: of paddle.fluid.Trainer:1
msgid "A function which will return loss. The loss must be a scalar."
msgstr ""

#: of paddle.fluid.Trainer:3
msgid "A function that returns an Optimizer object."
msgstr ""

#: of paddle.fluid.Trainer:5
msgid "The device place of this trainer."
msgstr ""

#: of paddle.fluid.Trainer.stop:1
msgid "stop training"
msgstr ""

#: of paddle.fluid.Trainer.test:1
msgid "Test the model on given test data"
msgstr ""

#: of paddle.fluid.Trainer.test:3
msgid "The reader that yields test data."
msgstr ""

#: of paddle.fluid.Trainer.test:4 paddle.fluid.Trainer.train:6
msgid "Feeding order of reader. None will following the defining order in program"
msgstr ""

#: of paddle.fluid.Trainer.train:1
msgid "Train the model."
msgstr ""

#: of paddle.fluid.Trainer.train:3
msgid "The number of epoch. An epoch will process all data in reader"
msgstr ""

#: of paddle.fluid.Trainer.train:4
msgid "The event handler. A function with type (ev:Event)->void"
msgstr ""

#: of paddle.fluid.Trainer.train:9
msgid "Returns:"
msgstr ""

#: ../../source/api_reference/fluid.rst:195
msgid "BeginEpochEvent"
msgstr ""

#: ../../source/api_reference/fluid.rst:204
msgid "EndEpochEvent"
msgstr ""

#: ../../source/api_reference/fluid.rst:213
msgid "BeginStepEvent"
msgstr ""

#: ../../source/api_reference/fluid.rst:222
msgid "EndStepEvent"
msgstr ""

#: ../../source/api_reference/fluid.rst:231
msgid "CheckpointConfig"
msgstr ""

#: ../../source/api_reference/fluid.rst:240
msgid "Inferencer"
msgstr ""

#: of paddle.fluid.Inferencer.infer:1
msgid ""
"a map of {\"input_name\": input_var} that will be feed into the inference"
" program"
msgstr ""

#: of paddle.fluid.Inferencer.infer:2
msgid "to get the predict value :return: the predict value of the inference model"
msgstr ""

#: ../../source/api_reference/fluid.rst:249
msgid "memory_optimize"
msgstr ""

#: of paddle.fluid.memory_optimize:1
msgid "Optimize memory by reusing var memory."
msgstr ""

#: of paddle.fluid.memory_optimize:3
msgid "Note: it doesn't not support subblock nested in subblock."
msgstr ""

#: of paddle.fluid.memory_optimize:5
msgid "Input Program"
msgstr ""

#: of paddle.fluid.memory_optimize:6
msgid "whether to print debug log."
msgstr ""

#: of paddle.fluid.memory_optimize:7
msgid "If level=0, reuse if the shape is completely equal, o"
msgstr ""

#: ../../source/api_reference/fluid.rst:257
msgid "release_memory"
msgstr ""

#: ../../source/api_reference/fluid.rst:265
msgid "ParallelExecutor"
msgstr ""

#: of paddle.fluid.ParallelExecutor.run:1
msgid "Run a parallel executor with fetch_list."
msgstr ""

#: of paddle.fluid.ParallelExecutor.run:3
msgid ""
"The feed parameter can be a dict or a list. If feed is a dict, the feed "
"data will be split into multiple devices. If feed is a list, we assume "
"the data has been splitted into multiple devices, the each element in the"
" list will be copied to each device directly."
msgstr ""

#: of paddle.fluid.ParallelExecutor.run:8
msgid ""
"For example, if the feed is a dict: >>> exe = ParallelExecutor() >>> # "
"the image will be splitted into devices. If there is two devices >>> # "
"each device will process an image with shape (24, 1, 28, 28) >>> "
"exe.run(feed={'image': numpy.random.random(size=(48, 1, 28, 28))})"
msgstr ""

#: of paddle.fluid.ParallelExecutor.run:14
msgid ""
"For example, if the feed is a list: >>> exe = ParallelExecutor() >>> # "
"each device will process each element in the list. >>> # the 1st device "
"will process an image with shape (48, 1, 28, 28) >>> # the 2nd device "
"will process an image with shape (32, 1, 28, 28) >>> # >>> # you can use "
"exe.device_count to get the device number. >>> exe.run(feed=[{\"image\": "
"numpy.random.random(size=(48, 1, 28, 28))}, >>>               {\"image\":"
" numpy.random.random(size=(32, 1, 28, 28))}, >>>              ])"
msgstr ""

#: of paddle.fluid.ParallelExecutor.run:26
msgid "The fetched variable names"
msgstr ""

#: of paddle.fluid.ParallelExecutor.run:28
msgid ""
"The feed variables. If the feed is a dict, tensors in that dict will be "
"splitted into each devices. If the feed is a list, each element of the "
"list will be copied to each device."
msgstr ""

#: of paddle.fluid.ParallelExecutor.run:33
msgid ""
"Alias for feed parameter, for backward compatibility. This parameter is "
"deprecated."
msgstr ""

#: of paddle.fluid.ParallelExecutor.run:36
msgid "Returns: fetched result list."
msgstr ""

#: ../../source/api_reference/fluid.rst:274
msgid "ExecutionStrategy"
msgstr ""

#: ../../source/api_reference/fluid.rst:283
msgid "BuildStrategy"
msgstr ""

#: ../../source/api_reference/fluid.rst:292
msgid "create_lod_tensor"
msgstr ""

#: of paddle.fluid.create_lod_tensor:1
msgid "Create a lod tensor from a numpy array, a list, or an existing lod tensor."
msgstr ""

#: of paddle.fluid.create_lod_tensor:3
msgid ""
"Create a lod tensor by doing the following: 1. Check that the length-"
"based input lod is valid. 2. Convert the length-based lod to a offset-"
"based LoD. 3. Copy the data from a numpy array, a list or a existing lod "
"tensor to"
msgstr ""

#: of paddle.fluid.create_lod_tensor:7
msgid "CPU or GPU device (based on input place)."
msgstr ""

#: of paddle.fluid.create_lod_tensor:8
msgid "Set the level of detail (LoD) using the offset-based LoD."
msgstr ""

#: of paddle.fluid.create_lod_tensor:10
msgid ""
"Use example: Suppose we want LoDTensor to hold data for sequences of "
"word, where each word is represented by an integer. If we want to create "
"a LoDTensor to represent two sentences, one of 2 words, and one of 3 "
"words."
msgstr ""

#: of paddle.fluid.create_lod_tensor:15
msgid ""
"Then 'data' can be a numpy array of integers with shape (5, 1). 'lod' "
"will be [[2, 3]], indicating the length(# of words) in each sentence. "
"This length-based input lod [[2, 3]] will be converted to offset-based "
"lod [[0, 2, 5]] inside the function call."
msgstr ""

#: of paddle.fluid.create_lod_tensor:20
msgid ""
"Please refer to "
"github.com/PaddlePaddle/Paddle/blob/develop/doc/fluid/design/concepts/lod_tensor.md"
" for more details regarding LoD."
msgstr ""

#: of paddle.fluid.create_lod_tensor:24
msgid "a numpy array or a LoDTensor or a list holding the data to be copied."
msgstr ""

#: of paddle.fluid.create_lod_tensor:25
#: paddle.fluid.create_random_int_lodtensor:20
msgid ""
"a list of lists indicating the length-based LoD info specified by the "
"user."
msgstr ""

#: of paddle.fluid.create_lod_tensor:26
#: paddle.fluid.create_random_int_lodtensor:22
msgid ""
"CPU or GPU place indicating where the data in the new LoDTensor will be "
"stored."
msgstr ""

#: of paddle.fluid.create_lod_tensor:28
#: paddle.fluid.create_random_int_lodtensor:26
msgid "A fluid LoDTensor object with tensor data and lod info."
msgstr ""

#: ../../source/api_reference/fluid.rst:300
msgid "create_random_int_lodtensor"
msgstr ""

#: of paddle.fluid.create_random_int_lodtensor:1
msgid "Create a LoDTensor containing random integers."
msgstr ""

#: of paddle.fluid.create_random_int_lodtensor:3
msgid ""
"This function is frequently used in the book examples. So we revised it "
"based on the new create_lod_tensor API and put it here in the lod_tensor "
"module to simplify the code."
msgstr ""

#: of paddle.fluid.create_random_int_lodtensor:7
msgid ""
"The function does the following: 1. Calculate the overall shape of the "
"LoDTensor based on the length-based 'lod' input and the shape of the "
"basic element in 'base_shape'. 2. Create a numpy array of this shape. 3. "
"Create the LoDTensor using create_lod_tensor API."
msgstr ""

#: of paddle.fluid.create_random_int_lodtensor:13
msgid ""
"Suppose we want LoDTensor to hold data for sequences of word, where each "
"word is represented by an integer. If we want to create a LoDTensor to "
"represent two sentences, one of 2 words, and one of 3 words. Then "
"'base_shape' is [1], input length-based 'lod' is [[2, 3]]. Then the "
"overall shape of the LoDTensor would be [5, 1], holding 5 words for two "
"sentences."
msgstr ""

#: of paddle.fluid.create_random_int_lodtensor:19
msgid "a numpy array or a LoDTensor holding the data to be copied."
msgstr ""

#: of paddle.fluid.create_random_int_lodtensor:21
msgid "the shape of the basic element to be held by the LoDTensor."
msgstr ""

#: of paddle.fluid.create_random_int_lodtensor:23
msgid "the lower bound of the random integers."
msgstr ""

#: of paddle.fluid.create_random_int_lodtensor:24
msgid "the upper bound of the random integers."
msgstr ""

#: ../../source/api_reference/fluid.rst:308
msgid "LoDTensor"
msgstr ""

#: ../../source/api_reference/fluid.rst:317
msgid "CPUPlace"
msgstr ""

#: ../../source/api_reference/fluid.rst:326
msgid "CUDAPlace"
msgstr ""

#: ../../source/api_reference/fluid.rst:335
msgid "CUDAPinnedPlace"
msgstr ""

#: ../../source/api_reference/fluid.rst:344
msgid "Tensor"
msgstr ""

#: ../../source/api_reference/fluid.rst:353
msgid "ParamAttr"
msgstr ""

#: ../../source/api_reference/fluid.rst:362
msgid "WeightNormParamAttr"
msgstr ""

#: of paddle.fluid.WeightNormParamAttr:1
msgid ""
"Used for weight normalization. Any field in ParamAttr can also be set "
"here. Besides, an extra field dim can be set to indicate the dimension "
"except which to normalize."
msgstr ""

#: ../../source/api_reference/fluid.rst:371
msgid "DataFeeder"
msgstr ""

