# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, paddle-dev@baidu.com
# This file is distributed under the same license as the PaddlePaddle Fluid
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PaddlePaddle Fluid 0.13.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-15 16:34+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../source/api_reference/layers.rst:6
msgid "fluid.layers"
msgstr ""

#: ../../source/api_reference/layers.rst:9
msgid "control_flow"
msgstr ""

#: ../../source/api_reference/layers.rst:14
msgid "split_lod_tensor"
msgstr ""

#: of paddle.fluid.layers.split_lod_tensor:1
msgid "**split_lod_tensor**"
msgstr ""

#: of paddle.fluid.layers.split_lod_tensor:3
msgid ""
"This function takes in an input that contains the complete lod "
"information, and takes in a mask which is used to mask certain parts of "
"the input. The output is the true branch and the false branch with the "
"mask applied to the input at a certain level in the tensor."
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.memory
#: paddle.fluid.layers.DynamicRNN.output paddle.fluid.layers.IfElse
#: paddle.fluid.layers.Preprocessor paddle.fluid.layers.Print
#: paddle.fluid.layers.Send paddle.fluid.layers.StaticRNN.memory
#: paddle.fluid.layers.StaticRNNMemoryLink paddle.fluid.layers.While
#: paddle.fluid.layers.abs paddle.fluid.layers.argmax
#: paddle.fluid.layers.argmin paddle.fluid.layers.array_length
#: paddle.fluid.layers.array_to_lod_tensor paddle.fluid.layers.array_write
#: paddle.fluid.layers.assign paddle.fluid.layers.autoincreased_step_counter
#: paddle.fluid.layers.batch_norm paddle.fluid.layers.beam_search
#: paddle.fluid.layers.beam_search_decode paddle.fluid.layers.bipartite_match
#: paddle.fluid.layers.box_coder paddle.fluid.layers.brelu
#: paddle.fluid.layers.ceil paddle.fluid.layers.chunk_eval
#: paddle.fluid.layers.clip paddle.fluid.layers.clip_by_norm
#: paddle.fluid.layers.concat paddle.fluid.layers.conv2d
#: paddle.fluid.layers.conv2d_transpose paddle.fluid.layers.conv3d
#: paddle.fluid.layers.conv3d_transpose paddle.fluid.layers.cos
#: paddle.fluid.layers.cos_sim paddle.fluid.layers.create_array
#: paddle.fluid.layers.create_parameter paddle.fluid.layers.crf_decoding
#: paddle.fluid.layers.cross_entropy paddle.fluid.layers.ctc_greedy_decoder
#: paddle.fluid.layers.cumsum paddle.fluid.layers.data
#: paddle.fluid.layers.detection_map paddle.fluid.layers.detection_output
#: paddle.fluid.layers.dice_loss paddle.fluid.layers.double_buffer
#: paddle.fluid.layers.dropout paddle.fluid.layers.dynamic_gru
#: paddle.fluid.layers.dynamic_lstm paddle.fluid.layers.dynamic_lstmp
#: paddle.fluid.layers.edit_distance paddle.fluid.layers.elementwise_add
#: paddle.fluid.layers.elementwise_div paddle.fluid.layers.elementwise_max
#: paddle.fluid.layers.elementwise_min paddle.fluid.layers.elementwise_mul
#: paddle.fluid.layers.elementwise_pow paddle.fluid.layers.elementwise_sub
#: paddle.fluid.layers.elu paddle.fluid.layers.embedding
#: paddle.fluid.layers.equal paddle.fluid.layers.exp
#: paddle.fluid.layers.exponential_decay paddle.fluid.layers.fc
#: paddle.fluid.layers.fill_constant
#: paddle.fluid.layers.fill_constant_batch_size_like paddle.fluid.layers.floor
#: paddle.fluid.layers.gather paddle.fluid.layers.gaussian_random
#: paddle.fluid.layers.gaussian_random_batch_size_like
#: paddle.fluid.layers.get_places paddle.fluid.layers.gru_unit
#: paddle.fluid.layers.hard_shrink paddle.fluid.layers.hard_sigmoid
#: paddle.fluid.layers.im2sequence paddle.fluid.layers.image_resize
#: paddle.fluid.layers.image_resize_short paddle.fluid.layers.increment
#: paddle.fluid.layers.inverse_time_decay paddle.fluid.layers.iou_similarity
#: paddle.fluid.layers.is_empty paddle.fluid.layers.label_smooth
#: paddle.fluid.layers.layer_norm paddle.fluid.layers.leaky_relu
#: paddle.fluid.layers.less_than paddle.fluid.layers.linear_chain_crf
#: paddle.fluid.layers.load paddle.fluid.layers.lod_rank_table
#: paddle.fluid.layers.lod_reset paddle.fluid.layers.lod_tensor_to_array
#: paddle.fluid.layers.log paddle.fluid.layers.logical_and
#: paddle.fluid.layers.logical_not paddle.fluid.layers.logical_or
#: paddle.fluid.layers.logical_xor paddle.fluid.layers.logsigmoid
#: paddle.fluid.layers.lstm_unit paddle.fluid.layers.matmul
#: paddle.fluid.layers.max_sequence_len paddle.fluid.layers.maxout
#: paddle.fluid.layers.mean paddle.fluid.layers.mean_iou
#: paddle.fluid.layers.merge_lod_tensor paddle.fluid.layers.mul
#: paddle.fluid.layers.multi_box_head paddle.fluid.layers.multiplex
#: paddle.fluid.layers.natural_exp_decay paddle.fluid.layers.nce
#: paddle.fluid.layers.noam_decay paddle.fluid.layers.one_hot
#: paddle.fluid.layers.ones paddle.fluid.layers.open_files
#: paddle.fluid.layers.open_recordio_file paddle.fluid.layers.pad
#: paddle.fluid.layers.polygon_box_transform paddle.fluid.layers.pool2d
#: paddle.fluid.layers.pool3d paddle.fluid.layers.pow
#: paddle.fluid.layers.prior_box paddle.fluid.layers.random_crop
#: paddle.fluid.layers.random_data_generator paddle.fluid.layers.reciprocal
#: paddle.fluid.layers.reduce_max paddle.fluid.layers.reduce_mean
#: paddle.fluid.layers.reduce_min paddle.fluid.layers.reduce_prod
#: paddle.fluid.layers.reduce_sum paddle.fluid.layers.relu
#: paddle.fluid.layers.relu6 paddle.fluid.layers.reorder_lod_tensor_by_rank
#: paddle.fluid.layers.reshape paddle.fluid.layers.resize_bilinear
#: paddle.fluid.layers.roi_pool paddle.fluid.layers.round
#: paddle.fluid.layers.row_conv paddle.fluid.layers.scale
#: paddle.fluid.layers.scatter paddle.fluid.layers.sequence_conv
#: paddle.fluid.layers.sequence_expand paddle.fluid.layers.sequence_first_step
#: paddle.fluid.layers.sequence_last_step paddle.fluid.layers.sequence_pool
#: paddle.fluid.layers.sequence_reshape paddle.fluid.layers.shape
#: paddle.fluid.layers.shrink_memory paddle.fluid.layers.sigmoid
#: paddle.fluid.layers.sigmoid_cross_entropy_with_logits
#: paddle.fluid.layers.sin paddle.fluid.layers.slice
#: paddle.fluid.layers.smooth_l1 paddle.fluid.layers.soft_relu
#: paddle.fluid.layers.softmax_with_cross_entropy paddle.fluid.layers.softplus
#: paddle.fluid.layers.softshrink paddle.fluid.layers.softsign
#: paddle.fluid.layers.split paddle.fluid.layers.split_lod_tensor
#: paddle.fluid.layers.sqrt paddle.fluid.layers.square
#: paddle.fluid.layers.square_error_cost paddle.fluid.layers.ssd_loss
#: paddle.fluid.layers.stanh paddle.fluid.layers.sum paddle.fluid.layers.sums
#: paddle.fluid.layers.swish paddle.fluid.layers.tanh
#: paddle.fluid.layers.tanh_shrink paddle.fluid.layers.target_assign
#: paddle.fluid.layers.thresholded_relu paddle.fluid.layers.topk
#: paddle.fluid.layers.transpose paddle.fluid.layers.uniform_random
#: paddle.fluid.layers.uniform_random_batch_size_like
#: paddle.fluid.layers.warpctc paddle.fluid.layers.zeros
msgid "参数"
msgstr ""

#: of paddle.fluid.layers.merge_lod_tensor:12
#: paddle.fluid.layers.split_lod_tensor:8
msgid ""
"The input tensor that contains complete lod information needed to "
"construct the output."
msgstr ""

#: of paddle.fluid.layers.merge_lod_tensor:15
#: paddle.fluid.layers.split_lod_tensor:11
msgid "A bool column vector which masks the input."
msgstr ""

#: of paddle.fluid.layers.merge_lod_tensor:17
#: paddle.fluid.layers.split_lod_tensor:13
msgid "The specific lod level to rank."
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.memory
#: paddle.fluid.layers.DynamicRNN.output
#: paddle.fluid.layers.DynamicRNN.static_input
#: paddle.fluid.layers.DynamicRNN.step_input
#: paddle.fluid.layers.DynamicRNN.update_memory paddle.fluid.layers.Print
#: paddle.fluid.layers.abs paddle.fluid.layers.argmax
#: paddle.fluid.layers.argmin paddle.fluid.layers.array_length
#: paddle.fluid.layers.array_read paddle.fluid.layers.array_to_lod_tensor
#: paddle.fluid.layers.array_write paddle.fluid.layers.assign
#: paddle.fluid.layers.autoincreased_step_counter
#: paddle.fluid.layers.batch_norm paddle.fluid.layers.beam_search
#: paddle.fluid.layers.beam_search_decode paddle.fluid.layers.bipartite_match
#: paddle.fluid.layers.box_coder paddle.fluid.layers.brelu
#: paddle.fluid.layers.ceil paddle.fluid.layers.chunk_eval
#: paddle.fluid.layers.clip paddle.fluid.layers.clip_by_norm
#: paddle.fluid.layers.concat paddle.fluid.layers.conv2d
#: paddle.fluid.layers.conv2d_transpose paddle.fluid.layers.conv3d
#: paddle.fluid.layers.conv3d_transpose paddle.fluid.layers.cos
#: paddle.fluid.layers.cos_sim paddle.fluid.layers.create_array
#: paddle.fluid.layers.create_global_var paddle.fluid.layers.create_parameter
#: paddle.fluid.layers.crf_decoding paddle.fluid.layers.cross_entropy
#: paddle.fluid.layers.ctc_greedy_decoder paddle.fluid.layers.cumsum
#: paddle.fluid.layers.data paddle.fluid.layers.detection_map
#: paddle.fluid.layers.detection_output paddle.fluid.layers.dice_loss
#: paddle.fluid.layers.double_buffer paddle.fluid.layers.dropout
#: paddle.fluid.layers.dynamic_gru paddle.fluid.layers.dynamic_lstm
#: paddle.fluid.layers.dynamic_lstmp paddle.fluid.layers.edit_distance
#: paddle.fluid.layers.elementwise_add paddle.fluid.layers.elementwise_div
#: paddle.fluid.layers.elementwise_max paddle.fluid.layers.elementwise_min
#: paddle.fluid.layers.elementwise_mul paddle.fluid.layers.elementwise_pow
#: paddle.fluid.layers.elementwise_sub paddle.fluid.layers.elu
#: paddle.fluid.layers.embedding paddle.fluid.layers.equal
#: paddle.fluid.layers.exp paddle.fluid.layers.exponential_decay
#: paddle.fluid.layers.fc paddle.fluid.layers.fill_constant
#: paddle.fluid.layers.fill_constant_batch_size_like paddle.fluid.layers.floor
#: paddle.fluid.layers.gather paddle.fluid.layers.gaussian_random
#: paddle.fluid.layers.gaussian_random_batch_size_like
#: paddle.fluid.layers.get_places paddle.fluid.layers.gru_unit
#: paddle.fluid.layers.hard_shrink paddle.fluid.layers.hard_sigmoid
#: paddle.fluid.layers.im2sequence paddle.fluid.layers.image_resize
#: paddle.fluid.layers.image_resize_short paddle.fluid.layers.increment
#: paddle.fluid.layers.inverse_time_decay paddle.fluid.layers.iou_similarity
#: paddle.fluid.layers.is_empty paddle.fluid.layers.label_smooth
#: paddle.fluid.layers.layer_norm paddle.fluid.layers.leaky_relu
#: paddle.fluid.layers.less_than paddle.fluid.layers.linear_chain_crf
#: paddle.fluid.layers.load paddle.fluid.layers.lod_rank_table
#: paddle.fluid.layers.lod_reset paddle.fluid.layers.lod_tensor_to_array
#: paddle.fluid.layers.log paddle.fluid.layers.logical_and
#: paddle.fluid.layers.logical_not paddle.fluid.layers.logical_or
#: paddle.fluid.layers.logical_xor paddle.fluid.layers.logsigmoid
#: paddle.fluid.layers.lstm_unit paddle.fluid.layers.matmul
#: paddle.fluid.layers.max_sequence_len paddle.fluid.layers.maxout
#: paddle.fluid.layers.mean paddle.fluid.layers.mean_iou
#: paddle.fluid.layers.merge_lod_tensor paddle.fluid.layers.mul
#: paddle.fluid.layers.multi_box_head paddle.fluid.layers.multiplex
#: paddle.fluid.layers.natural_exp_decay paddle.fluid.layers.nce
#: paddle.fluid.layers.noam_decay paddle.fluid.layers.one_hot
#: paddle.fluid.layers.ones paddle.fluid.layers.open_files
#: paddle.fluid.layers.open_recordio_file paddle.fluid.layers.pad
#: paddle.fluid.layers.polygon_box_transform
#: paddle.fluid.layers.polynomial_decay paddle.fluid.layers.pool2d
#: paddle.fluid.layers.pool3d paddle.fluid.layers.pow
#: paddle.fluid.layers.prior_box paddle.fluid.layers.random_crop
#: paddle.fluid.layers.random_data_generator paddle.fluid.layers.reciprocal
#: paddle.fluid.layers.reduce_max paddle.fluid.layers.reduce_mean
#: paddle.fluid.layers.reduce_min paddle.fluid.layers.reduce_prod
#: paddle.fluid.layers.reduce_sum paddle.fluid.layers.relu
#: paddle.fluid.layers.relu6 paddle.fluid.layers.reorder_lod_tensor_by_rank
#: paddle.fluid.layers.reshape paddle.fluid.layers.resize_bilinear
#: paddle.fluid.layers.roi_pool paddle.fluid.layers.round
#: paddle.fluid.layers.row_conv paddle.fluid.layers.scale
#: paddle.fluid.layers.scatter paddle.fluid.layers.sequence_conv
#: paddle.fluid.layers.sequence_expand paddle.fluid.layers.sequence_first_step
#: paddle.fluid.layers.sequence_last_step paddle.fluid.layers.sequence_pool
#: paddle.fluid.layers.sequence_reshape paddle.fluid.layers.shape
#: paddle.fluid.layers.shrink_memory paddle.fluid.layers.sigmoid
#: paddle.fluid.layers.sigmoid_cross_entropy_with_logits
#: paddle.fluid.layers.sin paddle.fluid.layers.slice
#: paddle.fluid.layers.smooth_l1 paddle.fluid.layers.soft_relu
#: paddle.fluid.layers.softmax_with_cross_entropy paddle.fluid.layers.softplus
#: paddle.fluid.layers.softshrink paddle.fluid.layers.softsign
#: paddle.fluid.layers.split paddle.fluid.layers.split_lod_tensor
#: paddle.fluid.layers.sqrt paddle.fluid.layers.square
#: paddle.fluid.layers.square_error_cost paddle.fluid.layers.ssd_loss
#: paddle.fluid.layers.stanh paddle.fluid.layers.sum paddle.fluid.layers.sums
#: paddle.fluid.layers.swish paddle.fluid.layers.tanh
#: paddle.fluid.layers.tanh_shrink paddle.fluid.layers.target_assign
#: paddle.fluid.layers.thresholded_relu paddle.fluid.layers.topk
#: paddle.fluid.layers.transpose paddle.fluid.layers.uniform_random
#: paddle.fluid.layers.uniform_random_batch_size_like
#: paddle.fluid.layers.warpctc paddle.fluid.layers.zeros
msgid "返回"
msgstr ""

#: of paddle.fluid.layers.split_lod_tensor:16
msgid ""
"The true branch of tensor as per the mask applied to input. Variable: The"
" false branch of tensor as per the mask applied to input."
msgstr ""

#: of paddle.fluid.layers.Print paddle.fluid.layers.argmax
#: paddle.fluid.layers.argmin paddle.fluid.layers.array_length
#: paddle.fluid.layers.array_read paddle.fluid.layers.array_to_lod_tensor
#: paddle.fluid.layers.array_write paddle.fluid.layers.assign
#: paddle.fluid.layers.autoincreased_step_counter
#: paddle.fluid.layers.batch_norm paddle.fluid.layers.beam_search
#: paddle.fluid.layers.beam_search_decode paddle.fluid.layers.bipartite_match
#: paddle.fluid.layers.chunk_eval paddle.fluid.layers.concat
#: paddle.fluid.layers.conv2d paddle.fluid.layers.conv2d_transpose
#: paddle.fluid.layers.conv3d paddle.fluid.layers.conv3d_transpose
#: paddle.fluid.layers.cos_sim paddle.fluid.layers.create_array
#: paddle.fluid.layers.create_global_var paddle.fluid.layers.ctc_greedy_decoder
#: paddle.fluid.layers.data paddle.fluid.layers.detection_output
#: paddle.fluid.layers.dice_loss paddle.fluid.layers.dropout
#: paddle.fluid.layers.dynamic_gru paddle.fluid.layers.dynamic_lstm
#: paddle.fluid.layers.dynamic_lstmp paddle.fluid.layers.edit_distance
#: paddle.fluid.layers.embedding paddle.fluid.layers.equal
#: paddle.fluid.layers.fill_constant paddle.fluid.layers.gather
#: paddle.fluid.layers.gru_unit paddle.fluid.layers.im2sequence
#: paddle.fluid.layers.image_resize paddle.fluid.layers.image_resize_short
#: paddle.fluid.layers.increment paddle.fluid.layers.is_empty
#: paddle.fluid.layers.label_smooth paddle.fluid.layers.linear_chain_crf
#: paddle.fluid.layers.lod_rank_table paddle.fluid.layers.lod_reset
#: paddle.fluid.layers.lod_tensor_to_array paddle.fluid.layers.lstm_unit
#: paddle.fluid.layers.matmul paddle.fluid.layers.mean_iou
#: paddle.fluid.layers.merge_lod_tensor paddle.fluid.layers.multi_box_head
#: paddle.fluid.layers.nce paddle.fluid.layers.ones
#: paddle.fluid.layers.open_files paddle.fluid.layers.open_recordio_file
#: paddle.fluid.layers.pad paddle.fluid.layers.pool2d
#: paddle.fluid.layers.pool3d paddle.fluid.layers.prior_box
#: paddle.fluid.layers.random_data_generator paddle.fluid.layers.reduce_max
#: paddle.fluid.layers.reduce_mean paddle.fluid.layers.reduce_min
#: paddle.fluid.layers.reduce_prod paddle.fluid.layers.reduce_sum
#: paddle.fluid.layers.reshape paddle.fluid.layers.roi_pool
#: paddle.fluid.layers.sequence_conv paddle.fluid.layers.sequence_expand
#: paddle.fluid.layers.sequence_reshape paddle.fluid.layers.smooth_l1
#: paddle.fluid.layers.softmax_with_cross_entropy paddle.fluid.layers.split
#: paddle.fluid.layers.split_lod_tensor paddle.fluid.layers.square_error_cost
#: paddle.fluid.layers.sums paddle.fluid.layers.target_assign
#: paddle.fluid.layers.topk paddle.fluid.layers.transpose
#: paddle.fluid.layers.warpctc paddle.fluid.layers.zeros
msgid "返回类型"
msgstr ""

#: of paddle.fluid.layers.IfElse:8 paddle.fluid.layers.Preprocessor:8
#: paddle.fluid.layers.Print:34 paddle.fluid.layers.While:8
#: paddle.fluid.layers.argmax:15 paddle.fluid.layers.argmin:15
#: paddle.fluid.layers.array_length:11 paddle.fluid.layers.array_read:12
#: paddle.fluid.layers.array_to_lod_tensor:16
#: paddle.fluid.layers.array_write:21 paddle.fluid.layers.assign:13
#: paddle.fluid.layers.bipartite_match:60 paddle.fluid.layers.concat:17
#: paddle.fluid.layers.conv2d:99 paddle.fluid.layers.conv2d_transpose:98
#: paddle.fluid.layers.conv3d:94 paddle.fluid.layers.conv3d_transpose:99
#: paddle.fluid.layers.create_array:10 paddle.fluid.layers.create_parameter:23
#: paddle.fluid.layers.cross_entropy:55
#: paddle.fluid.layers.ctc_greedy_decoder:51 paddle.fluid.layers.cumsum:16
#: paddle.fluid.layers.data:29 paddle.fluid.layers.detection_output:65
#: paddle.fluid.layers.dice_loss:26 paddle.fluid.layers.double_buffer:15
#: paddle.fluid.layers.dropout:26 paddle.fluid.layers.dynamic_gru:63
#: paddle.fluid.layers.dynamic_lstm:104 paddle.fluid.layers.dynamic_lstmp:113
#: paddle.fluid.layers.edit_distance:38 paddle.fluid.layers.embedding:34
#: paddle.fluid.layers.equal:15 paddle.fluid.layers.fc:62
#: paddle.fluid.layers.fill_constant:22 paddle.fluid.layers.gather:33
#: paddle.fluid.layers.gru_unit:44 paddle.fluid.layers.hard_shrink:18
#: paddle.fluid.layers.image_resize:35 paddle.fluid.layers.increment:18
#: paddle.fluid.layers.is_empty:17 paddle.fluid.layers.label_smooth:42
#: paddle.fluid.layers.layer_norm:53 paddle.fluid.layers.lod_rank_table:40
#: paddle.fluid.layers.lod_reset:70 paddle.fluid.layers.lod_tensor_to_array:16
#: paddle.fluid.layers.lstm_unit:64 paddle.fluid.layers.matmul:43
#: paddle.fluid.layers.mean_iou:25 paddle.fluid.layers.merge_lod_tensor:23
#: paddle.fluid.layers.multi_box_head:81 paddle.fluid.layers.one_hot:12
#: paddle.fluid.layers.ones:16 paddle.fluid.layers.open_files:28
#: paddle.fluid.layers.open_recordio_file:24 paddle.fluid.layers.pad:42
#: paddle.fluid.layers.prior_box:53 paddle.fluid.layers.random_crop:5
#: paddle.fluid.layers.random_data_generator:24
#: paddle.fluid.layers.reduce_max:22 paddle.fluid.layers.reduce_mean:22
#: paddle.fluid.layers.reduce_min:22 paddle.fluid.layers.reduce_prod:22
#: paddle.fluid.layers.reduce_sum:22 paddle.fluid.layers.reshape:61
#: paddle.fluid.layers.roi_pool:34 paddle.fluid.layers.row_conv:40
#: paddle.fluid.layers.sequence_expand:53
#: paddle.fluid.layers.sequence_first_step:20
#: paddle.fluid.layers.sequence_last_step:20
#: paddle.fluid.layers.sequence_pool:40 paddle.fluid.layers.sequence_reshape:37
#: paddle.fluid.layers.shrink_memory:19 paddle.fluid.layers.smooth_l1:34
#: paddle.fluid.layers.softmax_with_cross_entropy:47
#: paddle.fluid.layers.split:22 paddle.fluid.layers.split_lod_tensor:20
#: paddle.fluid.layers.square_error_cost:26 paddle.fluid.layers.ssd_loss:95
#: paddle.fluid.layers.sums:14 paddle.fluid.layers.thresholded_relu:17
#: paddle.fluid.layers.topk:28 paddle.fluid.layers.transpose:18
#: paddle.fluid.layers.uniform_random:18 paddle.fluid.layers.warpctc:34
#: paddle.fluid.layers.zeros:16
msgid "Examples"
msgstr ""

#: ../../source/api_reference/layers.rst:22
msgid "merge_lod_tensor"
msgstr ""

#: of paddle.fluid.layers.merge_lod_tensor:1
msgid "**merge_lod_tensor**"
msgstr ""

#: of paddle.fluid.layers.merge_lod_tensor:3
msgid ""
"This function takes in an input :math:`x`, the True branch, the False "
"branch and a binary :math:`mask`. Using this information, this function "
"merges the True and False branches of the tensor into a single Output at "
"a certain lod level indiacted by :math:`level`."
msgstr ""

#: of paddle.fluid.layers.merge_lod_tensor:8
msgid "The True branch to be merged."
msgstr ""

#: of paddle.fluid.layers.merge_lod_tensor:10
msgid "The False branch to be merged."
msgstr ""

#: of paddle.fluid.layers.merge_lod_tensor:20
msgid "The merged output tensor."
msgstr ""

#: ../../source/api_reference/layers.rst:30
msgid "BlockGuard"
msgstr ""

#: of paddle.fluid.layers.BlockGuard:1
msgid "BlockGuard class."
msgstr ""

#: of paddle.fluid.layers.BlockGuard:3
msgid ""
"BlockGuard class is used to create a sub-block in a program by using the "
"Python `with` keyword."
msgstr ""

#: ../../source/api_reference/layers.rst:39
msgid "BlockGuardWithCompletion"
msgstr ""

#: of paddle.fluid.layers.BlockGuardWithCompletion:1
msgid "BlockGuardWithCompletion class."
msgstr ""

#: of paddle.fluid.layers.BlockGuardWithCompletion:3
msgid ""
"BlockGuardWithCompletion class is used to create an op with a block in a "
"program."
msgstr ""

#: ../../source/api_reference/layers.rst:48
msgid "StaticRNNMemoryLink"
msgstr ""

#: of paddle.fluid.layers.StaticRNNMemoryLink:1
msgid "StaticRNNMemoryLink class."
msgstr ""

#: of paddle.fluid.layers.StaticRNNMemoryLink:3
msgid "the initial variable for Memory"
msgstr ""

#: of paddle.fluid.layers.StaticRNNMemoryLink:4
#: paddle.fluid.layers.StaticRNNMemoryLink:6
#: paddle.fluid.layers.StaticRNNMemoryLink:8
msgid "Variable"
msgstr ""

#: of paddle.fluid.layers.StaticRNNMemoryLink:5
msgid "the memory variable in previous time step"
msgstr ""

#: of paddle.fluid.layers.StaticRNNMemoryLink:7
msgid "the memory variable in current time step"
msgstr ""

#: of paddle.fluid.layers.StaticRNNMemoryLink:10
msgid ""
"StaticRNNMemoryLink class is used to create a link between two memory "
"cells of a StaticRNN."
msgstr ""

#: ../../source/api_reference/layers.rst:57
msgid "WhileGuard"
msgstr ""

#: ../../source/api_reference/layers.rst:66
msgid "While"
msgstr ""

#: of paddle.fluid.layers.While:1
msgid "while loop control flow."
msgstr ""

#: of paddle.fluid.layers.IfElse:3 paddle.fluid.layers.While:3
msgid "condition used to compare."
msgstr ""

#: of paddle.fluid.layers.IfElse:5 paddle.fluid.layers.While:5
#: paddle.fluid.layers.fc:55
msgid "The name of this layer."
msgstr ""

#: ../../source/api_reference/layers.rst:75
msgid "Switch"
msgstr ""

#: of paddle.fluid.layers.Switch.case:1
msgid "create a new block for this condition"
msgstr ""

#: of paddle.fluid.layers.Switch.default:1
msgid "create a default case for this switch"
msgstr ""

#: ../../source/api_reference/layers.rst:84
msgid "lod_rank_table"
msgstr ""

#: of paddle.fluid.layers.lod_rank_table:1
msgid ""
"LoD Rank Table Operator. Given an input variable **x** and a level number"
" of LoD, this layer creates a LodRankTable object. A LoDRankTable object "
"contains a list of bi-element tuples. Each tuple consists of an index and"
" a length, both of which are int type. Refering to specified level of "
"LoD, the index is the sequence index number and the length representes "
"the sequence length. Please note that the list is ranked in descending "
"order by the length. The following is an example:"
msgstr ""

#: of paddle.fluid.layers.lod_rank_table:30
msgid "Input variable, a LoDTensor based which to create the lod rank table."
msgstr ""

#: of paddle.fluid.layers.lod_rank_table:33
msgid "Specify the LoD level, on which to create the lod rank table."
msgstr ""

#: of paddle.fluid.layers.lod_rank_table:37
msgid "The created LoDRankTable object."
msgstr ""

#: ../../source/api_reference/layers.rst:92
msgid "max_sequence_len"
msgstr ""

#: of paddle.fluid.layers.max_sequence_len:1
msgid ""
"Given a LoDRankTable object, this layer returns the max length of a batch"
" of sequences. In fact, a LoDRankTable object contains a list of "
"tuples(<sequence index, sequence length>) and the list is already sorted "
"by sequence length in descending order, so the operator just returns the "
"sequence length of the first tuple element"
msgstr ""

#: of paddle.fluid.layers.max_sequence_len:11
msgid "Input variable which is a LoDRankTable object."
msgstr ""

#: of paddle.fluid.layers.max_sequence_len:14
msgid "The max sequence length."
msgstr ""

#: ../../source/api_reference/layers.rst:100
msgid "lod_tensor_to_array"
msgstr ""

#: of paddle.fluid.layers.lod_tensor_to_array:1
msgid "Convert a LOD_TENSOR to an LOD_TENSOR_ARRAY."
msgstr ""

#: of paddle.fluid.layers.lod_tensor_to_array:3
msgid "The LOD tensor to be converted to a LOD tensor array."
msgstr ""

#: of paddle.fluid.layers.array_to_lod_tensor:5
#: paddle.fluid.layers.lod_tensor_to_array:5
msgid ""
"The variable that stores the level of lod which is ordered by sequence "
"length in descending order."
msgstr ""

#: of paddle.fluid.layers.lod_tensor_to_array:10
msgid ""
"The variable of type array that has been converted from a           "
"tensor."
msgstr ""

#: of paddle.fluid.layers.lod_tensor_to_array:12
msgid "The variable of type array that has been converted from a"
msgstr ""

#: of paddle.fluid.layers.lod_tensor_to_array:13
msgid "tensor."
msgstr ""

#: ../../source/api_reference/layers.rst:108
msgid "array_to_lod_tensor"
msgstr ""

#: of paddle.fluid.layers.array_to_lod_tensor:1
msgid "Convert a LoD_Tensor_Aarry to an LoDTensor."
msgstr ""

#: of paddle.fluid.layers.array_to_lod_tensor:3
msgid "The lod tensor array to be converted to a tensor."
msgstr ""

#: of paddle.fluid.layers.array_to_lod_tensor:10
msgid ""
"The variable of type tensor that has been converted           from an "
"array."
msgstr ""

#: of paddle.fluid.layers.array_to_lod_tensor:12
msgid "The variable of type tensor that has been converted"
msgstr ""

#: of paddle.fluid.layers.array_to_lod_tensor:13
msgid "from an array."
msgstr ""

#: ../../source/api_reference/layers.rst:116
msgid "increment"
msgstr ""

#: of paddle.fluid.layers.increment:1
msgid ""
"This function performs an operation that increments each value in the "
"input :math:`x` by an amount: :math:`value` as mentioned in the input "
"parameter. This operation is performed in-place by default."
msgstr ""

#: of paddle.fluid.layers.increment:5
msgid "The tensor that has the input values."
msgstr ""

#: of paddle.fluid.layers.increment:7
msgid "The amount by which the values should be incremented."
msgstr ""

#: of paddle.fluid.layers.increment:9
msgid "If the increment should be performed in-place."
msgstr ""

#: of paddle.fluid.layers.increment:12
msgid ""
"The tensor variable storing the transformation of           element-wise "
"increment of each value in the input."
msgstr ""

#: of paddle.fluid.layers.increment:14
msgid "The tensor variable storing the transformation of"
msgstr ""

#: of paddle.fluid.layers.increment:15
msgid "element-wise increment of each value in the input."
msgstr ""

#: ../../source/api_reference/layers.rst:124
msgid "array_write"
msgstr ""

#: of paddle.fluid.layers.array_write:1
msgid ""
"This function writes the given input variable to the specified position "
"indicating by the arrary index to an output LOD_TENSOR_ARRAY. If the "
"output LOD_TENSOR_ARRAY is not given(None), a new one will be created and"
" returned."
msgstr ""

#: of paddle.fluid.layers.array_write:6
msgid "The input tensor from which the data will be read."
msgstr ""

#: of paddle.fluid.layers.array_write:8
msgid ""
"The index of the output LOD_TENSOR_ARRAY, pointing to the position to "
"which the input tensor will be written."
msgstr ""

#: of paddle.fluid.layers.array_write:12
msgid ""
"The output LOD_TENSOR_ARRAY to which the input tensor will be written. If"
" this parameter is NONE, a new LOD_TENSOR_ARRAY will be created and "
"returned."
msgstr ""

#: of paddle.fluid.layers.array_write:18
msgid "The output LOD_TENSOR_ARRAY where the input tensor is written."
msgstr ""

#: ../../source/api_reference/layers.rst:132
msgid "create_array"
msgstr ""

#: of paddle.fluid.layers.create_array:1
msgid ""
"This function creates an array of type :math:`LOD_TENSOR_ARRAY` using the"
" LayerHelper."
msgstr ""

#: of paddle.fluid.layers.create_array:4
msgid "The data type of the elements in the array."
msgstr ""

#: of paddle.fluid.layers.create_array:7
msgid "The tensor variable storing the elements of data type."
msgstr ""

#: ../../source/api_reference/layers.rst:140
msgid "less_than"
msgstr ""

#: of paddle.fluid.layers.less_than:1
msgid ""
"It operates element-wise on X and Y, and returns the Out. Each of them is"
" a N-dim tensor. X and Y could be any type.  The each element of the Out "
"tensor is calculated by :math:`Out = X < Y`"
msgstr ""

#: of paddle.fluid.layers.less_than:8
msgid "the left hand operand of less_than operator."
msgstr ""

#: of paddle.fluid.layers.less_than:10
msgid "the right hand operand of less_than operator."
msgstr ""

#: of paddle.fluid.layers.less_than:12
msgid ""
"Force fill output variable to cpu memory. Otherwise, fill output variable"
" to the running device [default true]."
msgstr ""

#: of paddle.fluid.layers.less_than:14
msgid "Optional output variable to store the result of *less_than*"
msgstr ""

#: of paddle.fluid.layers.less_than:17
msgid "n-dim bool tensor. Each element is Out = X < Y."
msgstr ""

#: ../../source/api_reference/layers.rst:148
msgid "equal"
msgstr ""

#: of paddle.fluid.layers.equal:1
msgid "**equal**"
msgstr ""

#: of paddle.fluid.layers.equal:3
msgid "This layer returns the truth value of :math:`x == y` elementwise."
msgstr ""

#: of paddle.fluid.layers.equal:5
msgid "First operand of *equal*"
msgstr ""

#: of paddle.fluid.layers.equal:7
msgid "Second operand of *equal*"
msgstr ""

#: of paddle.fluid.layers.equal:9
msgid "Optional output variable to store the result of *equal*"
msgstr ""

#: of paddle.fluid.layers.equal:12
msgid "The tensor variable storing the output of *equal*."
msgstr ""

#: ../../source/api_reference/layers.rst:156
msgid "array_read"
msgstr ""

#: of paddle.fluid.layers.array_read:1
msgid ""
"This function performs the operation to read the data in as an "
"LOD_TENSOR_ARRAY. :param array: The input tensor that will be written to "
"an array. :type array: Variable|list :param i: The subscript index in "
"tensor array, that points the"
msgstr ""

#: of paddle.fluid.layers.array_read:6
msgid "place where data will be written to."
msgstr ""

#: of paddle.fluid.layers.array_read:9
msgid "The tensor type variable that has the data written to it."
msgstr ""

#: ../../source/api_reference/layers.rst:164
msgid "shrink_memory"
msgstr ""

#: of paddle.fluid.layers.shrink_memory:1
msgid ""
"This function creates an operator to shrink rnn memory using the "
"RankTable as mentioned in the input parameter."
msgstr ""

#: of paddle.fluid.layers.shrink_memory:4
msgid "NOTE: This API is very low-level API. It is used by DynamicRNN only."
msgstr ""

#: of paddle.fluid.layers.shrink_memory:6
msgid ""
"Since the Dynamic RNN uses no-padding way to implement RNN. The sequence "
"will be sorted by order, and the length of valid memory will be shrink "
"after each time step."
msgstr ""

#: of paddle.fluid.layers.shrink_memory:10
msgid "The memory object in the previous time step."
msgstr ""

#: of paddle.fluid.layers.shrink_memory:12
msgid "The step count variable. A int scalar as LoDTensor."
msgstr ""

#: of paddle.fluid.layers.shrink_memory:14
msgid "The RNNRankTable object."
msgstr ""

#: of paddle.fluid.layers.shrink_memory:17
msgid "the memory variable after shrink."
msgstr ""

#: of paddle.fluid.layers.shrink_memory:21
msgid ""
"Since this API is very low level API. The example is not provided. Please"
" reference the implementation of class DynamicRNN for detail usage."
msgstr ""

#: ../../source/api_reference/layers.rst:172
msgid "array_length"
msgstr ""

#: of paddle.fluid.layers.array_length:1
msgid ""
"This function performs the operation to find the length of the input "
"LOD_TENSOR_ARRAY."
msgstr ""

#: of paddle.fluid.layers.array_length:4
msgid "The input array that will be used to compute the length."
msgstr ""

#: of paddle.fluid.layers.array_length:8
msgid "The length of the input LoDTensorArray."
msgstr ""

#: ../../source/api_reference/layers.rst:180
msgid "IfElse"
msgstr ""

#: of paddle.fluid.layers.IfElse:1
msgid "if-else control flow."
msgstr ""

#: ../../source/api_reference/layers.rst:189
msgid "DynamicRNN"
msgstr ""

#: of paddle.fluid.layers.DynamicRNN:1
msgid ""
"The dynamic RNN can process a batch of sequence data. The length of each "
"sample sequence can be different. This API automatically process them in "
"batch."
msgstr ""

#: of paddle.fluid.layers.DynamicRNN:5
msgid "The input lod must be set. Please reference `lod_tensor`"
msgstr ""

#: of paddle.fluid.layers.DynamicRNN:23
msgid ""
"The dynamic RNN will unfold sequence into timesteps. Users need to define"
" how to process each time step during the :code:`with` block."
msgstr ""

#: of paddle.fluid.layers.DynamicRNN:26
msgid ""
"The `memory` is used staging data cross time step. The initial value of "
"memory can be zero or another variable."
msgstr ""

#: of paddle.fluid.layers.DynamicRNN:29
msgid ""
"The dynamic RNN can mark multiple variables as its output. Use `drnn()` "
"to get the output sequence."
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.block:1
msgid ""
"The block for user to define operators in RNN. See the class docstring "
"for more details."
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.memory:1
msgid "Create a memory variable for dynamic rnn."
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.memory:3
msgid ""
"If the :code:`init` is not None, :code:`memory` will be initialized by "
"this variable. The :code:`need_reorder` is used to reorder the memory as "
"the input variable. It should be set to true when the initialized memory "
"depends on the input sample."
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.memory:8
#: paddle.fluid.layers.DynamicRNN.memory:30
msgid "For example,"
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.memory:27
msgid ""
"Otherwise, if :code:`shape`, :code:`value`, :code:`dtype` are set, the "
":code:`memory` will be initialized by this :code:`value`."
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.memory:47
msgid "The initialized variable."
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.memory:49
msgid "The memory shape. NOTE the shape does not contain"
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.memory:52
msgid "the initalized value."
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.memory:54
msgid "True if the initialized memory depends on the"
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.memory:57
msgid "The data type of the initialized memory."
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.memory:60
msgid "the memory variable."
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.output:1
msgid "mark the RNN output variables."
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.output:3
msgid "The output variables."
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.output:5
#: paddle.fluid.layers.DynamicRNN.update_memory:8 paddle.fluid.layers.load:14
msgid "None"
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.static_input:1
msgid ""
"Mark a variable as a RNN input. The input will not be scattered into time"
" steps. :param x: The input variable. :type x: Variable"
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.static_input:6
msgid "The input variable that can access in RNN."
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.step_input:1
msgid ""
"Mark a sequence as a dynamic RNN input. :param x: The input sequence. "
":type x: Variable"
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.step_input:5
msgid "The current timestep in the input sequence."
msgstr ""

#: of paddle.fluid.layers.DynamicRNN.update_memory:1
msgid ""
"Update the memory from ex_mem to new_mem. NOTE that the shape and data "
"type of :code:`ex_mem` and :code:`new_mem` must be same. :param ex_mem: "
"the memory variable. :type ex_mem: Variable :param new_mem: the plain "
"variable generated in RNN block. :type new_mem: Variable"
msgstr ""

#: ../../source/api_reference/layers.rst:198
msgid "ConditionalBlock"
msgstr ""

#: ../../source/api_reference/layers.rst:207
msgid "StaticRNN"
msgstr ""

#: of paddle.fluid.layers.StaticRNN:1
msgid "StaticRNN class."
msgstr ""

#: of paddle.fluid.layers.StaticRNN:3
msgid ""
"StaticRNN class is used to create a StaticRNN. The RNN will have its own "
"parameters like inputs, outputs, memories, status and length."
msgstr ""

#: of paddle.fluid.layers.StaticRNN.memory:1
msgid "boot memory, if not set, a shape, batch_ref must be provided"
msgstr ""

#: of paddle.fluid.layers.StaticRNN.memory:2
msgid "shape of the boot memory"
msgstr ""

#: of paddle.fluid.layers.StaticRNN.memory:3
msgid "batch size reference variable"
msgstr ""

#: of paddle.fluid.layers.StaticRNN.memory:4
msgid "the init value of boot memory"
msgstr ""

#: of paddle.fluid.layers.StaticRNN.memory:5
msgid "the index of batch size in init's dimension"
msgstr ""

#: of paddle.fluid.layers.StaticRNN.memory:6
msgid "the index of batch size in batch_ref's dimension"
msgstr ""

#: ../../source/api_reference/layers.rst:216
msgid "reorder_lod_tensor_by_rank"
msgstr ""

#: of paddle.fluid.layers.reorder_lod_tensor_by_rank:1
msgid "ReorderLoDTensorByRankTable operator."
msgstr ""

#: of paddle.fluid.layers.reorder_lod_tensor_by_rank:3
msgid ""
"Input(X) is a batch of sequences. Input(RankTable) stores new orders of "
"the input sequence batch. The reorder_lod_tensor_by_rank operator "
"reorders the Input(X) according to the information provided by "
"Input(RankTable)."
msgstr ""

#: of paddle.fluid.layers.elementwise_add:23
#: paddle.fluid.layers.elementwise_div:23
#: paddle.fluid.layers.elementwise_max:23
#: paddle.fluid.layers.elementwise_min:23
#: paddle.fluid.layers.elementwise_mul:23
#: paddle.fluid.layers.elementwise_pow:23
#: paddle.fluid.layers.elementwise_sub:23
#: paddle.fluid.layers.reorder_lod_tensor_by_rank:7
msgid "For example:"
msgstr ""

#: of paddle.fluid.layers.reorder_lod_tensor_by_rank:9
msgid ""
"If the indices stored in the Input(RankTable) are [3, 0, 2, 1], the "
"Input(X) will be reordered that the fourth sequence in Input(X) will "
"become the first one, and then followed by the original first, third, and"
" the second one."
msgstr ""

#: of paddle.fluid.layers.reorder_lod_tensor_by_rank:13
msgid ""
"This is: X = [Seq0, Seq1, Seq2, Seq3]. The indices in RankTable are [3, "
"0, 2, 1]. Out =  [Seq3, Seq0, Seq2, Seq1] with a new LoD information."
msgstr ""

#: of paddle.fluid.layers.reorder_lod_tensor_by_rank:17
msgid ""
"If the LoD information of Input(X) is empty, this means Input(X) is not "
"sequence data. This is also identical to a batch of sequences where each "
"sequence has a fixed length 1. In this case, the "
"reorder_lod_tensor_by_rank operator reorders each slice of Input(X) along"
" the first axis according to Input(RankTable)."
msgstr ""

#: of paddle.fluid.layers.reorder_lod_tensor_by_rank:22
msgid ""
"This is: X = [Slice0, Slice1, Slice2, Slice3] and its LoD information is "
"empty. The indices in RankTable are [3, 0, 2, 1]. Out = [Slice3, Slice0, "
"Slice2, Slice1] with no LoD information is appended."
msgstr ""

#: of paddle.fluid.layers.reorder_lod_tensor_by_rank:27
msgid ""
"NOTE: This operator sorts Input(X) according to a given LoDRankTable "
"which does not need to be calculated according to Input(X). It can be "
"calculated according to another different sequence, and then this "
"operator sorts Input(X) according to the given LoDRankTable."
msgstr ""

#: of paddle.fluid.layers.reorder_lod_tensor_by_rank:33
msgid ""
"(LoDTensor), the input lod tensor to be reordered according to "
"Input(RankTable). Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.reorder_lod_tensor_by_rank:35
msgid ""
"(LoDRankTable), the rank table according to which Input(X) is reordered. "
"Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.reorder_lod_tensor_by_rank:38
msgid "(LoDTensor), the reordered lod tensor."
msgstr ""

#: ../../source/api_reference/layers.rst:224
msgid "ParallelDo"
msgstr ""

#: of paddle.fluid.layers.ParallelDo:1
msgid "ParallelDo class."
msgstr ""

#: of paddle.fluid.layers.ParallelDo:3
msgid "ParallelDo class is used to create a ParallelDo."
msgstr ""

#: ../../source/api_reference/layers.rst:233
msgid "Print"
msgstr ""

#: of paddle.fluid.layers.Print:1
msgid "**Print operator**"
msgstr ""

#: of paddle.fluid.layers.Print:3
msgid "This creates a print op that will print when a tensor is accessed."
msgstr ""

#: of paddle.fluid.layers.Print:5
msgid ""
"Wraps the tensor passed in so that whenever that a tensor is accessed, "
"the message `message` is printed, along with the current value of the "
"tensor `t`."
msgstr ""

#: of paddle.fluid.layers.Print:9
msgid "A Tensor to print."
msgstr ""

#: of paddle.fluid.layers.Print:11
msgid ""
"Print this number of elements in the tensor, will print all if left is "
"negative."
msgstr ""

#: of paddle.fluid.layers.Print:14
msgid "A string message to print as a prefix."
msgstr ""

#: of paddle.fluid.layers.Print:16
msgid "Only log `first_n` number of times."
msgstr ""

#: of paddle.fluid.layers.Print:18
msgid "Print the tensor name."
msgstr ""

#: of paddle.fluid.layers.Print:20
msgid "Print the tensor type."
msgstr ""

#: of paddle.fluid.layers.Print:22
msgid "Print the tensor shape."
msgstr ""

#: of paddle.fluid.layers.Print:24
msgid "Print the tensor lod."
msgstr ""

#: of paddle.fluid.layers.Print:26
msgid ""
"Which phase to displace, including 'forward', 'backward' and 'both'. If "
"set to 'backward' or 'both', will print the gradients of input tensor."
msgstr ""

#: of paddle.fluid.layers.Print:31
msgid "Output tensor, same data with input tensor."
msgstr ""

#: of paddle.fluid.layers.Print:38
msgid "value = some_layer(...) Print(value, summarize=10,"
msgstr ""

#: of paddle.fluid.layers.Print:40
msgid "message=\"The content of some_layer: \")"
msgstr ""

#: ../../source/api_reference/layers.rst:241
msgid "is_empty"
msgstr ""

#: of paddle.fluid.layers.is_empty:1
msgid "**Is Empty**"
msgstr ""

#: of paddle.fluid.layers.is_empty:3
msgid "This layer returns the truth value of whether the variable is empty."
msgstr ""

#: of paddle.fluid.layers.is_empty:5
msgid "Operand of *is_empty*"
msgstr ""

#: of paddle.fluid.layers.is_empty:7
msgid "Optional output variable to store the result of *is_empty*"
msgstr ""

#: of paddle.fluid.layers.is_empty:11
msgid "The tensor variable storing the output of *is_empty*."
msgstr ""

#: of paddle.fluid.layers.conv2d paddle.fluid.layers.conv2d_transpose
#: paddle.fluid.layers.conv3d paddle.fluid.layers.conv3d_transpose
#: paddle.fluid.layers.cross_entropy paddle.fluid.layers.fc
#: paddle.fluid.layers.is_empty paddle.fluid.layers.lod_reset
#: paddle.fluid.layers.lstm_unit paddle.fluid.layers.ssd_loss
msgid "raises"
msgstr ""

#: of paddle.fluid.layers.is_empty:14
msgid ""
":exc:`TypeError` -- If input cond is not a variable, or cond's dtype is "
"not bool"
msgstr ""

#: ../../source/api_reference/layers.rst:247
msgid "device"
msgstr ""

#: ../../source/api_reference/layers.rst:252
msgid "get_places"
msgstr ""

#: of paddle.fluid.layers.get_places:1
msgid ""
"Returns a list of places based on arguments. The list will be used for "
"parallel execution."
msgstr ""

#: of paddle.fluid.layers.get_places:4
msgid "device count"
msgstr ""

#: of paddle.fluid.layers.get_places:6
msgid "device type"
msgstr ""

#: of paddle.fluid.layers.get_places:9
msgid "vector of Place"
msgstr ""

#: ../../source/api_reference/layers.rst:258
msgid "io"
msgstr ""

#: ../../source/api_reference/layers.rst:263
msgid "data"
msgstr ""

#: of paddle.fluid.layers.data:1
msgid "**Data Layer**"
msgstr ""

#: of paddle.fluid.layers.data:3
msgid ""
"This function takes in the input and based on whether data has to be "
"returned back as a minibatch, it creates the global variable by using the"
" helper functions. The global variables can be accessed by all the "
"following operators in the graph."
msgstr ""

#: of paddle.fluid.layers.data:8
msgid ""
"All the input variables of this function are passed in as local variables"
" to the LayerHelper constructor."
msgstr ""

#: of paddle.fluid.layers.data:11
msgid "The name/alias of the function"
msgstr ""

#: of paddle.fluid.layers.data:13
msgid "Tuple declaring the shape."
msgstr ""

#: of paddle.fluid.layers.data:15
msgid "Whether or not to append the data as a batch."
msgstr ""

#: of paddle.fluid.layers.data:17 paddle.fluid.layers.embedding:28
msgid "The type of data : float32, float_16, int etc"
msgstr ""

#: of paddle.fluid.layers.data:19
msgid "The output type. By default it is LOD_TENSOR."
msgstr ""

#: of paddle.fluid.layers.data:21
msgid "The LoD Level. 0 means the input data is not a sequence."
msgstr ""

#: of paddle.fluid.layers.data:23
msgid "A boolean that mentions whether gradient should flow."
msgstr ""

#: of paddle.fluid.layers.data:26
msgid "The global variable that gives access to the data."
msgstr ""

#: ../../source/api_reference/layers.rst:271
msgid "BlockGuardServ"
msgstr ""

#: of paddle.fluid.layers.BlockGuardServ:1
msgid "BlockGuardServ class."
msgstr ""

#: of paddle.fluid.layers.BlockGuardServ:3
msgid "BlockGuardServ class is used to create an op with a block in a program."
msgstr ""

#: ../../source/api_reference/layers.rst:280
msgid "ListenAndServ"
msgstr ""

#: of paddle.fluid.layers.ListenAndServ:1
msgid "ListenAndServ class."
msgstr ""

#: of paddle.fluid.layers.ListenAndServ:3
msgid ""
"ListenAndServ class is used to wrap listen_and_serv op to create a server"
" which can receive variables from clients and run a block."
msgstr ""

#: ../../source/api_reference/layers.rst:289
msgid "Send"
msgstr ""

#: of paddle.fluid.layers.Send:1
msgid "Send layer"
msgstr ""

#: of paddle.fluid.layers.Send:3
msgid "comma seperated IP:PORT pairs in the order of send_vars to send"
msgstr ""

#: of paddle.fluid.layers.Send:5
msgid "vars to send"
msgstr ""

#: of paddle.fluid.layers.Send:6
msgid "vars to get from server after send completes."
msgstr ""

#: of paddle.fluid.layers.Send:8
msgid ""
"Send variables to the server side, and get vars from server side when "
"server have finished running server side program."
msgstr ""

#: ../../source/api_reference/layers.rst:297
msgid "open_recordio_file"
msgstr ""

#: of paddle.fluid.layers.open_recordio_file:1
msgid ""
"Open a recordio file and return the reader object. The returned reader "
"object is thread-safe."
msgstr ""

#: of paddle.fluid.layers.open_recordio_file:3
msgid ""
"NOTE: This is a very low-level API. It is used for debugging data file or"
" training. Please use `open_files` instead of this API for production "
"usage."
msgstr ""

#: of paddle.fluid.layers.open_recordio_file:7
msgid "The filename of record file. This file will given to reader."
msgstr ""

#: of paddle.fluid.layers.open_files:9 paddle.fluid.layers.open_recordio_file:9
#: paddle.fluid.layers.random_data_generator:13
msgid "List of tuples which declaring data shapes."
msgstr ""

#: of paddle.fluid.layers.open_recordio_file:11
msgid "The LoD levels of each data."
msgstr ""

#: of paddle.fluid.layers.open_files:13
#: paddle.fluid.layers.open_recordio_file:13
msgid "List of strs which declaring data type."
msgstr ""

#: of paddle.fluid.layers.open_files:19
#: paddle.fluid.layers.open_recordio_file:15
msgid "Number of passes to run."
msgstr ""

#: of paddle.fluid.layers.open_files:21
#: paddle.fluid.layers.open_recordio_file:17
#: paddle.fluid.layers.random_data_generator:17
msgid "Set it as True if you are going to run subsequent operators in parallel."
msgstr ""

#: of paddle.fluid.layers.open_recordio_file:21
msgid "The created random reader."
msgstr ""

#: ../../source/api_reference/layers.rst:305
msgid "open_files"
msgstr ""

#: of paddle.fluid.layers.open_files:1
msgid "Open files"
msgstr ""

#: of paddle.fluid.layers.open_files:3
msgid ""
"This layer takes a list of files to read from and returns a Reader "
"Variable. Via the Reader Variable, we can get data from given files. All "
"files must have name suffixs to indicate their formats, e.g., "
"'*.recordio'."
msgstr ""

#: of paddle.fluid.layers.open_files:7
msgid "The list of file names."
msgstr ""

#: of paddle.fluid.layers.open_files:11
#: paddle.fluid.layers.random_data_generator:15
msgid "List of ints which declaring data lod_level."
msgstr ""

#: of paddle.fluid.layers.open_files:15
msgid "The maximal concurrent prefetch thread number."
msgstr ""

#: of paddle.fluid.layers.open_files:17
msgid "The size of prefetch buffer."
msgstr ""

#: of paddle.fluid.layers.open_files:25
msgid "A Reader Variable via which we can get file data."
msgstr ""

#: ../../source/api_reference/layers.rst:313
msgid "read_file"
msgstr ""

#: ../../source/api_reference/layers.rst:321
msgid "shuffle"
msgstr ""

#: of paddle.fluid.layers.shuffle:1
msgid "Shuffle the reader."
msgstr ""

#: ../../source/api_reference/layers.rst:329
msgid "batch"
msgstr ""

#: ../../source/api_reference/layers.rst:337
msgid "double_buffer"
msgstr ""

#: of paddle.fluid.layers.double_buffer:1
msgid ""
"Wrap a double buffer reader. The data will copy to target place with a "
"double buffer queue. If the target place is None, the place that executor"
" perform on will be used."
msgstr ""

#: of paddle.fluid.layers.double_buffer:5
msgid "the reader variable need to be wrapped."
msgstr ""

#: of paddle.fluid.layers.double_buffer:7
msgid "the place of target data. Default is the sample place of executor perform."
msgstr ""

#: of paddle.fluid.layers.double_buffer:10
msgid "Variable name. None if the user does not care."
msgstr ""

#: of paddle.fluid.layers.double_buffer:13
msgid "wrapped reader with double buffer."
msgstr ""

#: ../../source/api_reference/layers.rst:345
msgid "random_data_generator"
msgstr ""

#: of paddle.fluid.layers.random_data_generator:1
msgid "Create a uniform random data generator"
msgstr ""

#: of paddle.fluid.layers.random_data_generator:3
msgid ""
"This layer returns a Reader Variable. Instead of opening a file and "
"reading data from it, this Reader Variable generates float uniform random"
" data by itself. It can be used as a dummy reader to test a network "
"without opening a real file."
msgstr ""

#: of paddle.fluid.layers.random_data_generator:9
msgid "The lower bound of data's uniform distribution."
msgstr ""

#: of paddle.fluid.layers.random_data_generator:11
msgid "The upper bound of data's uniform distribution."
msgstr ""

#: of paddle.fluid.layers.random_data_generator:21
msgid "A Reader Variable from which we can get random data."
msgstr ""

#: ../../source/api_reference/layers.rst:353
msgid "Preprocessor"
msgstr ""

#: of paddle.fluid.layers.Preprocessor:1
msgid "A block for data pre-processing in reader."
msgstr ""

#: of paddle.fluid.layers.Preprocessor:3
msgid "A reader variable."
msgstr ""

#: of paddle.fluid.layers.Preprocessor:5
msgid "The name of the reader."
msgstr ""

#: ../../source/api_reference/layers.rst:362
msgid "load"
msgstr ""

#: of paddle.fluid.layers.load:1
msgid "Load operator will load a tensor variable from disk file."
msgstr ""

#: of paddle.fluid.layers.load:7
msgid "The tensor need to be loaded."
msgstr ""

#: of paddle.fluid.layers.load:9
msgid "Variable will be loaded from \"file_path\"."
msgstr ""

#: of paddle.fluid.layers.load:11
msgid ""
"If true, the tensor will be first loaded and then converted to float16 "
"data type. Otherwise, the tensor will be directly loaded without data "
"type conversion. Default is false."
msgstr ""

#: ../../source/api_reference/layers.rst:368
msgid "nn"
msgstr ""

#: ../../source/api_reference/layers.rst:373
msgid "fc"
msgstr ""

#: of paddle.fluid.layers.fc:1
msgid "**Fully Connected Layer**"
msgstr ""

#: of paddle.fluid.layers.fc:3
msgid ""
"The fully connected layer can take multiple tensors as its inputs. It "
"creates a variable called weights for each input tensor, which represents"
" a fully connected weight matrix from each input unit to each output "
"unit. The fully connected layer multiplies each input tensor with its "
"coresponding weight to produce an output Tensor. If multiple input "
"tensors are given, the results of multiple multiplications will be sumed "
"up. If bias_attr is not None, a bias variable will be created and added "
"to the output. Finally, if activation is not None, it will be applied to "
"the output as well."
msgstr ""

#: of paddle.fluid.layers.fc:12
msgid "This process can be formulated as follows:"
msgstr ""

#: of paddle.fluid.layers.conv2d_transpose:18 paddle.fluid.layers.conv3d:18
#: paddle.fluid.layers.conv3d_transpose:18 paddle.fluid.layers.fc:18
#: paddle.fluid.layers.lrn:13 paddle.fluid.layers.row_conv:11
#: paddle.fluid.layers.square_error_cost:12
msgid "In the above equation:"
msgstr ""

#: of paddle.fluid.layers.fc:20
msgid ":math:`N`: Number of the input."
msgstr ""

#: of paddle.fluid.layers.fc:21
msgid ":math:`X_i`: The input tensor."
msgstr ""

#: of paddle.fluid.layers.fc:22
msgid ":math:`W`: The weights created by this layer."
msgstr ""

#: of paddle.fluid.layers.fc:23
msgid ":math:`b`: The bias parameter created by this layer (if needed)."
msgstr ""

#: of paddle.fluid.layers.fc:24
msgid ":math:`Act`: The activation function."
msgstr ""

#: of paddle.fluid.layers.fc:25
msgid ":math:`Out`: The output tensor."
msgstr ""

#: of paddle.fluid.layers.fc:27
msgid ""
"The input tensor(s) of this layer, and the dimension of the input "
"tensor(s) is at least 2."
msgstr ""

#: of paddle.fluid.layers.fc:30
msgid "The number of output units in this layer."
msgstr ""

#: of paddle.fluid.layers.fc:32
msgid ""
"The fc layer can accept an input tensor with more than two dimensions. If"
" this happens, the multidimensional tensor will first be flattened into a"
" 2-dimensional matrix. The parameter `num_flatten_dims` determines how "
"the input tensor is flattened: the first `num_flatten_dims` (inclusive, "
"index starts from 1) dimensions will be flatten to form the first "
"dimension of the final matrix (height of the matrix), and the rest "
"`rank(X) - num_flatten_dims` dimensions are flattened to form the second "
"dimension of the final matrix (width of the matrix). For example, suppose"
" `X` is a 6-dimensional tensor with a shape [2, 3, 4, 5, 6], and "
"`num_flatten_dims` = 3. Then, the flattened matrix will have a shape [2 x"
" 3 x 4, 5 x 6] = [24, 30]."
msgstr ""

#: of paddle.fluid.layers.fc:42
msgid "The parameter attribute for learnable parameters/weights of this layer."
msgstr ""

#: of paddle.fluid.layers.fc:45
msgid ""
"The parameter attribute for the bias of this layer. If it is set to None,"
" no bias will be added to the output units."
msgstr ""

#: of paddle.fluid.layers.fc:48
msgid "Activation to be applied to the output of this layer."
msgstr ""

#: of paddle.fluid.layers.fc:50
msgid "A flag indicating whether execution is in test phase."
msgstr ""

#: of paddle.fluid.layers.fc:52
msgid ""
"Use mkldnn kernel or not, it is valid only when the mkldnn library is "
"installed. Default: False"
msgstr ""

#: of paddle.fluid.layers.fc:58 paddle.fluid.layers.lrn:35
msgid "A tensor variable storing the transformation result."
msgstr ""

#: of paddle.fluid.layers.fc:60
msgid ":exc:`ValueError` -- If rank of the input tensor is less than 2."
msgstr ""

#: ../../source/api_reference/layers.rst:381
msgid "embedding"
msgstr ""

#: of paddle.fluid.layers.embedding:1
msgid "**Embedding Layer**"
msgstr ""

#: of paddle.fluid.layers.embedding:3
msgid ""
"This layer is used to lookup embeddings of IDs, provided by "
":attr:`input`, in a lookup table. The result of this lookup is the "
"embedding of each ID in the :attr:`input`."
msgstr ""

#: of paddle.fluid.layers.embedding:7
msgid ""
"All the input variables are passed in as local variables to the "
"LayerHelper constructor."
msgstr ""

#: of paddle.fluid.layers.embedding:10
msgid "The tensor variable containing the IDs."
msgstr ""

#: of paddle.fluid.layers.embedding:12
msgid ""
"The shape of the look up table parameter. It should have two elements "
"which indicate the size of the dictionary of embeddings and the size of "
"each embedding vector respectively."
msgstr ""

#: of paddle.fluid.layers.embedding:16
msgid "The flag indicating whether to use sparse update."
msgstr ""

#: of paddle.fluid.layers.embedding:18
msgid "Whether to run lookup table from remote parameter server."
msgstr ""

#: of paddle.fluid.layers.embedding:20
msgid ""
"If :attr:`None`, it makes no effect to lookup. Otherwise the given "
":attr:`padding_idx` indicates padding the output with zeros whenever "
"lookup encounters it in :attr:`input`. If :math:`padding_idx < 0`, the "
":attr:`padding_idx` to use in lookup is :math:`size[0] + dim`."
msgstr ""

#: of paddle.fluid.layers.embedding:26
msgid "Parameters for this layer"
msgstr ""

#: of paddle.fluid.layers.embedding:31
msgid ""
"The tensor variable storing the embeddings of the                   "
"supplied inputs."
msgstr ""

#: ../../source/api_reference/layers.rst:389
msgid "dynamic_lstm"
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:1
msgid "**Dynamic LSTM Layer**"
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:3
msgid ""
"The defalut implementation is diagonal/peephole connection "
"(https://arxiv.org/pdf/1402.1128.pdf), the formula is as follows:"
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:20
msgid ""
"where the :math:`W` terms denote weight matrices (e.g. :math:`W_{xi}` is "
"the matrix of weights from the input gate to the input), :math:`W_{ic},"
"     W_{fc}, W_{oc}` are diagonal weight matrices for peephole "
"connections. In our implementation, we use vectors to reprenset these "
"diagonal weight matrices. The :math:`b` terms denote bias vectors "
"(:math:`b_i` is the input gate bias vector), :math:`\\sigma` is the non-"
"linear activations, such as logistic sigmoid function, and :math:`i, f, "
"o` and :math:`c` are the input gate, forget gate, output gate, and cell "
"activation vectors, respectively, all of which have the same size as the "
"cell output activation vector :math:`h`."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:29
msgid ""
"The :math:`\\odot` is the element-wise product of the vectors. "
":math:`act_g` and :math:`act_h` are the cell input and cell output "
"activation functions and `tanh` is usually used for them. "
":math:`\\tilde{c_t}` is also called candidate hidden state, which is "
"computed based on the current input and the previous hidden state."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:35 paddle.fluid.layers.dynamic_lstmp:42
msgid ""
"Set `use_peepholes` to `False` to disable peephole connection. The "
"formula is omitted here, please refer to the paper "
"http://www.bioinf.jku.at/publications/older/2604.pdf for details."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:39
msgid ""
"Note that these :math:`W_{xi}x_{t}, W_{xf}x_{t}, W_{xc}x_{t}, "
"W_{xo}x_{t}` operations on the input :math:`x_{t}` are NOT included in "
"this operator. Users can choose to use fully-connect layer before LSTM "
"layer."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:43
msgid ""
"The input of dynamic_lstm layer, which supports variable-time length "
"input sequence. The underlying tensor in this Variable is a matrix with "
"shape (T X 4D), where T is the total time steps in this mini-batch, D is "
"the hidden size."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:49 paddle.fluid.layers.dynamic_lstmp:56
msgid "4 * hidden size."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:51
msgid ""
"The initial hidden state is an optional input, default is zero. This is a"
" tensor with shape (N x D), where N is the batch size and D is the hidden"
" size."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:55
msgid ""
"The initial cell state is an optional input, default is zero. This is a "
"tensor with shape (N x D), where N is the batch size. `h_0` and `c_0` can"
" be NULL but only at the same time."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:59
msgid ""
"The parameter attribute for the learnable hidden-hidden weights.  - "
"Weights = {:math:`W_{ch}, W_{ih},"
"                                                 W_{fh}, W_{oh}`} - The "
"shape is (D x 4D), where D is the hidden   size."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:59
msgid "The parameter attribute for the learnable hidden-hidden weights."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:62
msgid ""
"Weights = {:math:`W_{ch}, W_{ih},"
"                                                 W_{fh}, W_{oh}`}"
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:63
msgid "The shape is (D x 4D), where D is the hidden size."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:66 paddle.fluid.layers.dynamic_lstmp:70
msgid ""
"The bias attribute for the learnable bias weights, which contains two "
"parts, input-hidden bias weights and peephole connections weights if "
"setting `use_peepholes` to `True`.  1. `use_peepholes = False`   - Biases"
" = {:math:`b_c, b_i, b_f, b_o`}.   - The shape is (1 x 4D). 2. "
"`use_peepholes = True`   - Biases = { :math:`b_c, b_i, b_f, b_o, W_{ic},"
"                                                  W_{fc}, W_{oc}`}.   - "
"The shape is (1 x 7D)."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:66 paddle.fluid.layers.dynamic_lstmp:70
msgid ""
"The bias attribute for the learnable bias weights, which contains two "
"parts, input-hidden bias weights and peephole connections weights if "
"setting `use_peepholes` to `True`."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:71 paddle.fluid.layers.dynamic_lstmp:75
msgid "`use_peepholes = False`"
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:72 paddle.fluid.layers.dynamic_lstmp:76
msgid "Biases = {:math:`b_c, b_i, b_f, b_o`}."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:73 paddle.fluid.layers.dynamic_lstmp:77
msgid "The shape is (1 x 4D)."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:74 paddle.fluid.layers.dynamic_lstmp:78
msgid "`use_peepholes = True`"
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:75 paddle.fluid.layers.dynamic_lstmp:79
msgid ""
"Biases = { :math:`b_c, b_i, b_f, b_o, W_{ic},"
"                                                  W_{fc}, W_{oc}`}."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:76 paddle.fluid.layers.dynamic_lstmp:80
msgid "The shape is (1 x 7D)."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:78 paddle.fluid.layers.dynamic_lstmp:82
msgid "Whether to enable diagonal/peephole connections, default `True`."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:81 paddle.fluid.layers.dynamic_lstmp:85
msgid "Whether to compute reversed LSTM, default `False`."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:83 paddle.fluid.layers.dynamic_lstmp:87
msgid ""
"The activation for input gate, forget gate and output gate. Choices = "
"[\"sigmoid\", \"tanh\", \"relu\", \"identity\"], default \"sigmoid\"."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:87 paddle.fluid.layers.dynamic_lstmp:91
msgid ""
"The activation for cell output. Choices = [\"sigmoid\", \"tanh\", "
"\"relu\", \"identity\"], default \"tanh\"."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:90 paddle.fluid.layers.dynamic_lstmp:94
msgid ""
"The activation for candidate hidden state. Choices = [\"sigmoid\", "
"\"tanh\",     \"relu\", \"identity\"], default \"tanh\"."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:90 paddle.fluid.layers.dynamic_lstmp:94
msgid ""
"The activation for candidate hidden state. Choices = [\"sigmoid\", "
"\"tanh\","
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:92 paddle.fluid.layers.dynamic_lstmp:96
#: paddle.fluid.layers.dynamic_lstmp:101
msgid "\"relu\", \"identity\"],"
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:93 paddle.fluid.layers.dynamic_lstmp:97
#: paddle.fluid.layers.dynamic_lstmp:102
msgid "default \"tanh\"."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:95 paddle.fluid.layers.dynamic_lstmp:104
msgid "Data type. Choices = [\"float32\", \"float64\"], default \"float32\"."
msgstr ""

#: of paddle.fluid.layers.concat:10 paddle.fluid.layers.conv2d:89
#: paddle.fluid.layers.conv2d_transpose:88 paddle.fluid.layers.conv3d:84
#: paddle.fluid.layers.conv3d_transpose:89 paddle.fluid.layers.dropout:19
#: paddle.fluid.layers.dynamic_lstm:97 paddle.fluid.layers.dynamic_lstmp:106
#: paddle.fluid.layers.image_resize:22 paddle.fluid.layers.label_smooth:35
#: paddle.fluid.layers.lstm_unit:52 paddle.fluid.layers.matmul:36
#: paddle.fluid.layers.pad:35 paddle.fluid.layers.pool2d:22
#: paddle.fluid.layers.pool3d:22 paddle.fluid.layers.reduce_max:15
#: paddle.fluid.layers.reduce_mean:15 paddle.fluid.layers.reduce_min:15
#: paddle.fluid.layers.reduce_prod:15 paddle.fluid.layers.reduce_sum:15
#: paddle.fluid.layers.sequence_expand:46 paddle.fluid.layers.split:15
#: paddle.fluid.layers.topk:16
msgid ""
"A name for this layer(optional). If set None, the layer will be named "
"automatically."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstm:101
msgid ""
"The hidden state, and cell state of LSTM. The shape of both         is (T"
" x D), and lod is the same with the `input`."
msgstr ""

#: ../../source/api_reference/layers.rst:397
msgid "dynamic_lstmp"
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:1
msgid "**Dynamic LSTMP Layer**"
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:3
msgid ""
"LSTMP (LSTM with recurrent projection) layer has a separate projection "
"layer after the LSTM layer, projecting the original hidden state to a "
"lower-dimensional one, which is proposed to reduce the number of total "
"parameters and furthermore computational complexity for the LSTM, "
"espeacially for the case that the size of output units is relative large "
"(https://research.google.com/pubs/archive/43905.pdf)."
msgstr ""

#: of paddle.fluid.layers.dynamic_gru:6 paddle.fluid.layers.dynamic_lstmp:10
#: paddle.fluid.layers.layer_norm:7 paddle.fluid.layers.lrn:4
msgid "The formula is as follows:"
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:28
msgid "In the above formula:"
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:30
msgid ""
":math:`W`: Denotes weight matrices (e.g. :math:`W_{xi}` is           the "
"matrix of weights from the input gate to the input)."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:31
msgid ""
":math:`W_{ic}`, :math:`W_{fc}`, :math:`W_{oc}`: Diagonal weight"
"           matrices for peephole connections. In our implementation,"
"           we use vectors to reprenset these diagonal weight matrices."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:32
msgid ""
":math:`b`: Denotes bias vectors (e.g. :math:`b_i` is the input gate"
"           bias vector)."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:33
msgid ":math:`\\sigma`: The activation, such as logistic sigmoid function."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:34
msgid ""
":math:`i, f, o` and :math:`c`: The input gate, forget gate, output"
"           gate, and cell activation vectors, respectively, all of which "
"have           the same size as the cell output activation vector "
":math:`h`."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:35
msgid ":math:`h`: The hidden state."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:36
msgid ":math:`r`: The recurrent projection of the hidden state."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:37
msgid ""
":math:`\\tilde{c_t}`: The candidate hidden state, whose           "
"computation is based on the current input and previous hidden state."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:38
msgid ":math:`\\odot`: The element-wise product of the vectors."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:39
msgid ""
":math:`act_g` and :math:`act_h`: The cell input and cell output"
"           activation functions and `tanh` is usually used for them."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:40
msgid ""
":math:`\\overline{act_h}`: The activation function for the projection"
"           output, usually using `identity` or same as :math:`act_h`."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:46
msgid ""
"Note that these :math:`W_{xi}x_{t}, W_{xf}x_{t}, W_{xc}x_{t}, "
"W_{xo}x_{t}` operations on the input :math:`x_{t}` are NOT included in "
"this operator. Users can choose to use fully-connected layer before LSTMP"
" layer."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:50
msgid ""
"The input of dynamic_lstmp layer, which supports variable-time length "
"input sequence. The underlying tensor in this Variable is a matrix with "
"shape (T X 4D), where T is the total time steps in this mini-batch, D is "
"the hidden size."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:58
msgid "The size of projection output."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:60
msgid ""
"The parameter attribute for the learnable hidden-hidden weight and "
"projection weight.  - Hidden-hidden weight = {:math:`W_{ch}, W_{ih},"
"                                                 W_{fh}, W_{oh}`}. - The "
"shape of hidden-hidden weight is (P x 4D),   where P is the projection "
"size and D the hidden   size. - Projection weight = {:math:`W_{rh}`}. - "
"The shape of projection weight is (D x P)."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:60
msgid ""
"The parameter attribute for the learnable hidden-hidden weight and "
"projection weight."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:63
msgid ""
"Hidden-hidden weight = {:math:`W_{ch}, W_{ih},"
"                                                 W_{fh}, W_{oh}`}."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:64
msgid ""
"The shape of hidden-hidden weight is (P x 4D), where P is the projection "
"size and D the hidden size."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:67
msgid "Projection weight = {:math:`W_{rh}`}."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:68
msgid "The shape of projection weight is (D x P)."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:99
msgid ""
"The activation for projection output. Choices = [\"sigmoid\", \"tanh\","
"     \"relu\", \"identity\"], default \"tanh\"."
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:99
msgid "The activation for projection output. Choices = [\"sigmoid\", \"tanh\","
msgstr ""

#: of paddle.fluid.layers.dynamic_lstmp:110
msgid ""
"The projection of hidden state, and cell state of LSTMP. The"
"                shape of projection is (T x P), for the cell state which "
"is                (T x D), and both LoD is the same with the `input`."
msgstr ""

#: ../../source/api_reference/layers.rst:405
msgid "dynamic_gru"
msgstr ""

#: of paddle.fluid.layers.dynamic_gru:1
msgid "**Dynamic GRU Layer**"
msgstr ""

#: of paddle.fluid.layers.dynamic_gru:3
msgid ""
"Refer to `Empirical Evaluation of Gated Recurrent Neural Networks on "
"Sequence Modeling <https://arxiv.org/abs/1412.3555>`_"
msgstr ""

#: of paddle.fluid.layers.dynamic_gru:18
msgid ""
"The :math:`\\odot` is the element-wise product of the vectors. "
":math:`act_g` is the update gate and reset gate activation function and "
":math:`sigmoid` is usually used for it. :math:`act_c` is the activation "
"function for candidate hidden state and :math:`tanh` is usually used for "
"it."
msgstr ""

#: of paddle.fluid.layers.dynamic_gru:23
msgid ""
"Note that these :math:`W_{ux}x_{t}, W_{rx}x_{t}, W_{cx}x_{t}` operations "
"on the input :math:`x_{t}` are NOT included in this operator. Users can "
"choose to use fully-connect layer before GRU layer."
msgstr ""

#: of paddle.fluid.layers.dynamic_gru:27
msgid ""
"The input of dynamic_gru layer, which supports variable-time length input"
" sequence. The underlying tensor in this Variable is a matrix with shape "
":math:`(T \\times 3D)`, where :math:`T` is the total time steps in this "
"mini-batch, :math:`D` is the hidden size."
msgstr ""

#: of paddle.fluid.layers.dynamic_gru:33
msgid "The dimension of the gru cell."
msgstr ""

#: of paddle.fluid.layers.dynamic_gru:35
msgid ""
"The parameter attribute for the learnable hidden-hidden weight matrix. "
"Note:  - The shape of the weight matrix is :math:`(T \\times 3D)`, where"
"   :math:`D` is the hidden size. - All elements in the weight matrix can "
"be divided into two parts.   The first part are weights of the update "
"gate and reset gate with   shape :math:`(D \\times 2D)`, and the second "
"part are weights for   candidate hidden state with shape :math:`(D "
"\\times D)`."
msgstr ""

#: of paddle.fluid.layers.dynamic_gru:35
msgid ""
"The parameter attribute for the learnable hidden-hidden weight matrix. "
"Note:"
msgstr ""

#: of paddle.fluid.layers.dynamic_gru:38
msgid ""
"The shape of the weight matrix is :math:`(T \\times 3D)`, where :math:`D`"
" is the hidden size."
msgstr ""

#: of paddle.fluid.layers.dynamic_gru:40
msgid ""
"All elements in the weight matrix can be divided into two parts. The "
"first part are weights of the update gate and reset gate with shape "
":math:`(D \\times 2D)`, and the second part are weights for candidate "
"hidden state with shape :math:`(D \\times D)`."
msgstr ""

#: of paddle.fluid.layers.dynamic_gru:45
msgid "The parameter attribute for learnable the hidden-hidden bias."
msgstr ""

#: of paddle.fluid.layers.dynamic_gru:48
msgid "Whether to compute reversed GRU, default :attr:`False`."
msgstr ""

#: of paddle.fluid.layers.dynamic_gru:51
msgid ""
"The activation for update gate and reset gate. Choices = [\"sigmoid\", "
"\"tanh\", \"relu\", \"identity\"], default \"sigmoid\"."
msgstr ""

#: of paddle.fluid.layers.dynamic_gru:54
msgid ""
"The activation for candidate hidden state. Choices = [\"sigmoid\", "
"\"tanh\", \"relu\", \"identity\"], default \"tanh\"."
msgstr ""

#: of paddle.fluid.layers.dynamic_gru:57
msgid "The hidden output of the first time step."
msgstr ""

#: of paddle.fluid.layers.dynamic_gru:60
msgid ""
"The hidden state of GRU. The shape is :math:`(T \\times D)`,             "
"and lod is the same with the input."
msgstr ""

#: ../../source/api_reference/layers.rst:413
msgid "gru_unit"
msgstr ""

#: of paddle.fluid.layers.gru_unit:1
msgid "GRU unit layer. The equation of a gru step is:"
msgstr ""

#: of paddle.fluid.layers.gru_unit:12
msgid ""
"The inputs of gru unit includes :math:`z_t`, :math:`h_{t-1}`. In terms of"
" the equation above, the :math:`z_t` is split into 3 parts - "
":math:`xu_t`, :math:`xr_t` and :math:`xm_t`. This means that in order to "
"implement a full GRU unit operator for an input, a fully connected layer "
"has to be applied, such that :math:`z_t = W_{fc}x_t`."
msgstr ""

#: of paddle.fluid.layers.gru_unit:18
msgid ""
"The terms :math:`u_t` and :math:`r_t` represent the update and reset "
"gates of the GRU cell. Unlike LSTM, GRU has one lesser gate. However, "
"there is an intermediate candidate hidden output, which is denoted by "
":math:`m_t`. This layer has three outputs :math:`h_t`, :math:`dot(r_t, "
"h_{t-1})` and concatenation of :math:`u_t`, :math:`r_t` and :math:`m_t`."
msgstr ""

#: of paddle.fluid.layers.gru_unit:24
msgid "The fc transformed input value of current step."
msgstr ""

#: of paddle.fluid.layers.gru_unit:26
msgid "The hidden value of lstm unit from previous step."
msgstr ""

#: of paddle.fluid.layers.gru_unit:28
msgid "The input dimension value."
msgstr ""

#: of paddle.fluid.layers.gru_unit:30
msgid "The weight parameters for gru unit. Default: None"
msgstr ""

#: of paddle.fluid.layers.gru_unit:32
msgid "The bias parameters for gru unit. Default: None"
msgstr ""

#: of paddle.fluid.layers.gru_unit:34
msgid "The activation type for cell (actNode). Default: 'tanh'"
msgstr ""

#: of paddle.fluid.layers.gru_unit:37
msgid "The activation type for gates (actGate). Default: 'sigmoid'"
msgstr ""

#: of paddle.fluid.layers.gru_unit:41
msgid "The hidden value, reset-hidden value and gate values."
msgstr ""

#: ../../source/api_reference/layers.rst:421
msgid "linear_chain_crf"
msgstr ""

#: of paddle.fluid.layers.linear_chain_crf:1
msgid "Linear Chain CRF."
msgstr ""

#: of paddle.fluid.layers.linear_chain_crf:3
msgid ""
"Conditional Random Field defines an undirected probabilistic graph with "
"nodes denoting random variables and edges denoting dependencies between "
"these variables. CRF learns the conditional probability :math:`P(Y|X)`, "
"where :math:`X = (x_1, x_2, ... , x_n)` are structured inputs and "
":math:`Y = (y_1, y_2, ... , y_n)` are labels for the inputs."
msgstr ""

#: of paddle.fluid.layers.linear_chain_crf:5
msgid ""
"Linear chain CRF is a special case of CRF that is useful for sequence "
"labeling task. Sequence labeling tasks do not assume a lot of conditional"
" independences among inputs. The only constraint they impose is that the "
"input and output must be linear sequences. Thus, the graph of such a CRF "
"is a simple chain or a line, which results in the linear chain CRF."
msgstr ""

#: of paddle.fluid.layers.linear_chain_crf:7
msgid ""
"This operator implements the Forward-Backward algorithm for the linear "
"chain CRF. Please refer to http://www.cs.columbia.edu/~mcollins/fb.pdf "
"and http://cseweb.ucsd.edu/~elkan/250Bwinter2012/loglinearCRFs.pdf for "
"details."
msgstr ""

#: of paddle.fluid.layers.linear_chain_crf:9
msgid ""
"Equation: 1. Denote Input(Emission) to this operator as :math:`x` here. "
"2. The first D values of Input(Transition) to this operator are for "
"starting weights, denoted as :math:`a` here. 3. The next D values of "
"Input(Transition) of this operator are for ending weights, denoted as "
":math:`b` here. 4. The remaning values of Input(Transition) are for "
"transition weights, denoted as :math:`w` here. 5. Denote Input(Label) as "
":math:`s` here."
msgstr ""

#: of paddle.fluid.layers.linear_chain_crf:11
msgid ""
"The probability of a sequence :math:`s` of length :math:`L` is defined "
"as: $$P(s) = (1/Z) \\exp(a_{s_1} + b_{s_L} + \\sum_{l=1}^L x_{s_l} + "
"\\sum_{l=2}^L w_{s_{l-1},s_l})$$"
msgstr ""

#: of paddle.fluid.layers.linear_chain_crf:13
msgid ""
"where :math:`Z` is a normalization value so that the sum of :math:`P(s)` "
"over all possible sequences is 1, and :math:`x` is the emission feature "
"weight to the linear chain CRF."
msgstr ""

#: of paddle.fluid.layers.linear_chain_crf:15
msgid ""
"Finally, the linear chain CRF operator outputs the logarithm of the "
"conditional likelihood of each training sample in a mini-batch."
msgstr ""

#: of paddle.fluid.layers.linear_chain_crf:17
msgid ""
"NOTE: 1. The feature function for a CRF is made up of the emission "
"features and the transition features. The emission feature weights are "
"NOT computed in this operator. They MUST be computed first before this "
"operator is called."
msgstr ""

#: of paddle.fluid.layers.linear_chain_crf:19
msgid ""
"Because this operator performs global normalization over all possible "
"sequences internally, it expects UNSCALED emission feature weights. "
"Please do not call this op with the emission feature being output of any "
"nonlinear activation."
msgstr ""

#: of paddle.fluid.layers.linear_chain_crf:21
msgid "The 2nd dimension of Input(Emission) MUST be equal to the tag number."
msgstr ""

#: of paddle.fluid.layers.linear_chain_crf:27
msgid ""
"(LoDTensor, default LoDTensor<float>) A 2-D LoDTensor with shape [N x D],"
" where N is the size of the mini-batch and D is the total tag number. The"
" unscaled emission weight matrix for the linear chain CRF."
msgstr ""

#: of paddle.fluid.layers.linear_chain_crf:29
msgid ""
"(LoDTensor, default LoDTensor<int64_t>) A LoDTensor with shape [N x 1], "
"where N is the total element number in a mini-batch. The ground truth"
msgstr ""

#: of paddle.fluid.layers.linear_chain_crf:31
msgid "The attribute of the learnable parameter."
msgstr ""

#: of paddle.fluid.layers.linear_chain_crf:34
msgid ""
"S is equal to the sequence number in a mini-batch. The output is no "
"longer a LoDTensor"
msgstr ""

#: ../../source/api_reference/layers.rst:429
msgid "crf_decoding"
msgstr ""

#: of paddle.fluid.layers.crf_decoding:1
msgid ""
"The crf_decoding operator reads the emission feature weights and the "
"transition feature weights learned by the linear_chain_crf operator. It "
"implements the Viterbi algorithm which is a dynamic programming algorithm"
" for finding the most likely sequence of hidden states, called the "
"Viterbi path, that results in a sequence of observed tags."
msgstr ""

#: of paddle.fluid.layers.crf_decoding:3
msgid ""
"The output of this operator changes according to whether Input(Label) is "
"given:"
msgstr ""

#: of paddle.fluid.layers.crf_decoding:5
msgid "Input(Label) is given:"
msgstr ""

#: of paddle.fluid.layers.crf_decoding:7
msgid ""
"This happens in training. This operator is used to co-work with the "
"chunk_eval operator."
msgstr ""

#: of paddle.fluid.layers.crf_decoding:9
msgid ""
"When Input(Label) is given, the crf_decoding operator returns a row "
"vector with shape [N x 1] whose values are fixed to be 0, indicating an "
"incorrect prediction, or 1 indicating a tag is correctly predicted. Such "
"an output is the input to chunk_eval operator."
msgstr ""

#: of paddle.fluid.layers.crf_decoding:11
msgid "Input(Label) is not given:"
msgstr ""

#: of paddle.fluid.layers.crf_decoding:13
msgid "This is the standard decoding process."
msgstr ""

#: of paddle.fluid.layers.crf_decoding:15
msgid ""
"The crf_decoding operator returns a row vector with shape [N x 1] whose "
"values range from 0 to maximum tag number - 1. Each element indicates an "
"index of a predicted tag."
msgstr ""

#: of paddle.fluid.layers.crf_decoding:19
msgid ""
"(LoDTensor, default: LoDTensor<float>). A LoDTensor with shape [N x D] "
"where N is the size of the mini-batch and D is the total tag number. This"
" input is the unscaled emission weight matrix of the linear_chain_crf "
"operator"
msgstr ""

#: of paddle.fluid.layers.crf_decoding:21
msgid "The parameter attribute for training."
msgstr ""

#: of paddle.fluid.layers.crf_decoding:23
msgid ""
"(LoDTensor,  LoDTensor<int64_t>). The ground truth with shape [N x 1]. "
"This input is optional. See more details in the operator's comments"
msgstr ""

#: of paddle.fluid.layers.crf_decoding:26
msgid ""
"(LoDTensor, LoDTensor<int64_t>). The decoding results. What to return "
"changes depending on whether the Input(Label) (the ground truth) is "
"given. See more details in the operator's comment"
msgstr ""

#: ../../source/api_reference/layers.rst:437
msgid "cos_sim"
msgstr ""

#: of paddle.fluid.layers.cos_sim:1
msgid ""
"This function performs the cosine similarity between two tensors X and Y "
"and returns that as the output."
msgstr ""

#: of paddle.fluid.layers.cos_sim:4
msgid "The input X."
msgstr ""

#: of paddle.fluid.layers.cos_sim:6
msgid "The input Y."
msgstr ""

#: of paddle.fluid.layers.cos_sim:9
msgid "the output of cosine(X, Y)."
msgstr ""

#: ../../source/api_reference/layers.rst:445
msgid "cross_entropy"
msgstr ""

#: of paddle.fluid.layers.cross_entropy:1
msgid "**Cross Entropy Layer**"
msgstr ""

#: of paddle.fluid.layers.cross_entropy:3
msgid ""
"This layer computes the cross entropy between `input` and `label`. It "
"supports both standard cross-entropy and soft-label cross-entropy loss "
"computation."
msgstr ""

#: of paddle.fluid.layers.cross_entropy:12
msgid "One-hot cross-entropy:"
msgstr ""

#: of paddle.fluid.layers.cross_entropy:8
msgid ""
"`soft_label = False`, `Label[i, 0]` indicates the class index for sample "
"i:"
msgstr ""

#: of paddle.fluid.layers.cross_entropy:20
msgid "Soft-label cross-entropy:"
msgstr ""

#: of paddle.fluid.layers.cross_entropy:15
msgid ""
"`soft_label = True`, `Label[i, j]` indicates the soft label of class j "
"for sample i:"
msgstr ""

#: of paddle.fluid.layers.cross_entropy:22
msgid ""
"Please make sure that in this case the summation of each row of `label` "
"equals one."
msgstr ""

#: of paddle.fluid.layers.cross_entropy:28
msgid "One-hot cross-entropy with vecterized `label`:"
msgstr ""

#: of paddle.fluid.layers.cross_entropy:26
msgid ""
"As a special case of 2), when each row of 'label' has only one non-zero "
"element which is equal to 1, soft-label cross-entropy degenerates to a "
"one-hot cross-entropy with one-hot label representation."
msgstr ""

#: of paddle.fluid.layers.cross_entropy:30
msgid ""
"a 2-D tensor with shape [N x D], where N is the batch size and D is the "
"number of classes. This input is a probability computed by the previous "
"operator, which is almost always the result of a softmax operator."
msgstr ""

#: of paddle.fluid.layers.cross_entropy:36
msgid ""
"the ground truth which is a 2-D tensor. When `soft_label` is set to "
"`False`, `label` is a tensor<int64> with shape [N x 1]. When `soft_label`"
" is set to `True`, `label` is a tensor<float/double> with shape [N x D]."
msgstr ""

#: of paddle.fluid.layers.cross_entropy:42
msgid ""
"a flag indicating whether to interpretate the given labels as soft "
"labels, default `False`."
msgstr ""

#: of paddle.fluid.layers.cross_entropy:47
msgid "A 2-D tensor with shape [N x 1], the cross entropy loss."
msgstr ""

#: of paddle.fluid.layers.cross_entropy:49
msgid ""
"`ValueError` -- 1) the 1st dimension of `input` and `label` are not "
"equal. 2) when `soft_label == True`, and the 2nd dimension of"
msgstr ""

#: of paddle.fluid.layers.cross_entropy:51
msgid "`input` and `label` are not equal."
msgstr ""

#: of paddle.fluid.layers.cross_entropy:52
msgid "when `soft_label == False`, and the 2nd dimension of `label` is not 1."
msgstr ""

#: ../../source/api_reference/layers.rst:453
msgid "square_error_cost"
msgstr ""

#: of paddle.fluid.layers.square_error_cost:1
msgid "**Square error cost layer**"
msgstr ""

#: of paddle.fluid.layers.square_error_cost:3
msgid ""
"This layer accepts input predictions and target label and returns the "
"squared error cost."
msgstr ""

#: of paddle.fluid.layers.square_error_cost:6
msgid "For predictions, :math:`X`, and target labels, :math:`Y`, the equation is:"
msgstr ""

#: of paddle.fluid.layers.square_error_cost:14
msgid ":math:`X`: Input predictions, a tensor."
msgstr ""

#: of paddle.fluid.layers.square_error_cost:15
msgid ":math:`Y`: Input labels, a tensor."
msgstr ""

#: of paddle.fluid.layers.square_error_cost:16
msgid ":math:`Out`: Output value, same shape with :math:`X`."
msgstr ""

#: of paddle.fluid.layers.square_error_cost:18
msgid "Input tensor, has predictions."
msgstr ""

#: of paddle.fluid.layers.square_error_cost:20
msgid "Label tensor, has target labels."
msgstr ""

#: of paddle.fluid.layers.square_error_cost:23
msgid ""
"The tensor variable storing the element-wise squared error"
"                   difference of input and label."
msgstr ""

#: ../../source/api_reference/layers.rst:461
msgid "chunk_eval"
msgstr ""

#: of paddle.fluid.layers.chunk_eval:1
msgid ""
"This function computes and outputs the precision, recall and F1-score of "
"chunk detection."
msgstr ""

#: of paddle.fluid.layers.chunk_eval:4
msgid "prediction output of the network."
msgstr ""

#: of paddle.fluid.layers.chunk_eval:6
msgid "label of the test data set."
msgstr ""

#: of paddle.fluid.layers.chunk_eval:8
msgid ""
"(string, default IOB). The labeling scheme indicating how to encode the "
"chunks. Must be IOB, IOE, IOBES or plain. See below for details"
msgstr ""

#: of paddle.fluid.layers.chunk_eval:10
msgid "(int). The number of chunk type. See below for details"
msgstr ""

#: of paddle.fluid.layers.chunk_eval:12
msgid ""
"(list<int>) A list including chunk type ids indicating chunk types that "
"are not counted. See below for details"
msgstr ""

#: of paddle.fluid.layers.chunk_eval:15
msgid ""
"tuple containing: (precision, recall, f1_score,        num_infer_chunks, "
"num_label_chunks,        num_correct_chunks)"
msgstr ""

#: of paddle.fluid.layers.chunk_eval:18
msgid "tuple containing: (precision, recall, f1_score,"
msgstr ""

#: of paddle.fluid.layers.chunk_eval:18
msgid "num_infer_chunks, num_label_chunks, num_correct_chunks)"
msgstr ""

#: ../../source/api_reference/layers.rst:469
msgid "sequence_conv"
msgstr ""

#: of paddle.fluid.layers.sequence_conv:1
msgid ""
"This function creates the op for sequence_conv, using the inputs and "
"other convolutional configurations for the filters and stride as given in"
" the input parameters to the function."
msgstr ""

#: of paddle.fluid.layers.sequence_conv:5
msgid ""
"(LoDTensor) the input(X) is a LodTensor, which supports variable-time "
"length input sequence. The underlying tensor in this LoDTensor is a "
"matrix with shape (T, N), where T is the total time steps in this mini-"
"batch and N is the input_hidden_size"
msgstr ""

#: of paddle.fluid.layers.sequence_conv:7
msgid "number of filters."
msgstr ""

#: of paddle.fluid.layers.sequence_conv:9
msgid "the filter size (H and W)."
msgstr ""

#: of paddle.fluid.layers.sequence_conv:11
msgid "stride of the filter."
msgstr ""

#: of paddle.fluid.layers.sequence_conv:13
msgid "if True, add paddings."
msgstr ""

#: of paddle.fluid.layers.batch_norm:16 paddle.fluid.layers.nce:15
#: paddle.fluid.layers.sequence_conv:15
msgid "attributes for bias"
msgstr ""

#: of paddle.fluid.layers.batch_norm:14 paddle.fluid.layers.nce:13
#: paddle.fluid.layers.sequence_conv:17
msgid "attributes for parameter"
msgstr ""

#: of paddle.fluid.layers.sequence_conv:19
msgid "the activation type"
msgstr ""

#: of paddle.fluid.layers.sequence_conv:22
msgid "output of sequence_conv"
msgstr ""

#: ../../source/api_reference/layers.rst:477
msgid "conv2d"
msgstr ""

#: of paddle.fluid.layers.conv2d:1
msgid ""
"The convolution2D layer calculates the output based on the input, filter "
"and strides, paddings, dilations, groups parameters. Input and Output are"
" in NCHW format, where N is batch size, C is the number of channels, H is"
" the height of the feature, and W is the width of the feature. Filter is "
"in MCHW format, where M is the number of output image channels, C is the "
"number of input image channels, H is the height of the filter, and W is "
"the width of the filter. If the groups is greater than 1, C will equal "
"the number of input image channels divided by the groups. Please refer to"
" UFLDL's `convolution "
"<http://ufldl.stanford.edu/tutorial/supervised/FeatureExtractionUsingConvolution/>`_"
" for more detials. If bias attribution and activation type are provided, "
"bias is added to the output of the convolution, and the corresponding "
"activation function is applied to the final result."
msgstr ""

#: of paddle.fluid.layers.conv2d:16 paddle.fluid.layers.conv2d_transpose:12
#: paddle.fluid.layers.conv3d:12 paddle.fluid.layers.conv3d_transpose:12
msgid "For each input :math:`X`, the equation is:"
msgstr ""

#: of paddle.fluid.layers.conv2d:22
msgid "Where:"
msgstr ""

#: of paddle.fluid.layers.conv2d:24 paddle.fluid.layers.conv2d_transpose:20
msgid ":math:`X`: Input value, a tensor with NCHW format."
msgstr ""

#: of paddle.fluid.layers.conv2d:25 paddle.fluid.layers.conv2d_transpose:21
msgid ":math:`W`: Filter value, a tensor with MCHW format."
msgstr ""

#: of paddle.fluid.layers.conv2d:26 paddle.fluid.layers.conv3d:22
msgid ":math:`\\ast`: Convolution operation."
msgstr ""

#: of paddle.fluid.layers.conv2d:27 paddle.fluid.layers.conv3d:23
msgid ":math:`b`: Bias value, a 2-D tensor with shape [M, 1]."
msgstr ""

#: of paddle.fluid.layers.conv2d:28 paddle.fluid.layers.conv3d:24
msgid ":math:`\\sigma`: Activation function."
msgstr ""

#: of paddle.fluid.layers.conv2d:29
msgid ""
":math:`Out`: Output value, the shape of :math:`Out` and :math:`X` may be "
"different."
msgstr ""

#: of paddle.fluid.layers.conv2d:31 paddle.fluid.layers.conv2d_transpose:26
#: paddle.fluid.layers.conv3d:28 paddle.fluid.layers.conv3d_transpose:26
msgid "Example"
msgstr ""

#: of paddle.fluid.layers.conv2d:33 paddle.fluid.layers.conv2d_transpose:28
#: paddle.fluid.layers.conv3d:30 paddle.fluid.layers.conv3d_transpose:28
msgid "Input:"
msgstr ""

#: of paddle.fluid.layers.conv2d:35
msgid "Input shape: :math:`(N, C_{in}, H_{in}, W_{in})`"
msgstr ""

#: of paddle.fluid.layers.conv2d:37
msgid "Filter shape: :math:`(C_{out}, C_{in}, H_f, W_f)`"
msgstr ""

#: of paddle.fluid.layers.conv2d:39 paddle.fluid.layers.conv2d_transpose:34
#: paddle.fluid.layers.conv3d_transpose:34
msgid "Output:"
msgstr ""

#: of paddle.fluid.layers.conv2d:41
msgid "Output shape: :math:`(N, C_{out}, H_{out}, W_{out})`"
msgstr ""

#: of paddle.fluid.layers.conv2d:43 paddle.fluid.layers.conv2d_transpose:38
#: paddle.fluid.layers.conv3d:39 paddle.fluid.layers.conv3d_transpose:38
msgid "Where"
msgstr ""

#: of paddle.fluid.layers.conv2d:50 paddle.fluid.layers.conv2d_transpose:45
msgid "The input image with [N, C, H, W] format."
msgstr ""

#: of paddle.fluid.layers.conv2d:52
msgid "The number of filter. It is as same as the output image channel."
msgstr ""

#: of paddle.fluid.layers.conv2d:55 paddle.fluid.layers.im2sequence:17
msgid ""
"The filter size. If filter_size is a tuple, it must contain two integers,"
" (filter_size_H, filter_size_W). Otherwise, the filter will be a square."
msgstr ""

#: of paddle.fluid.layers.conv2d:59 paddle.fluid.layers.conv2d_transpose:63
#: paddle.fluid.layers.im2sequence:21
msgid ""
"The stride size. If stride is a tuple, it must contain two integers, "
"(stride_H, stride_W). Otherwise, the stride_H = stride_W = stride. "
"Default: stride = 1."
msgstr ""

#: of paddle.fluid.layers.conv2d:63 paddle.fluid.layers.conv2d_transpose:59
msgid ""
"The padding size. If padding is a tuple, it must contain two integers, "
"(padding_H, padding_W). Otherwise, the padding_H = padding_W = padding. "
"Default: padding = 0."
msgstr ""

#: of paddle.fluid.layers.conv2d:67 paddle.fluid.layers.conv2d_transpose:67
msgid ""
"The dilation size. If dilation is a tuple, it must contain two integers, "
"(dilation_H, dilation_W). Otherwise, the dilation_H = dilation_W = "
"dilation. Default: dilation = 1."
msgstr ""

#: of paddle.fluid.layers.conv2d:71
msgid ""
"The groups number of the Conv2d Layer. According to grouped convolution "
"in Alex Krizhevsky's Deep CNN paper: when group=2, the first half of the "
"filters is only connected to the first half of the input channels, while "
"the second half of the filters is only connected to the second half of "
"the input channels. Default: groups=1"
msgstr ""

#: of paddle.fluid.layers.conv2d:77
msgid "The parameters to the Conv2d Layer. Default: None"
msgstr ""

#: of paddle.fluid.layers.conv2d:79 paddle.fluid.layers.conv2d_transpose:81
msgid "Bias parameter for the Conv2d layer. Default: None"
msgstr ""

#: of paddle.fluid.layers.conv2d:81 paddle.fluid.layers.conv2d_transpose:83
#: paddle.fluid.layers.conv3d:77 paddle.fluid.layers.conv3d_transpose:84
msgid ""
"Use cudnn kernel or not, it is valid only when the cudnn library is "
"installed. Default: True"
msgstr ""

#: of paddle.fluid.layers.conv2d:84
msgid ""
"Use mkldnn kernels or not, it is valid only when compiled with mkldnn "
"library. Default: False"
msgstr ""

#: of paddle.fluid.layers.conv2d:87 paddle.fluid.layers.conv2d_transpose:86
#: paddle.fluid.layers.conv3d:82 paddle.fluid.layers.conv3d_transpose:87
msgid "Activation type. Default: None"
msgstr ""

#: of paddle.fluid.layers.conv2d:93 paddle.fluid.layers.conv3d:88
msgid ""
"The tensor variable storing the convolution and                   non-"
"linearity activation result."
msgstr ""

#: of paddle.fluid.layers.conv2d:96 paddle.fluid.layers.conv2d_transpose:95
#: paddle.fluid.layers.conv3d:91 paddle.fluid.layers.conv3d_transpose:96
msgid ""
":exc:`ValueError` -- If the shapes of input, filter_size, stride, padding"
" and groups mismatch."
msgstr ""

#: ../../source/api_reference/layers.rst:485
msgid "conv3d"
msgstr ""

#: of paddle.fluid.layers.conv3d:1
msgid "**Convlution3D Layer**"
msgstr ""

#: of paddle.fluid.layers.conv3d:3
msgid ""
"The convolution3D layer calculates the output based on the input, filter "
"and strides, paddings, dilations, groups parameters. Input(Input) and "
"Output(Output) are in NCDHW format. Where N is batch size C is the number"
" of channels, D is the depth of the feature, H is the height of the "
"feature, and W is the width of the feature. Convlution3D is similar with "
"Convlution2D but adds one dimension(depth). If bias attribution and "
"activation type are provided, bias is added to the output of the "
"convolution, and the corresponding activation function is applied to the "
"final result."
msgstr ""

#: of paddle.fluid.layers.conv3d:20 paddle.fluid.layers.conv3d_transpose:20
msgid ":math:`X`: Input value, a tensor with NCDHW format."
msgstr ""

#: of paddle.fluid.layers.conv3d:21 paddle.fluid.layers.conv3d_transpose:21
msgid ":math:`W`: Filter value, a tensor with MCDHW format."
msgstr ""

#: of paddle.fluid.layers.conv2d_transpose:24 paddle.fluid.layers.conv3d:26
#: paddle.fluid.layers.conv3d_transpose:24
msgid ":math:`Out`: Output value, the shape of :math:`Out` and :math:`X` may be"
msgstr ""

#: of paddle.fluid.layers.conv2d_transpose:24 paddle.fluid.layers.conv3d:26
#: paddle.fluid.layers.conv3d_transpose:24
msgid "different."
msgstr ""

#: of paddle.fluid.layers.conv3d:32
msgid "Input shape: :math:`(N, C_{in}, D_{in}, H_{in}, W_{in})`"
msgstr ""

#: of paddle.fluid.layers.conv3d:34
msgid "Filter shape: :math:`(C_{out}, C_{in}, D_f, H_f, W_f)`"
msgstr ""

#: of paddle.fluid.layers.conv3d:36
msgid "Output: Output shape: :math:`(N, C_{out}, D_{out}, H_{out}, W_{out})`"
msgstr ""

#: of paddle.fluid.layers.conv3d:47
msgid ""
"The input image with [N, C, D, H, W] format. num_filters(int): The number"
" of filter. It is as same as the output image channel."
msgstr ""

#: of paddle.fluid.layers.conv3d:51
msgid ""
"The filter size. If filter_size is a tuple, it must contain three "
"integers, (filter_size_D, filter_size_H, filter_size_W). Otherwise, the "
"filter will be a square."
msgstr ""

#: of paddle.fluid.layers.conv3d:55 paddle.fluid.layers.conv3d_transpose:64
msgid ""
"The stride size. If stride is a tuple, it must contain three integers, "
"(stride_D, stride_H, stride_W). Otherwise, the stride_D = stride_H = "
"stride_W = stride. Default: stride = 1."
msgstr ""

#: of paddle.fluid.layers.conv3d:59 paddle.fluid.layers.conv3d_transpose:60
msgid ""
"The padding size. If padding is a tuple, it must contain three integers, "
"(padding_D, padding_H, padding_W). Otherwise, the padding_D = padding_H ="
" padding_W = padding. Default: padding = 0."
msgstr ""

#: of paddle.fluid.layers.conv3d:63 paddle.fluid.layers.conv3d_transpose:68
msgid ""
"The dilation size. If dilation is a tuple, it must contain three "
"integers, (dilation_D, dilation_H, dilation_W). Otherwise, the dilation_D"
" = dilation_H = dilation_W = dilation. Default: dilation = 1."
msgstr ""

#: of paddle.fluid.layers.conv3d:67
msgid ""
"The groups number of the Conv3d Layer. According to grouped convolution "
"in Alex Krizhevsky's Deep CNN paper: when group=2, the first half of the "
"filters is only connected to the first half of the input channels, while "
"the second half of the filters is only connected to the second half of "
"the input channels. Default: groups=1"
msgstr ""

#: of paddle.fluid.layers.conv3d:73
msgid "The parameters to the Conv3d Layer. Default: None"
msgstr ""

#: of paddle.fluid.layers.conv3d:75 paddle.fluid.layers.conv3d_transpose:82
msgid "Bias parameter for the Conv3d layer. Default: None"
msgstr ""

#: of paddle.fluid.layers.conv3d:80
msgid "Use mkldnn kernels or not."
msgstr ""

#: ../../source/api_reference/layers.rst:493
msgid "sequence_pool"
msgstr ""

#: of paddle.fluid.layers.sequence_pool:1
msgid ""
"This function add the operator for sequence pooling. It pools features of"
" all time-steps of each instance, and is applied on top of the input "
"using pool_type mentioned in the parameters."
msgstr ""

#: of paddle.fluid.layers.sequence_pool:5
msgid "It supports four pool_type:"
msgstr ""

#: of paddle.fluid.layers.sequence_pool:7
msgid "average: :math:`Out[i] = \\frac{\\sum_i X_i}{N}`"
msgstr ""

#: of paddle.fluid.layers.sequence_pool:8
msgid "sum:     :math:`Out[i] = \\sum_jX_{ij}`"
msgstr ""

#: of paddle.fluid.layers.sequence_pool:9
msgid "sqrt:    :math:`Out[i] = \\frac{\\sum_jX_{ij}}{\\sqrt{len(X_i)}}`"
msgstr ""

#: of paddle.fluid.layers.sequence_pool:10
msgid "max:     :math:`Out[i] = max(X_i)`"
msgstr ""

#: of paddle.fluid.layers.sequence_expand:41
#: paddle.fluid.layers.sequence_first_step:15
#: paddle.fluid.layers.sequence_last_step:15
#: paddle.fluid.layers.sequence_pool:32
msgid "The input variable which is a LoDTensor."
msgstr ""

#: of paddle.fluid.layers.sequence_pool:34
msgid "The pooling type of sequence_pool. It supports average, sum, sqrt and max."
msgstr ""

#: of paddle.fluid.layers.sequence_pool:38
msgid "The sequence pooling variable which is a Tensor."
msgstr ""

#: ../../source/api_reference/layers.rst:501
msgid "sequence_softmax"
msgstr ""

#: ../../source/api_reference/layers.rst:509
msgid "softmax"
msgstr ""

#: ../../source/api_reference/layers.rst:517
msgid "pool2d"
msgstr ""

#: of paddle.fluid.layers.pool2d:1
msgid ""
"This function adds the operator for pooling in 2 dimensions, using the "
"pooling configurations mentioned in input parameters."
msgstr ""

#: of paddle.fluid.layers.pool2d:4 paddle.fluid.layers.pool3d:4
msgid "${input_comment}"
msgstr ""

#: of paddle.fluid.layers.pool2d:6 paddle.fluid.layers.pool3d:6
msgid "${ksize_comment}"
msgstr ""

#: of paddle.fluid.layers.pool2d:8 paddle.fluid.layers.pool3d:8
msgid "${pooling_type_comment}"
msgstr ""

#: of paddle.fluid.layers.pool2d:10 paddle.fluid.layers.pool3d:10
msgid "stride of the pooling layer."
msgstr ""

#: of paddle.fluid.layers.pool2d:12 paddle.fluid.layers.pool3d:12
msgid "padding size."
msgstr ""

#: of paddle.fluid.layers.pool2d:14 paddle.fluid.layers.pool3d:14
msgid "${global_pooling_comment}"
msgstr ""

#: of paddle.fluid.layers.pool2d:16 paddle.fluid.layers.pool3d:16
msgid "${use_cudnn_comment}"
msgstr ""

#: of paddle.fluid.layers.pool2d:18 paddle.fluid.layers.pool3d:18
msgid "${ceil_mode_comment}"
msgstr ""

#: of paddle.fluid.layers.batch_norm:22 paddle.fluid.layers.pool2d:20
#: paddle.fluid.layers.pool3d:20
msgid "${use_mkldnn_comment}"
msgstr ""

#: of paddle.fluid.layers.pool2d:26
msgid "output of pool2d layer."
msgstr ""

#: ../../source/api_reference/layers.rst:525
msgid "pool3d"
msgstr ""

#: of paddle.fluid.layers.pool3d:1
msgid ""
"This function adds the operator for pooling in 3-dimensions, using the "
"pooling configurations mentioned in input parameters."
msgstr ""

#: of paddle.fluid.layers.pool3d:26
msgid "output of pool3d layer."
msgstr ""

#: ../../source/api_reference/layers.rst:533
msgid "batch_norm"
msgstr ""

#: of paddle.fluid.layers.batch_norm:1
msgid ""
"This function helps create an operator to implement the BatchNorm layer "
"using the configurations from the input parameters."
msgstr ""

#: of paddle.fluid.layers.batch_norm:4
msgid "the input variable."
msgstr ""

#: of paddle.fluid.layers.batch_norm:6
msgid "activation type"
msgstr ""

#: of paddle.fluid.layers.batch_norm:8
msgid "whether to run batch_norm as test mode."
msgstr ""

#: of paddle.fluid.layers.batch_norm:10
msgid "momentum"
msgstr ""

#: of paddle.fluid.layers.batch_norm:12
msgid "epsilon, default 1e-05"
msgstr ""

#: of paddle.fluid.layers.batch_norm:18
msgid "data layout, default NCHW"
msgstr ""

#: of paddle.fluid.layers.batch_norm:20
msgid "if True, do not create tmp variable"
msgstr ""

#: of paddle.fluid.layers.batch_norm:24
#: paddle.fluid.layers.beam_search_decode:7
#: paddle.fluid.layers.ctc_greedy_decoder:44
#: paddle.fluid.layers.edit_distance:32 paddle.fluid.layers.im2sequence:34
#: paddle.fluid.layers.layer_norm:48 paddle.fluid.layers.reshape:55
#: paddle.fluid.layers.transpose:12
msgid "The name of this layer. It is optional."
msgstr ""

#: of paddle.fluid.layers.batch_norm:26
msgid "The name of moving mean variable name, optional."
msgstr ""

#: of paddle.fluid.layers.batch_norm:28
msgid "The name of moving variance name, optional."
msgstr ""

#: of paddle.fluid.layers.batch_norm:33
msgid "output of batch_norm layer."
msgstr ""

#: ../../source/api_reference/layers.rst:541
msgid "beam_search_decode"
msgstr ""

#: of paddle.fluid.layers.beam_search_decode:1
msgid "${beam_search_decode}"
msgstr ""

#: of paddle.fluid.layers.beam_search:5
#: paddle.fluid.layers.beam_search_decode:3
msgid "${ids_comment}"
msgstr ""

#: of paddle.fluid.layers.beam_search:7
#: paddle.fluid.layers.beam_search_decode:5
msgid "${scores_comment}"
msgstr ""

#: of paddle.fluid.layers.beam_search_decode:10
msgid "a tuple of two output variable: sentence_ids, sentence_scores"
msgstr ""

#: ../../source/api_reference/layers.rst:549
msgid "conv2d_transpose"
msgstr ""

#: of paddle.fluid.layers.conv2d_transpose:1
msgid "**Convlution2D transpose layer**"
msgstr ""

#: of paddle.fluid.layers.conv2d_transpose:3
msgid ""
"The convolution2D transpose layer calculates the output based on the "
"input, filter, and dilations, strides, paddings. Input(Input) and "
"output(Output) are in NCHW format. Where N is batch size, C is the number"
" of channels, H is the height of the feature, and W is the width of the "
"feature. Parameters(dilations, strides, paddings) are two elements. These"
" two elements represent height and width, respectively. The details of "
"convolution transpose layer, please refer to the following explanation "
"and references `therein <http://www.matthewzeiler.com/wp-"
"content/uploads/2017/07/cvpr2010.pdf>`_."
msgstr ""

#: of paddle.fluid.layers.conv2d_transpose:22
#: paddle.fluid.layers.conv3d_transpose:22
msgid ":math:`\\ast` : Convolution transpose operation."
msgstr ""

#: of paddle.fluid.layers.conv2d_transpose:30
msgid "Input shape: $(N, C_{in}, H_{in}, W_{in})$"
msgstr ""

#: of paddle.fluid.layers.conv2d_transpose:32
msgid "Filter shape: $(C_{in}, C_{out}, H_f, W_f)$"
msgstr ""

#: of paddle.fluid.layers.conv2d_transpose:36
msgid "Output shape: $(N, C_{out}, H_{out}, W_{out})$"
msgstr ""

#: of paddle.fluid.layers.conv2d_transpose:47
#: paddle.fluid.layers.conv3d_transpose:48
msgid "The number of the filter. It is as same as the output image channel."
msgstr ""

#: of paddle.fluid.layers.conv2d_transpose:50
msgid ""
"The output image size. If output size is a tuple, it must contain two "
"integers, (image_H, image_W). This parameter only works when filter_size "
"is None."
msgstr ""

#: of paddle.fluid.layers.conv2d_transpose:54
msgid ""
"The filter size. If filter_size is a tuple, it must contain two integers,"
" (filter_size_H, filter_size_W). Otherwise, the filter will be a square. "
"None if use output size to calculate filter_size."
msgstr ""

#: of paddle.fluid.layers.conv2d_transpose:71
msgid ""
"The groups number of the Conv2d transpose layer. Inspired by grouped "
"convolution in Alex Krizhevsky's Deep CNN paper, in which when group=2, "
"the first half of the filters is only connected to the first half of the "
"input channels, while the second half of the filters is only connected to"
" the second half of the input channels. Default: groups=1"
msgstr ""

#: of paddle.fluid.layers.conv2d_transpose:78
msgid "The parameters to the Conv2d_transpose Layer. Default: None"
msgstr ""

#: of paddle.fluid.layers.conv2d_transpose:92
#: paddle.fluid.layers.conv3d_transpose:93
msgid "The tensor variable storing the convolution transpose result."
msgstr ""

#: ../../source/api_reference/layers.rst:557
msgid "conv3d_transpose"
msgstr ""

#: of paddle.fluid.layers.conv3d_transpose:1
msgid "**Convlution3D transpose layer**"
msgstr ""

#: of paddle.fluid.layers.conv3d_transpose:3
msgid ""
"The convolution3D transpose layer calculates the output based on the "
"input, filter, and dilations, strides, paddings. Input(Input) and "
"output(Output) are in NCDHW format. Where N is batch size, C is the "
"number of channels, D is the depth of the feature, H is the height of the"
" feature, and W is the width of the feature. Parameters(dilations, "
"strides, paddings) are two elements. These two elements represent height "
"and width, respectively. The details of convolution transpose layer, "
"please refer to the following explanation and references `therein "
"<http://www.matthewzeiler.com/wp-content/uploads/2017/07/cvpr2010.pdf>`_."
msgstr ""

#: of paddle.fluid.layers.conv3d_transpose:30
msgid "Input shape: $(N, C_{in}, D_{in}, H_{in}, W_{in})$"
msgstr ""

#: of paddle.fluid.layers.conv3d_transpose:32
msgid "Filter shape: $(C_{in}, C_{out}, D_f, H_f, W_f)$"
msgstr ""

#: of paddle.fluid.layers.conv3d_transpose:36
msgid "Output shape: $(N, C_{out}, D_{out}, H_{out}, W_{out})$"
msgstr ""

#: of paddle.fluid.layers.conv3d_transpose:46
msgid "The input image with [N, C, D, H, W] format."
msgstr ""

#: of paddle.fluid.layers.conv3d_transpose:51
msgid ""
"The output image size. If output size is a tuple, it must contain three "
"integers, (image_D, image_H, image_W). This parameter only works when "
"filter_size is None."
msgstr ""

#: of paddle.fluid.layers.conv3d_transpose:55
msgid ""
"The filter size. If filter_size is a tuple, it must contain three "
"integers, (filter_size_D, filter_size_H, filter_size_W). Otherwise, the "
"filter will be a square. None if use output size to calculate "
"filter_size."
msgstr ""

#: of paddle.fluid.layers.conv3d_transpose:72
msgid ""
"The groups number of the Conv3d transpose layer. Inspired by grouped "
"convolution in Alex Krizhevsky's Deep CNN paper, in which when group=2, "
"the first half of the filters is only connected to the first half of the "
"input channels, while the second half of the filters is only connected to"
" the second half of the input channels. Default: groups=1"
msgstr ""

#: of paddle.fluid.layers.conv3d_transpose:79
msgid "The parameters to the Conv3d_transpose Layer. Default: None"
msgstr ""

#: ../../source/api_reference/layers.rst:565
msgid "sequence_expand"
msgstr ""

#: of paddle.fluid.layers.sequence_expand:1
msgid ""
"Sequence Expand Layer. This layer will expand the input variable **x** "
"according to specified level lod of **y**. Please note that lod level of "
"**x** is at most 1 and rank of **x** is at least 2. When rank of **x** is"
" greater than 2, then it would be viewed as a 2-D tensor. Following "
"examples will explain how sequence_expand works:"
msgstr ""

#: of paddle.fluid.layers.matmul:28 paddle.fluid.layers.matmul:30
#: paddle.fluid.layers.reduce_max:3 paddle.fluid.layers.reduce_mean:3
#: paddle.fluid.layers.reduce_min:3 paddle.fluid.layers.reduce_prod:3
#: paddle.fluid.layers.reduce_sum:3 paddle.fluid.layers.sequence_expand:39
#: paddle.fluid.layers.split:3
msgid "The input variable which is a Tensor or LoDTensor."
msgstr ""

#: of paddle.fluid.layers.sequence_expand:43
msgid ""
"Lod level of `y` to be referred by `x`. If set to -1, refer the last "
"level of lod."
msgstr ""

#: of paddle.fluid.layers.sequence_expand:50
msgid "The expanded variable which is a LoDTensor."
msgstr ""

#: ../../source/api_reference/layers.rst:573
msgid "lstm_unit"
msgstr ""

#: of paddle.fluid.layers.lstm_unit:1
msgid "Lstm unit layer. The equation of a lstm step is:"
msgstr ""

#: of paddle.fluid.layers.lstm_unit:15
msgid ""
"The inputs of lstm unit include :math:`x_t`, :math:`h_{t-1}` and "
":math:`c_{t-1}`. The 2nd dimensions of :math:`h_{t-1}` and "
":math:`c_{t-1}` should be same. The implementation separates the linear "
"transformation and non-linear transformation apart. Here, we take "
":math:`i_t` as an example. The linear transformation is applied by "
"calling a `fc` layer and the equation is:"
msgstr ""

#: of paddle.fluid.layers.lstm_unit:26
msgid ""
"The non-linear transformation is applied by calling `lstm_unit_op` and "
"the equation is:"
msgstr ""

#: of paddle.fluid.layers.lstm_unit:33
msgid "This layer has two outputs including :math:`h_t` and :math:`o_t`."
msgstr ""

#: of paddle.fluid.layers.lstm_unit:35
msgid ""
"The input value of current step, a 2-D tensor with shape M x N, M for "
"batch size and N for input size."
msgstr ""

#: of paddle.fluid.layers.lstm_unit:38
msgid ""
"The hidden value of lstm unit, a 2-D tensor with shape M x S, M for batch"
" size and S for size of lstm unit."
msgstr ""

#: of paddle.fluid.layers.lstm_unit:41
msgid ""
"The cell value of lstm unit, a 2-D tensor with shape M x S, M for batch "
"size and S for size of lstm unit."
msgstr ""

#: of paddle.fluid.layers.lstm_unit:44
msgid "The forget bias of lstm unit."
msgstr ""

#: of paddle.fluid.layers.lstm_unit:46
msgid "The attributes of parameter weights, used to set initializer, name etc."
msgstr ""

#: of paddle.fluid.layers.lstm_unit:49
msgid ""
"The attributes of bias weights, if not False, bias weights will be "
"created and be set to default value."
msgstr ""

#: of paddle.fluid.layers.lstm_unit:56
msgid "The hidden value and cell value of lstm unit."
msgstr ""

#: of paddle.fluid.layers.lstm_unit:59
msgid ""
":exc:`ValueError` -- The ranks of **x_t**, **hidden_t_prev** and "
"**cell_t_prev** not be 2 or the 1st dimensions of **x_t**, "
"**hidden_t_prev** and **cell_t_prev** not be the same or the 2nd "
"dimensions of **hidden_t_prev** and **cell_t_prev** not be the same."
msgstr ""

#: ../../source/api_reference/layers.rst:581
msgid "reduce_sum"
msgstr ""

#: of paddle.fluid.layers.reduce_sum:1
msgid "Computes the sum of tensor elements over the given dimension."
msgstr ""

#: of paddle.fluid.layers.reduce_sum:5
msgid ""
"The dimensions along which the sum is performed. If :attr:`None`, sum all"
" elements of :attr:`input` and return a Tensor variable with a single "
"element, otherwise must be in the range :math:`[-rank(input), "
"rank(input))`. If :math:`dim[i] < 0`, the dimension to reduce is "
":math:`rank + dim[i]`."
msgstr ""

#: of paddle.fluid.layers.reduce_max:11 paddle.fluid.layers.reduce_mean:11
#: paddle.fluid.layers.reduce_min:11 paddle.fluid.layers.reduce_prod:11
#: paddle.fluid.layers.reduce_sum:11
msgid ""
"Whether to reserve the reduced dimension in the output Tensor. The result"
" tensor will have one fewer dimension than the :attr:`input` unless "
":attr:`keep_dim` is true."
msgstr ""

#: of paddle.fluid.layers.reduce_max:19 paddle.fluid.layers.reduce_mean:19
#: paddle.fluid.layers.reduce_min:19 paddle.fluid.layers.reduce_prod:19
#: paddle.fluid.layers.reduce_sum:19
msgid "The reduced Tensor variable."
msgstr ""

#: ../../source/api_reference/layers.rst:589
msgid "reduce_mean"
msgstr ""

#: of paddle.fluid.layers.reduce_mean:1
msgid "Computes the mean of tensor elements over the given dimension."
msgstr ""

#: of paddle.fluid.layers.reduce_mean:5
msgid ""
"The dimensions along which the mean is computed. If :attr:`None`, compute"
" the mean over all elements of :attr:`input` and return a Tensor variable"
" with a single element, otherwise must be in the range "
":math:`[-rank(input), rank(input))`. If :math:`dim[i] < 0`, the dimension"
" to reduce is :math:`rank + dim[i]`."
msgstr ""

#: ../../source/api_reference/layers.rst:597
msgid "reduce_max"
msgstr ""

#: of paddle.fluid.layers.reduce_max:1
msgid "Computes the maximum of tensor elements over the given dimension."
msgstr ""

#: of paddle.fluid.layers.reduce_max:5
msgid ""
"The dimension along which the maximum is computed. If :attr:`None`, "
"compute the maximum over all elements of :attr:`input` and return a "
"Tensor variable with a single element, otherwise must be in the range "
":math:`[-rank(input), rank(input))`. If :math:`dim[i] < 0`, the dimension"
" to reduce is :math:`rank + dim[i]`."
msgstr ""

#: ../../source/api_reference/layers.rst:605
msgid "reduce_min"
msgstr ""

#: of paddle.fluid.layers.reduce_min:1
msgid "Computes the minimum of tensor elements over the given dimension."
msgstr ""

#: of paddle.fluid.layers.reduce_min:5
msgid ""
"The dimensions along which the minimum is computed. If :attr:`None`, "
"compute the minimum over all elements of :attr:`input` and return a "
"Tensor variable with a single element, otherwise must be in the range "
":math:`[-rank(input), rank(input))`. If :math:`dim[i] < 0`, the dimension"
" to reduce is :math:`rank + dim[i]`."
msgstr ""

#: ../../source/api_reference/layers.rst:613
msgid "reduce_prod"
msgstr ""

#: of paddle.fluid.layers.reduce_prod:1
msgid "Computes the product of tensor elements over the given dimension."
msgstr ""

#: of paddle.fluid.layers.reduce_prod:5
msgid ""
"The dimensions along which the product is performed. If :attr:`None`, "
"multipy all elements of :attr:`input` and return a Tensor variable with a"
" single element, otherwise must be in the range :math:`[-rank(input), "
"rank(input))`. If :math:`dim[i] < 0`, the dimension to reduce is "
":math:`rank + dim[i]`."
msgstr ""

#: ../../source/api_reference/layers.rst:621
msgid "sequence_first_step"
msgstr ""

#: of paddle.fluid.layers.sequence_first_step:1
msgid "This function gets the first step of sequence."
msgstr ""

#: of paddle.fluid.layers.sequence_first_step:18
msgid "The sequence's first step variable which is a Tensor."
msgstr ""

#: ../../source/api_reference/layers.rst:629
msgid "sequence_last_step"
msgstr ""

#: of paddle.fluid.layers.sequence_last_step:1
msgid "This function gets the last step of sequence."
msgstr ""

#: of paddle.fluid.layers.sequence_last_step:18
msgid "The sequence's last step variable which is a Tensor."
msgstr ""

#: ../../source/api_reference/layers.rst:637
msgid "dropout"
msgstr ""

#: of paddle.fluid.layers.dropout:1
msgid "Computes dropout."
msgstr ""

#: of paddle.fluid.layers.dropout:3
msgid ""
"Drop or keep each element of `x` independently. Dropout is a "
"regularization technique for reducing overfitting by preventing neuron "
"co-adaption during training. The dropout operator randomly set (according"
" to the given dropout probability) the outputs of some units to zero, "
"while others are remain unchanged."
msgstr ""

#: of paddle.fluid.layers.dropout:9
msgid ""
"The input tensor. dropout_prob (float): Probability of setting units to "
"zero."
msgstr ""

#: of paddle.fluid.layers.dropout:12
msgid "A flag indicating whether it is in test phrase or not."
msgstr ""

#: of paddle.fluid.layers.dropout:14
msgid ""
"A Python integer used to create random seeds. If this parameter is set to"
" None, a random seed is used. NOTE: If an integer seed is given, always "
"the same output units will be dropped. DO NOT use a fixed seed in "
"training."
msgstr ""

#: of paddle.fluid.layers.dropout:23
msgid "A tensor variable."
msgstr ""

#: ../../source/api_reference/layers.rst:645
msgid "split"
msgstr ""

#: of paddle.fluid.layers.split:1
msgid "Split the input tensor into multiple sub-tensors."
msgstr ""

#: of paddle.fluid.layers.split:5
msgid ""
"If :attr:`num_or_sections` is an integer, then the integer indicates the "
"number of equal sized sub-tensors that the tensor will be divided into. "
"If :attr:`num_or_sections` is a list of integers, the length of list "
"indicates the number of sub-tensors and the integers indicate the sizes "
"of sub-tensors' :attr:`dim` dimension orderly."
msgstr ""

#: of paddle.fluid.layers.split:12
msgid ""
"The dimension along which to split. If :math:`dim < 0`, the dimension to "
"split along is :math:`rank(input) + dim`."
msgstr ""

#: of paddle.fluid.layers.split:19
msgid "The list of segmented tensor variables."
msgstr ""

#: ../../source/api_reference/layers.rst:653
msgid "ctc_greedy_decoder"
msgstr ""

#: of paddle.fluid.layers.ctc_greedy_decoder:1
msgid ""
"This op is used to decode sequences by greedy policy by below steps: 1. "
"Get the indexes of max value for each row in input. a.k.a."
msgstr ""

#: of paddle.fluid.layers.ctc_greedy_decoder:3
msgid "numpy.argmax(input, axis=0)."
msgstr ""

#: of paddle.fluid.layers.ctc_greedy_decoder:4
msgid ""
"For each sequence in result of step1, merge repeated tokens between two "
"blanks and delete all blanks."
msgstr ""

#: of paddle.fluid.layers.ctc_greedy_decoder:7
msgid "A simple example as below:"
msgstr ""

#: of paddle.fluid.layers.ctc_greedy_decoder:33
msgid ""
"(LoDTensor<float>), the probabilities of variable-length sequences, which"
" is a 2-D Tensor with LoD information. It's shape is [Lp, num_classes + "
"1], where Lp is the sum of all input sequences' length and num_classes is"
" the true number of classes. (not including the blank label)."
msgstr ""

#: of paddle.fluid.layers.ctc_greedy_decoder:40
msgid ""
"the blank label index of Connectionist Temporal Classification (CTC) "
"loss, which is in thehalf-opened interval [0, num_classes + 1)."
msgstr ""

#: of paddle.fluid.layers.ctc_greedy_decoder:47
msgid ""
"CTC greedy decode result. If all the sequences in result were empty, the "
"result LoDTensor will be [-1] with LoD [[0]] and dims [1, 1]."
msgstr ""

#: ../../source/api_reference/layers.rst:661
msgid "edit_distance"
msgstr ""

#: of paddle.fluid.layers.edit_distance:1
msgid ""
"EditDistance operator computes the edit distances between a batch of "
"hypothesis strings and their references. Edit distance, also called "
"Levenshtein distance, measures how dissimilar two strings are by counting"
" the minimum number of operations to transform one string into anthor. "
"Here the operations include insertion, deletion, and substitution."
msgstr ""

#: of paddle.fluid.layers.edit_distance:7
msgid ""
"For example, given hypothesis string A = \"kitten\" and reference B = "
"\"sitting\", the edit distance is 3 for A will be transformed into B at "
"least after two substitutions and one insertion:"
msgstr ""

#: of paddle.fluid.layers.edit_distance:11
msgid "\"kitten\" -> \"sitten\" -> \"sittin\" -> \"sitting\""
msgstr ""

#: of paddle.fluid.layers.edit_distance:13
msgid ""
"Input(Hyps) is a LoDTensor consisting of all the hypothesis strings with "
"the total number denoted by `batch_size`, and the separation is specified"
" by the LoD information. And the `batch_size` reference strings are "
"arranged in order in the same way in the LoDTensor Input(Refs)."
msgstr ""

#: of paddle.fluid.layers.edit_distance:18
msgid ""
"Output(Out) contains the `batch_size` results and each stands for the "
"edit distance for a pair of strings respectively. If Attr(normalized) is "
"true, the edit distance will be divided by the length of reference "
"string."
msgstr ""

#: of paddle.fluid.layers.edit_distance:22
msgid "The indices for hypothesis strings."
msgstr ""

#: of paddle.fluid.layers.edit_distance:24
msgid "The indices for reference strings."
msgstr ""

#: of paddle.fluid.layers.edit_distance:26
msgid ""
"Indicated whether to normalize the edit distance by the length of "
"reference string."
msgstr ""

#: of paddle.fluid.layers.edit_distance:29
msgid "Tokens that should be removed before calculating edit distance."
msgstr ""

#: of paddle.fluid.layers.edit_distance:35
msgid "sequence-to-sequence edit distance in shape [batch_size, 1]."
msgstr ""

#: ../../source/api_reference/layers.rst:669
msgid "l2_normalize"
msgstr ""

#: of paddle.fluid.layers.l2_normalize:1
msgid "**L2 normalize Layer**"
msgstr ""

#: of paddle.fluid.layers.l2_normalize:3
msgid ""
"The l2 normalize layer normalizes `x` along dimension `axis` using an L2 "
"norm. For a 1-D tensor (`dim` is fixed to 0), this layer computes"
msgstr ""

#: of paddle.fluid.layers.l2_normalize:7
msgid "y ="
msgstr ""

#: of paddle.fluid.layers.l2_normalize:8
msgid "rac{x}{ \\sqrt{\\sum {x^2} + epsion }}"
msgstr ""

#: of paddle.fluid.layers.l2_normalize:10
msgid ""
"For `x` with more dimensions, this layer independently normalizes each "
"1-D slice along dimension `axis`."
msgstr ""

#: of paddle.fluid.layers.l2_normalize:22 paddle.fluid.layers.lrn:29
msgid "Args:"
msgstr ""

#: of paddle.fluid.layers.l2_normalize:14
msgid ""
"x(Variable|list): The input tensor to l2_normalize layer. axis(int): The "
"axis on which to apply normalization. If `axis < 0`,"
msgstr ""

#: of paddle.fluid.layers.l2_normalize:16
msgid ""
"the dimension to normalization is rank(X) + axis. -1 is the last "
"dimension."
msgstr ""

#: of paddle.fluid.layers.l2_normalize:18
msgid "epsilon(float): The epsilon value is used to avoid division by zero,"
msgstr ""

#: of paddle.fluid.layers.l2_normalize:19
msgid "the defalut value is 1e-10."
msgstr ""

#: of paddle.fluid.layers.l2_normalize:22
msgid "name(str|None): A name for this layer(optional). If set None, the layer"
msgstr ""

#: of paddle.fluid.layers.l2_normalize:21
msgid "will be named automatically."
msgstr ""

#: of paddle.fluid.layers.l2_normalize:25 paddle.fluid.layers.lrn:35
msgid "Returns:"
msgstr ""

#: of paddle.fluid.layers.l2_normalize:25
msgid "Variable: The output tensor variable."
msgstr ""

#: of paddle.fluid.layers.im2sequence:44 paddle.fluid.layers.l2_normalize:32
#: paddle.fluid.layers.lrn:41
msgid "Examples:"
msgstr ""

#: ../../source/api_reference/layers.rst:677
msgid "matmul"
msgstr ""

#: of paddle.fluid.layers.matmul:1
msgid "Applies matrix multiplication to two tensors."
msgstr ""

#: of paddle.fluid.layers.matmul:3
msgid ""
"Currently, the input tensors' rank can be any, but when the rank of any "
"inputs is bigger than 3, this two inputs' rank should be equal."
msgstr ""

#: of paddle.fluid.layers.matmul:6
msgid ""
"The actual behavior depends on the shapes of :math:`x`, :math:`y` and the"
" flag values of :attr:`transpose_x`, :attr:`transpose_y`. Specifically:"
msgstr ""

#: of paddle.fluid.layers.matmul:9
msgid ""
"If a transpose flag is specified, the last two dimensions of the tensor "
"are transposed. If the tensor is rank-1 of shape :math:`[D]`, then for "
":math:`x` it is treated as :math:`[1, D]` in nontransposed form and as "
":math:`[D, 1]` in transposed form, whereas for :math:`y` it is the "
"opposite: It is treated as :math:`[D, 1]` in nontransposed form and as "
":math:`[1, D]` in transposed form."
msgstr ""

#: of paddle.fluid.layers.matmul:16
msgid ""
"After transpose, the two tensors are 2-D or n-D and matrix multiplication"
" performs in the following way."
msgstr ""

#: of paddle.fluid.layers.matmul:19
msgid "If both are 2-D, they are multiplied like conventional matrices."
msgstr ""

#: of paddle.fluid.layers.matmul:20
msgid ""
"If either is n-D, it is treated as a stack of matrices residing in the "
"last two dimensions and a batched matrix multiply supporting broadcast "
"applies on the two tensors."
msgstr ""

#: of paddle.fluid.layers.matmul:24
msgid ""
"Also note that if the raw tensor :math:`x` or :math:`y` is rank-1 and "
"nontransposed, the prepended or appended dimension :math:`1` will be "
"removed after matrix multiplication."
msgstr ""

#: of paddle.fluid.layers.matmul:32
msgid "Whether to transpose :math:`x` before multiplication."
msgstr ""

#: of paddle.fluid.layers.matmul:34
msgid "Whether to transpose :math:`y` before multiplication."
msgstr ""

#: of paddle.fluid.layers.matmul:40
msgid "The product Tensor variable."
msgstr ""

#: ../../source/api_reference/layers.rst:685
msgid "topk"
msgstr ""

#: of paddle.fluid.layers.topk:1
msgid ""
"This operator is used to find values and indices of the k largest entries"
" for the last dimension."
msgstr ""

#: of paddle.fluid.layers.topk:4
msgid ""
"If the input is a vector (rank=1), finds the k largest entries in the "
"vector and outputs their values and indices as vectors. Thus values[j] is"
" the j-th largest entry in input, and its index is indices[j]."
msgstr ""

#: of paddle.fluid.layers.topk:8
msgid ""
"If the input is a Tensor with higher rank, this operator computes the top"
" k entries along the last dimension."
msgstr ""

#: of paddle.fluid.layers.topk:11
msgid "The input variable which can be a vector or Tensor with higher rank."
msgstr ""

#: of paddle.fluid.layers.topk:14
msgid "An integer value to specify the top k largest elements."
msgstr ""

#: of paddle.fluid.layers.topk:20
msgid ""
"The k largest elements along each last dimensional     slice. "
"indices(Variable): The indices of values within the last dimension of"
"     input."
msgstr ""

#: of paddle.fluid.layers.topk:22
msgid "The k largest elements along each last dimensional"
msgstr ""

#: of paddle.fluid.layers.topk:23
msgid "slice."
msgstr ""

#: of paddle.fluid.layers.topk:24
msgid "indices(Variable): The indices of values within the last dimension of"
msgstr ""

#: of paddle.fluid.layers.topk:25
msgid "input."
msgstr ""

#: ../../source/api_reference/layers.rst:693
msgid "warpctc"
msgstr ""

#: of paddle.fluid.layers.warpctc:1
msgid ""
"An operator integrating the open source Warp-CTC library "
"(https://github.com/baidu-research/warp-ctc) to compute Connectionist "
"Temporal Classification (CTC) loss. It can be aliased as softmax with "
"CTC, since a native softmax activation is interated to the Warp-CTC "
"library, to to normlize values for each row of the input tensor."
msgstr ""

#: of paddle.fluid.layers.warpctc:8
msgid ""
"(LodTensor, default: LoDTensor<float>), the unscaled probabilities of "
"variable-length sequences, which is a 2-D Tensor with LoD information. "
"It's shape is [Lp, num_classes + 1], where Lp is the sum of all input "
"sequences' length and num_classes is the true number of classes. (not "
"including the blank label)."
msgstr ""

#: of paddle.fluid.layers.warpctc:15
msgid ""
"(LodTensor, default: LoDTensor<int>), the ground truth of variable-length"
" sequence, which is a 2-D Tensor with LoD information. It is of the shape"
" [Lg, 1], where Lg is th sum of all labels' length."
msgstr ""

#: of paddle.fluid.layers.warpctc:20
msgid ""
"default 0, the blank label index of Connectionist Temporal Classification"
" (CTC) loss, which is in the half-opened interval [0, num_classes + 1)."
msgstr ""

#: of paddle.fluid.layers.warpctc:24
msgid ""
"default false, whether to normalize the gradients by the number of time-"
"step, which is also the sequence's length. There is no need to normalize "
"the gradients if warpctc layer was follewed by a mean_op."
msgstr ""

#: of paddle.fluid.layers.warpctc:30
msgid ""
"The Connectionist Temporal Classification (CTC) loss, which is a 2-D "
"Tensor of the shape [batch_size, 1]."
msgstr ""

#: ../../source/api_reference/layers.rst:701
msgid "sequence_reshape"
msgstr ""

#: of paddle.fluid.layers.sequence_reshape:1
msgid "**Sequence Reshape Layer**"
msgstr ""

#: of paddle.fluid.layers.sequence_reshape:3
msgid ""
"This layer will rearrange the input sequences. The new dimension is set "
"by user. Length of each sequence is computed according to original "
"length, original dimension and new dimension. The following example will "
"help to illustrate the function of this layer:"
msgstr ""

#: of paddle.fluid.layers.sequence_reshape:24
msgid ""
"Currently, only 1-level LoDTensor is supported and please make sure "
"(original length * original dimension) can be divided by new dimension "
"with no remainder for each sequence."
msgstr ""

#: of paddle.fluid.layers.sequence_reshape:28
msgid ""
"(LodTensor, default: LoDTensor<float>), a 2-D LoDTensor with shape being "
"[N, M] where M for dimension."
msgstr ""

#: of paddle.fluid.layers.sequence_reshape:31
msgid "New dimension which the input LoDTensor is reshaped to."
msgstr ""

#: of paddle.fluid.layers.sequence_reshape:34
msgid "Reshaped LoDTensor according to new dimension."
msgstr ""

#: ../../source/api_reference/layers.rst:709
msgid "transpose"
msgstr ""

#: of paddle.fluid.layers.transpose:1
msgid "**transpose Layer**"
msgstr ""

#: of paddle.fluid.layers.transpose:3
msgid "Permute the dimensions of `input` according to `perm`."
msgstr ""

#: of paddle.fluid.layers.transpose:5
msgid ""
"The `i`-th dimension  of the returned tensor will correspond to the "
"perm[i]-th dimension of `input`."
msgstr ""

#: of paddle.fluid.layers.transpose:8
msgid "The input Tensor."
msgstr ""

#: of paddle.fluid.layers.transpose:10
msgid "A permutation of the dimensions of `input`."
msgstr ""

#: of paddle.fluid.layers.transpose:15
msgid "A transposed Tensor."
msgstr ""

#: ../../source/api_reference/layers.rst:717
msgid "im2sequence"
msgstr ""

#: of paddle.fluid.layers.im2sequence:1
msgid ""
"Extracts image patches from the input tensor to form a tensor of shape "
"{input.batch_size * output_height * output_width, filter_size_H * "
"filter_size_W * input.channels} which is similar with im2col. This op use"
" filter / kernel to scan images and convert these images to sequences. "
"After expanding, the number of time step are output_height * output_width"
" for an image, in which output_height and output_width are calculated by "
"below equation:"
msgstr ""

#: of paddle.fluid.layers.im2sequence:13
msgid "And the dimension of each time step is block_y * block_x * input.channels."
msgstr ""

#: of paddle.fluid.layers.im2sequence:15
msgid "The input should be a tensor in NCHW format."
msgstr ""

#: of paddle.fluid.layers.im2sequence:25
msgid ""
"The padding size. If padding is a tuple, it can contain two integers like"
" (padding_H, padding_W) which means padding_up = padding_down = padding_H"
" and padding_left = padding_right = padding_W. Or it can use (padding_up,"
" padding_left, padding_down, padding_right) to indicate paddings of four "
"direction. Otherwise, a scalar padding means padding_up = padding_down = "
"padding_left = padding_right = padding Default: padding = 0."
msgstr ""

#: of paddle.fluid.layers.im2sequence:37
msgid ""
"The output is a LoDTensor with shape {input.batch_size * output_height * "
"output_width, filter_size_H * filter_size_W * input.channels}. If we "
"regard output as a matrix, each row of this matrix is a step of a "
"sequence."
msgstr ""

#: of paddle.fluid.layers.im2sequence:46
msgid "As an example:"
msgstr ""

#: of paddle.fluid.layers.im2sequence:91
msgid "The simple usage is:"
msgstr ""

#: ../../source/api_reference/layers.rst:725
msgid "nce"
msgstr ""

#: of paddle.fluid.layers.nce:1
msgid ""
"Compute and return the noise-contrastive estimation training loss. See "
"[Noise-contrastive estimation: A new estimation principle for "
"unnormalized statistical "
"models](http://www.jmlr.org/proceedings/papers/v9/gutmann10a/gutmann10a.pdf)."
" By default this operator uses a uniform distribution for sampling."
msgstr ""

#: of paddle.fluid.layers.nce:5
msgid "input variable."
msgstr ""

#: of paddle.fluid.layers.nce:7
msgid "label."
msgstr ""

#: of paddle.fluid.layers.nce:9
msgid "Total number of classes in all samples"
msgstr ""

#: of paddle.fluid.layers.nce:11
msgid ""
"(Tensor) A tensor of shape [batch_size, 1] storing a weight for each "
"sample. And it is a dispensable input. The default value of sample is 1"
msgstr ""

#: of paddle.fluid.layers.nce:17
msgid "The number of negative classes. The default value is 10"
msgstr ""

#: of paddle.fluid.layers.nce:20
msgid "output of nce layer."
msgstr ""

#: ../../source/api_reference/layers.rst:733
msgid "beam_search"
msgstr ""

#: of paddle.fluid.layers.beam_search:1
msgid "This function implements the beam search algorithm."
msgstr ""

#: of paddle.fluid.layers.beam_search:3
msgid "${pre_ids_comment}"
msgstr ""

#: of paddle.fluid.layers.beam_search:9
msgid "${beam_size_comment}"
msgstr ""

#: of paddle.fluid.layers.beam_search:11
msgid "${end_id_comment}"
msgstr ""

#: of paddle.fluid.layers.beam_search:13
msgid "${level_comment}"
msgstr ""

#: of paddle.fluid.layers.beam_search:16
msgid "a tuple of beam_search output variables: selected_ids, selected_scores"
msgstr ""

#: ../../source/api_reference/layers.rst:741
msgid "row_conv"
msgstr ""

#: of paddle.fluid.layers.row_conv:1
msgid ":strong:`Row-convolution operator`"
msgstr ""

#: of paddle.fluid.layers.row_conv:3
msgid ""
"The row convolution is called lookahead convolution.  This operator was "
"introduced in the following paper for DeepSpeech2: "
"http://www.cs.cmu.edu/~dyogatam/papers/wang+etal.iclrworkshop2016.pdf"
msgstr ""

#: of paddle.fluid.layers.row_conv:5
msgid ""
"The main motivation is that a bidirectional RNN, useful in DeepSpeech "
"like speech models, learns representation for a sequence by performing a "
"forward and a backward pass through the entire sequence. However, unlike "
"unidirectional RNNs, bidirectional RNNs are challenging to deploy in an "
"online and low-latency setting. The lookahead convolution incorporates "
"information from future subsequences in a computationally efficient "
"manner to improve unidirectional recurrent neural networks. The row "
"convolution operator is different from the 1D sequence convolution, and "
"is computed as follows:"
msgstr ""

#: of paddle.fluid.layers.row_conv:7
msgid ""
"Given an input sequence :math:`in` of length :math:`t` and input "
"dimension :math:`d`, and a filter (:math:`W`) of size :math:`context "
"\\times d`, the output sequence is convolved as:"
msgstr ""

#: of paddle.fluid.layers.row_conv:9
msgid ""
"$$ out_{i, :} = \\\\sum_{j=i}^{i + context} in_{j,:} \\\\cdot W_{i-j, :} "
"$$"
msgstr ""

#: of paddle.fluid.layers.row_conv:13
msgid ":math:`Out_{i}`: The i-th row of output variable with shape [1, D]."
msgstr ""

#: of paddle.fluid.layers.row_conv:15
msgid ":math:`\\\\tau`: Future context size."
msgstr ""

#: of paddle.fluid.layers.row_conv:17
msgid ":math:`X_{j}`: The j-th row of input variable with shape [1, D]."
msgstr ""

#: of paddle.fluid.layers.row_conv:19
msgid ":math:`W_{i-j}`: The (i-j)-th row of parameters with shape [1, D]."
msgstr ""

#: of paddle.fluid.layers.row_conv:21
msgid ""
"More details about row_conv please refer to the design document "
"https://github.com/PaddlePaddle/Paddle/issues/2228#issuecomment-303903645"
" ."
msgstr ""

#: of paddle.fluid.layers.row_conv:27
msgid ""
"the input(X) is a LodTensor, which supports variable time-length input "
"sequences. The underlying tensor in this LoDTensor is a matrix with shape"
" (T x N), where T is the total time steps in this mini-batch and N is the"
" input data dimension."
msgstr ""

#: of paddle.fluid.layers.row_conv:29
msgid ""
"Future context size. Please note, the shape of convolution kernel is "
"[future_context_size + 1, D]."
msgstr ""

#: of paddle.fluid.layers.row_conv:32
msgid "Attributes of parameters, including name, initializer etc."
msgstr ""

#: of paddle.fluid.layers.row_conv:35
msgid "Non-linear activation to be applied to output variable."
msgstr ""

#: of paddle.fluid.layers.row_conv:38
msgid ""
"the output(Out) is a LodTensor, which supports variable time-length input"
" sequences. The underlying tensor in this LodTensor is a matrix with "
"shape T x N, i.e., the same shape as X."
msgstr ""

#: ../../source/api_reference/layers.rst:749
msgid "multiplex"
msgstr ""

#: of paddle.fluid.layers.multiplex:1
msgid ""
"Referring to the given index variable, this layer selects rows from the "
"input variables to construct a multiplex variable. Assuming that there "
"are :math:`m` input variables and :math:`I_i` represents the i-th input "
"variable and :math:`i` is in [0, :math:`m`). All input variables are "
"tensors with same shape [:math:`d_0`, :math:`d_1`, ..., :math:`d_R`]. "
"Please note that rank of the input tensor should be at least 2. Each "
"input variable will be treated as a 2-D matrix with shape [:math:`M`, "
":math:`N`] where :math:`M` for :math:`d_0` and :math:`N` for :math:`d_1` "
"* :math:`d_2` * ... * :math:`d_R`. Let :math:`I_i[j]` be the j-th row of "
"the i-th input variable. The given index variable should be a 2-D tensor "
"with shape [:math:`M`, 1]. Let `ID[i]` be the i-th index value of the "
"index variable. Then the output variable will be a tensor with shape "
"[:math:`d_0`, :math:`d_1`, ..., :math:`d_R`]. If we treat the output "
"tensor as a 2-D matrix with shape [:math:`M`, :math:`N`] and let "
":math:`O[i]` be the i-th row of the matrix, then `O[i]` is equal to "
":math:`I_{ID[i]}[i]`."
msgstr ""

#: of paddle.fluid.layers.multiplex:3
msgid "Ids: the index tensor."
msgstr ""

#: of paddle.fluid.layers.multiplex:5
msgid "X[0 : N - 1]: the candidate tensors for output (N >= 2)."
msgstr ""

#: of paddle.fluid.layers.multiplex:7
msgid ""
"For each index i from 0 to batchSize - 1, the output is the i-th row of "
"the the (Ids[i])-th tensor."
msgstr ""

#: of paddle.fluid.layers.multiplex:9
msgid "For i-th row of the output tensor:"
msgstr ""

#: of paddle.fluid.layers.multiplex:11
msgid "$$ y[i] = x_{k}[i] $$"
msgstr ""

#: of paddle.fluid.layers.multiplex:13
msgid ""
"where :math:`y` is the output tensor, :math:`x_{k}` is the k-th input "
"tensor, and :math:`k = Ids[i]`."
msgstr ""

#: of paddle.fluid.layers.multiplex:25
msgid ""
"A list of variables to gather from. All variables have the same shape and"
" the rank is at least 2."
msgstr ""

#: of paddle.fluid.layers.multiplex:27
msgid ""
"Tensor<int32>, index variable which is a 2-D tensor with shape [M, 1] "
"where M is the batch size."
msgstr ""

#: of paddle.fluid.layers.multiplex:30
msgid "The output tensor of multiplex operator."
msgstr ""

#: ../../source/api_reference/layers.rst:757
msgid "layer_norm"
msgstr ""

#: of paddle.fluid.layers.layer_norm:1
msgid ""
"Assume feature vectors exist on dimensions :attr:`begin_norm_axis ... "
"rank(input)` and calculate the moment statistics along these dimensions "
"for each feature vector :math:`a` with size :math:`H`, then normalize "
"each feature vector using the corresponding statistics. After that, apply"
" learnable gain and bias on the normalized tensor to scale and shift if "
":attr:`scale` and :attr:`shift` are set."
msgstr ""

#: of paddle.fluid.layers.layer_norm:3
msgid "Refer to `Layer Normalization <https://arxiv.org/pdf/1607.06450v1.pdf>`_"
msgstr ""

#: of paddle.fluid.layers.layer_norm:17
msgid ":math:`a`: the vector representation of the summed inputs to the neurons"
msgstr ""

#: of paddle.fluid.layers.layer_norm:18
msgid "in that layer."
msgstr ""

#: of paddle.fluid.layers.layer_norm:20
msgid ":math:`H`: the number of hidden units in a layers"
msgstr ""

#: of paddle.fluid.layers.layer_norm:22
msgid ":math:`g`: the trainable scale parameter."
msgstr ""

#: of paddle.fluid.layers.layer_norm:24
msgid ":math:`b`: the trainable bias parameter."
msgstr ""

#: of paddle.fluid.layers.layer_norm:26 paddle.fluid.layers.pad:26
msgid "The input tensor variable."
msgstr ""

#: of paddle.fluid.layers.layer_norm:28
msgid "Whether to learn the adaptive gain :math:`g` after normalization."
msgstr ""

#: of paddle.fluid.layers.layer_norm:31
msgid "Whether to learn the adaptive bias :math:`b` after normalization."
msgstr ""

#: of paddle.fluid.layers.layer_norm:34
msgid ""
"The normalization will be performed along dimensions from "
":attr:`begin_norm_axis` to :attr:`rank(input)`."
msgstr ""

#: of paddle.fluid.layers.layer_norm:37
msgid "The small value added to the variance to prevent division by zero."
msgstr ""

#: of paddle.fluid.layers.layer_norm:40
msgid "The parameter attribute for the learnable gain :math:`g`."
msgstr ""

#: of paddle.fluid.layers.layer_norm:43
msgid "The parameter attribute for the learnable bias :math:`b`."
msgstr ""

#: of paddle.fluid.layers.layer_norm:46
msgid "Activation to be applied to the output of layer normalizaiton."
msgstr ""

#: of paddle.fluid.layers.layer_norm:51
msgid "Result after normalization"
msgstr ""

#: ../../source/api_reference/layers.rst:765
msgid "softmax_with_cross_entropy"
msgstr ""

#: of paddle.fluid.layers.softmax_with_cross_entropy:1
msgid "**Softmax With Cross Entropy Operator.**"
msgstr ""

#: of paddle.fluid.layers.softmax_with_cross_entropy:3
msgid ""
"Cross entropy loss with softmax is used as the output layer extensively. "
"This operator computes the softmax normalized values for each row of the "
"input tensor, after which cross-entropy loss is computed. This provides a"
" more numerically stable gradient."
msgstr ""

#: of paddle.fluid.layers.softmax_with_cross_entropy:8
msgid ""
"Because this operator performs a softmax on logits internally, it expects"
" unscaled logits. This operator should not be used with the output of "
"softmax operator since that would produce incorrect results."
msgstr ""

#: of paddle.fluid.layers.softmax_with_cross_entropy:12
msgid ""
"When the attribute soft_label is set false, this operators expects "
"mutually exclusive hard labels, each sample in a batch is in exactly one "
"class with a probability of 1.0. Each sample in the batch will have a "
"single label."
msgstr ""

#: of paddle.fluid.layers.softmax_with_cross_entropy:16
msgid "The equation is as follows:"
msgstr ""

#: of paddle.fluid.layers.softmax_with_cross_entropy:18
msgid "Hard label (one-hot label, so every sample has exactly one class)"
msgstr ""

#: of paddle.fluid.layers.softmax_with_cross_entropy:25
msgid "Soft label (each sample can have a distribution over all classes)"
msgstr ""

#: of paddle.fluid.layers.softmax_with_cross_entropy:33
msgid ""
"The unscaled log probabilities, which is a 2-D tensor with shape [N x K]."
" N is the batch_size, and K is the class number."
msgstr ""

#: of paddle.fluid.layers.softmax_with_cross_entropy:36
msgid ""
"The ground truth which is a 2-D tensor. If soft_label is set to false, "
"Label is a Tensor<int64> with shape [N x 1]. If soft_label is set to "
"true, Label is a Tensor<float/double> with"
msgstr ""

#: of paddle.fluid.layers.softmax_with_cross_entropy:40
msgid ""
"A flag to indicate whether to interpretate the given labels as soft "
"labels. By default, `soft_label` is set to False."
msgstr ""

#: of paddle.fluid.layers.softmax_with_cross_entropy:44
msgid "The cross entropy loss is a 2-D tensor with shape [N x 1]."
msgstr ""

#: ../../source/api_reference/layers.rst:773
msgid "smooth_l1"
msgstr ""

#: of paddle.fluid.layers.smooth_l1:1
msgid "**Smooth L1 Loss Operator. **"
msgstr ""

#: of paddle.fluid.layers.smooth_l1:3
msgid ""
"This operator computes the smooth L1 loss for X and Y. The operator takes"
" the first dimension of X and Y as batch size. For each instance, it "
"computes the smooth L1 loss element by element first and then sums all "
"the losses. So the shape of Out is [batch_size, 1]."
msgstr ""

#: of paddle.fluid.layers.smooth_l1:8
msgid ""
"A tensor with rank at least 2. The input value of smooth L1 loss op with "
"shape [batch_size, dim1, ..., dimN]."
msgstr ""

#: of paddle.fluid.layers.smooth_l1:11
msgid ""
"A tensor with rank at least 2. The target value of smooth L1 loss op with"
" same shape as x."
msgstr ""

#: of paddle.fluid.layers.smooth_l1:14
msgid ""
"A tensor with rank at least 2. This input is optional and should have "
"same shape with x. If provided, the result of (x - y) will be multiplied "
"by this tensor element by element."
msgstr ""

#: of paddle.fluid.layers.smooth_l1:19
msgid ""
"A tensor with rank at least 2. This input is optional and should have "
"same shape with x. If provided, the out smooth L1 loss will be multiplied"
" by this tensor element by element."
msgstr ""

#: of paddle.fluid.layers.smooth_l1:24
msgid ""
"Hyper parameter of smooth L1 loss op. A float scalar with default value "
"1.0."
msgstr ""

#: of paddle.fluid.layers.smooth_l1:28
msgid ""
"A tensor with rank be 2. The output smooth L1 loss with     shape "
"[batch_size, 1]."
msgstr ""

#: of paddle.fluid.layers.smooth_l1:30
msgid "A tensor with rank be 2. The output smooth L1 loss with"
msgstr ""

#: of paddle.fluid.layers.smooth_l1:31
msgid "shape [batch_size, 1]."
msgstr ""

#: ../../source/api_reference/layers.rst:781
msgid "one_hot"
msgstr ""

#: of paddle.fluid.layers.one_hot:1
msgid ""
"One Hot Operator. This operator creates the one-hot representations for "
"input index values. The following example will help to explain the "
"function of this operator."
msgstr ""

#: of paddle.fluid.layers.one_hot:5
msgid "A Tensor/LodTensor of indices, last dimension must be 1."
msgstr ""

#: of paddle.fluid.layers.one_hot:7
msgid "an interger defining the depth of the one hot dimension."
msgstr ""

#: of paddle.fluid.layers.one_hot:10
msgid "The one-hot tensor or LodTensor, same as input."
msgstr ""

#: of paddle.fluid.layers.one_hot:18
msgid "X is a LoDTensor:"
msgstr ""

#: of paddle.fluid.layers.one_hot:17
msgid "X.lod = [[0, 1, 4]] X.shape = [4, 1] X.data = [[1], [1], [3], [0]]"
msgstr ""

#: of paddle.fluid.layers.one_hot:20
msgid "set depth = 4 Out is a LoDTensor:"
msgstr ""

#: of paddle.fluid.layers.one_hot:22
msgid "Out.lod = [[0, 1, 4]] Out.shape = [4, 4] Out.data = [[0., 1., 0., 0.],"
msgstr ""

#: of paddle.fluid.layers.one_hot:25
msgid "[0., 1., 0., 0.], [0., 0., 0., 1.], [1., 0., 0., 0.]]"
msgstr ""

#: ../../source/api_reference/layers.rst:789
msgid "autoincreased_step_counter"
msgstr ""

#: of paddle.fluid.layers.autoincreased_step_counter:1
msgid ""
"NOTE: The counter will be automatically increased by 1 every mini-batch "
"Return the run counter of the main program, which is started with 1."
msgstr ""

#: of paddle.fluid.layers.autoincreased_step_counter:4
msgid "The counter name, default is '@STEP_COUNTER@'."
msgstr ""

#: of paddle.fluid.layers.autoincreased_step_counter:6
msgid "The first value of this counter."
msgstr ""

#: of paddle.fluid.layers.autoincreased_step_counter:8
msgid "The increment step between each execution."
msgstr ""

#: of paddle.fluid.layers.autoincreased_step_counter:11
msgid "The global run counter."
msgstr ""

#: ../../source/api_reference/layers.rst:797
msgid "reshape"
msgstr ""

#: of paddle.fluid.layers.reshape:1
msgid "Gives a new shape to the input Tensor without changing its data."
msgstr ""

#: of paddle.fluid.layers.reshape:3
msgid ""
"The target shape can be given by :attr:`shape` or :attr:`actual_shape`. "
":attr:`shape` is a list of integer while :attr:`actual_shape` is a tensor"
" variable. :attr:`actual_shape` has a higher priority than :attr:`shape` "
"if it is provided, while :attr:`shape` still should be set correctly to "
"gurantee shape inference in compile-time."
msgstr ""

#: of paddle.fluid.layers.reshape:9
msgid "Some tricks exist when specifying the target shape."
msgstr ""

#: of paddle.fluid.layers.reshape:11
msgid ""
"1. -1 means the value of this dimension is inferred from the total "
"element number of x and remaining dimensions. Thus one and only one "
"dimension can be set -1."
msgstr ""

#: of paddle.fluid.layers.reshape:15
msgid ""
"2. 0 means the actual dimension value is going to be copied from the "
"corresponding dimension of x. The indice of 0s in shape can not exceed "
"Rank(X)."
msgstr ""

#: of paddle.fluid.layers.reshape:19
msgid "Here are some examples to explain it."
msgstr ""

#: of paddle.fluid.layers.reshape:21
msgid ""
"1. Given a 3-D tensor x with a shape [2, 4, 6], and the target shape is "
"[6, 8], the reshape operator will transform x into a 2-D tensor with "
"shape [6, 8] and leaving x's data unchanged."
msgstr ""

#: of paddle.fluid.layers.reshape:25
msgid ""
"2. Given a 3-D tensor x with a shape [2, 4, 6], and the target shape "
"specified is [2, 3, -1, 2], the reshape operator will transform x into a "
"4-D tensor with shape [2, 3, 4, 2] and leaving x's data unchanged. In "
"this case, one dimension of the target shape is set to -1, the value of "
"this dimension is inferred from the total element number of x and "
"remaining dimensions."
msgstr ""

#: of paddle.fluid.layers.reshape:32
msgid ""
"3. Given a 3-D tensor x with a shape [2, 4, 6], and the target shape is "
"[-1, 0, 3, 2], the reshape operator will transform x into a 4-D tensor "
"with shape [2, 4, 3, 2] and leaving x's data unchanged. In this case, "
"besides -1, 0 means the actual dimension value is going to be copied from"
" the corresponding dimension of x."
msgstr ""

#: of paddle.fluid.layers.reshape:38
msgid "The input tensor."
msgstr ""

#: of paddle.fluid.layers.reshape:40
msgid "The new shape. At most one dimension of the new shape can be -1."
msgstr ""

#: of paddle.fluid.layers.reshape:43
msgid ""
"An optional input. If provided, reshape according to this given shape "
"rather than :attr:`shape` specifying shape. That is to say "
":attr:`actual_shape` has a higher priority than :attr:`shape`."
msgstr ""

#: of paddle.fluid.layers.reshape:49
msgid "The non-linear activation to be applied to output variable."
msgstr ""

#: of paddle.fluid.layers.reshape:51
msgid ""
"If this flag is set true, a new output tensor is created whose data is "
"copied from input x, otherwise the output shares data with input without "
"copying."
msgstr ""

#: of paddle.fluid.layers.fill_constant:14 paddle.fluid.layers.reshape:58
msgid "The output tensor."
msgstr ""

#: ../../source/api_reference/layers.rst:805
msgid "lod_reset"
msgstr ""

#: of paddle.fluid.layers.lod_reset:1
msgid ""
"LoD Reset Operator. Set LoD of **x** to a new one specified by **y** or "
"**target_lod**. When **y** provided, **y.lod** would be considered as "
"target LoD first, otherwise **y.data** would be considered as target LoD."
" If **y** is not provided, target LoD should be specified by "
"**target_lod**. If target LoD is specified by **Y.data** or "
"**target_lod**, only one level LoD is supported."
msgstr ""

#: of paddle.fluid.layers.lod_reset:57
msgid "Input variable which could be a Tensor or LodTensor."
msgstr ""

#: of paddle.fluid.layers.lod_reset:59
msgid "If provided, output's LoD would be derived from y."
msgstr ""

#: of paddle.fluid.layers.lod_reset:61
msgid ""
"One level LoD which should be considered as target LoD when y not "
"provided."
msgstr ""

#: of paddle.fluid.layers.lod_reset:65
msgid "Output variable with LoD specified by this operator."
msgstr ""

#: of paddle.fluid.layers.lod_reset:68
msgid ":exc:`ValueError` -- If y and target_lod are both None."
msgstr ""

#: ../../source/api_reference/layers.rst:813
msgid "lrn"
msgstr ""

#: of paddle.fluid.layers.lrn:1
msgid ""
"Local Response Normalization Layer. This layer performs a type of "
"\"lateral inhibition\" by normalizing over local input regions."
msgstr ""

#: of paddle.fluid.layers.lrn:11
msgid "ight)^{eta}"
msgstr ""

#: of paddle.fluid.layers.lrn:15
msgid ":math:`n`: The number of channels to sum over."
msgstr ""

#: of paddle.fluid.layers.lrn:16
msgid ":math:`k`: The offset (avoid being divided by 0)."
msgstr ""

#: of paddle.fluid.layers.lrn:17
msgid ":math:`alpha`: The scaling parameter."
msgstr ""

#: of paddle.fluid.layers.lrn:18
msgid ":math:`beta`: The exponent parameter."
msgstr ""

#: of paddle.fluid.layers.lrn:20
msgid ""
"Refer to `ImageNet Classification with Deep Convolutional Neural Networks"
" <https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-"
"convolutional-neural-networks.pdf>`_"
msgstr ""

#: of paddle.fluid.layers.lrn:24
msgid ""
"input (Variable): The input tensor of this layer, and the dimension of "
"input tensor must be 4. n (int, default 5): The number of channels to sum"
" over. k (float, default 1.0): An offset (usually positive to avoid "
"dividing by 0). alpha (float, default 1e-4): The scaling parameter. beta "
"(float, default 0.75): The exponent. name (str, default None): A name for"
" this operation."
msgstr ""

#: of paddle.fluid.layers.lrn:32
msgid "Raises:"
msgstr ""

#: of paddle.fluid.layers.lrn:32
msgid "ValueError: If rank of the input tensor is not 4."
msgstr ""

#: ../../source/api_reference/layers.rst:821
msgid "pad"
msgstr ""

#: of paddle.fluid.layers.pad:1
msgid ""
"Pads a tensor with a constant value given by :attr:`pad_value`, and the "
"padded width is specified by :attr:`paddings`."
msgstr ""

#: of paddle.fluid.layers.pad:4
msgid ""
"Specifically, the number of values padded before the contents of "
":attr:`x` in dimension :attr:`i` is indicated by :attr:`paddings[i]`, and"
" the number of values padded after the contents of :attr:`x` in dimension"
" :attr:`i` is indicated by :attr:`paddings[i+1]`."
msgstr ""

#: of paddle.fluid.layers.pad:9
msgid "See below for an example."
msgstr ""

#: of paddle.fluid.layers.pad:28
msgid ""
"A list of integers. Its elements specify the padded width before and "
"after for each dimension in turn. The length of :attr:paddings must be "
":math:`rank(x) \\times 2`."
msgstr ""

#: of paddle.fluid.layers.pad:33
msgid "The constant value used to pad."
msgstr ""

#: of paddle.fluid.layers.pad:39
msgid "The padded tensor variable."
msgstr ""

#: ../../source/api_reference/layers.rst:829
msgid "label_smooth"
msgstr ""

#: of paddle.fluid.layers.label_smooth:1
msgid ""
"Label smoothing is a mechanism to regularize the classifier layer and is "
"called label-smoothing regularization (LSR)."
msgstr ""

#: of paddle.fluid.layers.label_smooth:4
msgid ""
"Label smoothing is proposed to encourage the model to be less confident, "
"since optimizing the log-likelihood of the correct label directly may "
"cause overfitting and reduce the ability of the model to adapt. Label "
"smoothing replaces the ground-truth label :math:`y` with the weighted sum"
" of itself and some fixed distribution :math:`\\mu`. For class :math:`k`,"
" i.e."
msgstr ""

#: of paddle.fluid.layers.label_smooth:15
msgid ""
"where :math:`1 - \\epsilon` and :math:`\\epsilon` are the weights "
"respectively, and :math:`\\tilde{y}_k` is the smoothed label. Usually "
"uniform distribution is used for :math:`\\mu`."
msgstr ""

#: of paddle.fluid.layers.label_smooth:19
msgid ""
"See more details about label smoothing in "
"https://arxiv.org/abs/1512.00567."
msgstr ""

#: of paddle.fluid.layers.label_smooth:21
msgid ""
"The input variable containing the label data. The label data should use "
"one-hot representation."
msgstr ""

#: of paddle.fluid.layers.label_smooth:24
msgid ""
"The prior distribution to be used to smooth labels. If not provided, an "
"uniform distribution is used. The shape of :attr:`prior_dist` should be "
":math:`(1, class\\_num)`."
msgstr ""

#: of paddle.fluid.layers.label_smooth:29
msgid ""
"The weight used to mix up the original ground-truth distribution and the "
"fixed distribution."
msgstr ""

#: of paddle.fluid.layers.label_smooth:32
msgid "The type of data : float32, float_64, int etc."
msgstr ""

#: of paddle.fluid.layers.label_smooth:39
msgid "The tensor variable containing the smoothed labels."
msgstr ""

#: ../../source/api_reference/layers.rst:837
msgid "roi_pool"
msgstr ""

#: of paddle.fluid.layers.roi_pool:2
msgid "Region of interest pooling (also known as RoI pooling) is to perform"
msgstr ""

#: of paddle.fluid.layers.roi_pool:2
msgid ""
"is to perform max pooling on inputs of nonuniform sizes to obtain fixed-"
"size feature maps (e.g. 7*7)."
msgstr ""

#: of paddle.fluid.layers.roi_pool:8
msgid "The operator has three steps:"
msgstr ""

#: of paddle.fluid.layers.roi_pool:5
msgid ""
"Dividing each region proposal into equal-sized sections with the "
"pooled_width and pooled_height"
msgstr ""

#: of paddle.fluid.layers.roi_pool:7
msgid "Finding the largest value in each section"
msgstr ""

#: of paddle.fluid.layers.roi_pool:8
msgid "Copying these max values to the output buffer"
msgstr ""

#: of paddle.fluid.layers.roi_pool:10
msgid "The input for ROI pooling."
msgstr ""

#: of paddle.fluid.layers.roi_pool:12
msgid ""
"ROIs (Regions of Interest) to pool over. It should be a 2-D one level "
"LoTensor of shape [num_rois, 4]. The layout is [x1, y1, x2, y2], where "
"(x1, y1) is the top left coordinates, and (x2, y2) is the bottom right "
"coordinates. The num_rois is the total number of ROIs in this batch data."
msgstr ""

#: of paddle.fluid.layers.roi_pool:19
msgid "The pooled output height. Default: 1"
msgstr ""

#: of paddle.fluid.layers.roi_pool:21
msgid "The pooled output width. Default: 1"
msgstr ""

#: of paddle.fluid.layers.roi_pool:23
msgid ""
"Multiplicative spatial scale factor. To translate ROI coords from their "
"input scale to the scale used when pooling. Default: 1.0"
msgstr ""

#: of paddle.fluid.layers.roi_pool:28
msgid ""
"The output is a 4-D tensor of the shape                      (num_rois, "
"channels, pooled_h, pooled_w)."
msgstr ""

#: of paddle.fluid.layers.image_resize:31
#: paddle.fluid.layers.image_resize_short:17 paddle.fluid.layers.roi_pool:30
msgid "The output is a 4-D tensor of the shape"
msgstr ""

#: of paddle.fluid.layers.roi_pool:31
msgid "(num_rois, channels, pooled_h, pooled_w)."
msgstr ""

#: ../../source/api_reference/layers.rst:845
msgid "dice_loss"
msgstr ""

#: of paddle.fluid.layers.dice_loss:1
msgid ""
"Dice loss for comparing the similarity of two batch of data, usually is "
"used for binary image segmentation i.e. labels are binary. The dice loss "
"can be defined as below equation:"
msgstr ""

#: of paddle.fluid.layers.dice_loss:12
msgid ""
"The predictions with rank>=2. The first dimension is batch size, and the "
"last dimension is class number."
msgstr ""

#: of paddle.fluid.layers.dice_loss:15
msgid ""
"The groud truth with the same rank with input. The first dimension is "
"batch size, and the last dimension is 1."
msgstr ""

#: of paddle.fluid.layers.dice_loss:18
msgid ""
"The epsilon will be added to the numerator and denominator. If both input"
" and label are empty, it makes sure dice is 1. Default: 0.00001"
msgstr ""

#: of paddle.fluid.layers.dice_loss:23
msgid "The dice loss with shape [1]."
msgstr ""

#: ../../source/api_reference/layers.rst:853
msgid "image_resize"
msgstr ""

#: of paddle.fluid.layers.image_resize:1
msgid "Resize a batch of images."
msgstr ""

#: of paddle.fluid.layers.image_resize:3
msgid ""
"The input must be a tensor of the shape (num_batches, channels, in_h, "
"in_w), and the resizing only applies on the last two dimensions(hight and"
" width)."
msgstr ""

#: of paddle.fluid.layers.image_resize:7
msgid "Supporting resample methods:"
msgstr ""

#: of paddle.fluid.layers.image_resize:7
msgid "'BILINEAR' : Bilinear interpolation"
msgstr ""

#: of paddle.fluid.layers.image_resize:9
#: paddle.fluid.layers.image_resize_short:6
msgid ""
"The input tensor of image resize layer, This is a 4-D tensor of the shape"
" (num_batches, channels, in_h, in_w)."
msgstr ""

#: of paddle.fluid.layers.image_resize:13
msgid ""
"Output shape of image resize layer, the shape is (out_h, out_w). Default:"
" None"
msgstr ""

#: of paddle.fluid.layers.image_resize:17
msgid ""
"The multiplier for the input height or width. At least one of out_shape "
"or scale must be set. And out_shape has a higher priority than scale. "
"Default: None"
msgstr ""

#: of paddle.fluid.layers.image_resize:25
msgid ""
"The resample method. It can only be 'BILINEAR' currently. Default: "
"'BILINEAR'"
msgstr ""

#: of paddle.fluid.layers.image_resize:29
#: paddle.fluid.layers.image_resize_short:15
msgid ""
"The output is a 4-D tensor of the shape                 (num_batches, "
"channls, out_h, out_w)."
msgstr ""

#: of paddle.fluid.layers.image_resize:32
#: paddle.fluid.layers.image_resize_short:18
msgid "(num_batches, channls, out_h, out_w)."
msgstr ""

#: ../../source/api_reference/layers.rst:861
msgid "image_resize_short"
msgstr ""

#: of paddle.fluid.layers.image_resize_short:1
msgid ""
"Resize a batch of images. The short edge of input images will be resized "
"to the given 'out_short_len'. The long edge of input images will be "
"resized proportionately to make images' length-width ratio constant."
msgstr ""

#: of paddle.fluid.layers.image_resize_short:10
msgid "The length of output images' short edge."
msgstr ""

#: of paddle.fluid.layers.image_resize_short:12
msgid "resample method, default: BILINEAR."
msgstr ""

#: ../../source/api_reference/layers.rst:869
msgid "resize_bilinear"
msgstr ""

#: of paddle.fluid.layers.resize_bilinear:1
msgid ""
"Bilinear interpolation is an extension of linear interpolation for "
"interpolating functions of two variables (e.g. H-direction and "
"W-direction in this op) on a rectilinear 2D grid."
msgstr ""

#: of paddle.fluid.layers.resize_bilinear:3
msgid ""
"The key idea is to perform linear interpolation first in one direction, "
"and then again in the other direction."
msgstr ""

#: of paddle.fluid.layers.resize_bilinear:5
msgid ""
"For details, please refer to Wikipedia: "
"https://en.wikipedia.org/wiki/Bilinear_interpolation"
msgstr ""

#: of paddle.fluid.layers.resize_bilinear:9
msgid ""
"The input tensor of bilinear interpolation, This is a 4-D tensor with "
"shape of (N x C x h x w)."
msgstr ""

#: of paddle.fluid.layers.resize_bilinear:11
msgid ""
"This is a 1-D tensor with two number. The first number is height and the "
"second number is width."
msgstr ""

#: of paddle.fluid.layers.resize_bilinear:13
msgid ""
"The multiplier for the input height or width. At least one of out_shape "
"or scale must be set. And out_shape has a higher priority than scale. "
"Default: None."
msgstr ""

#: of paddle.fluid.layers.resize_bilinear:17
msgid "The output variable name."
msgstr ""

#: of paddle.fluid.layers.resize_bilinear:20
msgid "The dimension of output is (N x C x out_h x out_w)."
msgstr ""

#: ../../source/api_reference/layers.rst:877
msgid "gather"
msgstr ""

#: of paddle.fluid.layers.gather:1
msgid ""
"Output is obtained by gathering entries of the outer-most dimension of X "
"indexed by `index` and concatenate them together."
msgstr ""

#: of paddle.fluid.layers.gather:25
msgid "The source input with rank>=1."
msgstr ""

#: of paddle.fluid.layers.gather:27
msgid "The index input with rank=1."
msgstr ""

#: of paddle.fluid.layers.gather:30
msgid "The output is a tensor with the same rank as input."
msgstr ""

#: ../../source/api_reference/layers.rst:885
msgid "random_crop"
msgstr ""

#: of paddle.fluid.layers.random_crop:1
msgid ""
"This operator takes a batch of instance, and do random cropping on each "
"instance. It means that cropping positions differs on each instance, "
"which is determined by an uniform random generator. All cropped instances"
" have the same shape, which is determined by the operator's attribute "
"'shape'."
msgstr ""

#: of paddle.fluid.layers.random_crop:10
msgid "A batch of instances to random crop"
msgstr ""

#: of paddle.fluid.layers.random_crop:12
msgid "The shape of a cropped instance"
msgstr ""

#: of paddle.fluid.layers.random_crop:14
msgid ""
"The random seed By default, the seed will get from "
"`random.randint(-65536, 65535)`."
msgstr ""

#: of paddle.fluid.layers.random_crop:18
msgid "The cropped instance batch"
msgstr ""

#: ../../source/api_reference/layers.rst:893
msgid "mean_iou"
msgstr ""

#: of paddle.fluid.layers.mean_iou:1
msgid ""
"Mean Intersection-Over-Union is a common evaluation metric for semantic "
"image segmentation, which first computes the IOU for each semantic class "
"and then computes the average over classes. IOU is defined as follows:"
msgstr ""

#: of paddle.fluid.layers.mean_iou:10
msgid ""
"The predictions are accumulated in a confusion matrix and mean-IOU is "
"then calculated from it."
msgstr ""

#: of paddle.fluid.layers.mean_iou:14
msgid ""
"A Tensor of prediction results for semantic labels with type int32 or "
"int64."
msgstr ""

#: of paddle.fluid.layers.mean_iou:16
msgid ""
"A Tensor of ground truth labels with type int32 or int64. Its shape "
"should be the same as input."
msgstr ""

#: of paddle.fluid.layers.mean_iou:20
msgid ""
"A Tensor representing the mean intersection-over-union with shape [1]. "
"out_wrong(Variable): A Tensor with shape [num_classes]. The wrong numbers"
" of each class. out_correct(Variable): A Tensor with shape [num_classes]."
" The correct numbers of each class."
msgstr ""

#: ../../source/api_reference/layers.rst:899
msgid "ops"
msgstr ""

#: ../../source/api_reference/layers.rst:904
msgid "mean"
msgstr ""

#: of paddle.fluid.layers.mean:1
msgid "Mean Operator calculates the mean of all elements in X."
msgstr ""

#: of paddle.fluid.layers.mean:4
msgid "(Tensor) The input of mean op Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.mean:7
msgid "(Tensor) The output of mean op"
msgstr ""

#: ../../source/api_reference/layers.rst:912
msgid "mul"
msgstr ""

#: of paddle.fluid.layers.mul:1
msgid "Mul Operator."
msgstr ""

#: of paddle.fluid.layers.mul:3
msgid ""
"This operator is used to perform matrix multiplication for input $X$ and "
"$Y$."
msgstr ""

#: of paddle.fluid.layers.elementwise_add:3
#: paddle.fluid.layers.elementwise_div:3 paddle.fluid.layers.elementwise_max:3
#: paddle.fluid.layers.elementwise_min:3 paddle.fluid.layers.elementwise_mul:3
#: paddle.fluid.layers.elementwise_pow:3 paddle.fluid.layers.elementwise_sub:3
#: paddle.fluid.layers.mul:5
msgid "The equation is:"
msgstr ""

#: of paddle.fluid.layers.mul:7
msgid "$$Out = X * Y$$"
msgstr ""

#: of paddle.fluid.layers.mul:9
msgid ""
"Both the input $X$ and $Y$ can carry the LoD (Level of Details) "
"information, or not. But the output only shares the LoD information with "
"input $X$."
msgstr ""

#: of paddle.fluid.layers.mul:13
msgid ""
"(Tensor), The first input tensor of mul op. Duplicable: False  Optional: "
"False"
msgstr ""

#: of paddle.fluid.layers.mul:15
msgid ""
"(Tensor), The second input tensor of mul op. Duplicable: False  Optional:"
" False"
msgstr ""

#: of paddle.fluid.layers.mul:17
msgid ""
"(int, default 1), The mul_op can take tensors with more than two "
"dimensions as its inputs. If the input $X$ is a tensor with more than two"
" dimensions, $X$ will be flattened into a two-dimensional matrix first. "
"The flattening rule is: the first `num_col_dims` will be flattened to "
"form the first dimension of the final matrix (the height of the matrix), "
"and the rest `rank(X) - num_col_dims` dimensions are flattened to form "
"the second dimension of the final matrix (the width of the matrix). As a "
"result, height of the flattened matrix is equal to the product of $X$'s "
"first `x_num_col_dims` dimensions' sizes, and width of the flattened "
"matrix is equal to the product of $X$'s last `rank(x) - num_col_dims` "
"dimensions' size. For example, suppose $X$ is a 6-dimensional tensor with"
" the shape [2, 3, 4, 5, 6], and `x_num_col_dims` = 3. Thus, the flattened"
" matrix will have a shape [2 x 3 x 4, 5 x 6] = [24, 30]."
msgstr ""

#: of paddle.fluid.layers.mul:33
msgid ""
"(int, default 1), The mul_op can take tensors with more than two, "
"dimensions as its inputs. If the input $Y$ is a tensor with more than two"
" dimensions, $Y$ will be flattened into a two-dimensional matrix first. "
"The attribute `y_num_col_dims` determines how $Y$ is flattened. See "
"comments of `x_num_col_dims` for more details."
msgstr ""

#: of paddle.fluid.layers.mul:40
msgid "(Tensor), The output tensor of mul op."
msgstr ""

#: ../../source/api_reference/layers.rst:920
msgid "scale"
msgstr ""

#: of paddle.fluid.layers.scale:1
msgid "Scale operator"
msgstr ""

#: of paddle.fluid.layers.scale:3
msgid "$$Out = scale*X$$"
msgstr ""

#: of paddle.fluid.layers.scale:5
msgid ""
"(Tensor) Input tensor of scale operator. Duplicable: False  Optional: "
"False"
msgstr ""

#: of paddle.fluid.layers.scale:7
msgid "(float, default 1.0)The scaling factor of the scale operator."
msgstr ""

#: of paddle.fluid.layers.scale:10
msgid "(Tensor) Output tensor of scale operator."
msgstr ""

#: ../../source/api_reference/layers.rst:928
msgid "sigmoid_cross_entropy_with_logits"
msgstr ""

#: of paddle.fluid.layers.sigmoid_cross_entropy_with_logits:1
msgid "SigmoidCrossEntropyWithLogits Operator."
msgstr ""

#: of paddle.fluid.layers.sigmoid_cross_entropy_with_logits:3
msgid ""
"This measures the element-wise probability error in classification tasks "
"in which each class is independent. This can be thought of as predicting "
"labels for a data-point, where labels are not mutually exclusive. For "
"example, a news article can be about politics, technology or sports at "
"the same time or none of these."
msgstr ""

#: of paddle.fluid.layers.sigmoid_cross_entropy_with_logits:9
msgid "The logistic loss is given as follows:"
msgstr ""

#: of paddle.fluid.layers.sigmoid_cross_entropy_with_logits:11
msgid ""
"$$loss = -Labels * \\log(\\sigma(X)) - (1 - Labels) * \\log(1 - "
"\\sigma(X))$$"
msgstr ""

#: of paddle.fluid.layers.sigmoid_cross_entropy_with_logits:13
msgid ""
"We know that $$\\sigma(X) = (1 / (1 + \\exp(-X)))$$. By substituting this"
" we get:"
msgstr ""

#: of paddle.fluid.layers.sigmoid_cross_entropy_with_logits:15
msgid "$$loss = X - X * Labels + \\log(1 + \\exp(-X))$$"
msgstr ""

#: of paddle.fluid.layers.sigmoid_cross_entropy_with_logits:17
msgid ""
"For stability and to prevent overflow of $$\\exp(-X)$$ when X < 0, we "
"reformulate the loss as follows:"
msgstr ""

#: of paddle.fluid.layers.sigmoid_cross_entropy_with_logits:20
msgid "$$loss = \\max(X, 0) - X * Labels + \\log(1 + \\exp(-|X|))$$"
msgstr ""

#: of paddle.fluid.layers.sigmoid_cross_entropy_with_logits:22
msgid ""
"Both the input `X` and `Labels` can carry the LoD (Level of Details) "
"information. However the output only shares the LoD with input `X`."
msgstr ""

#: of paddle.fluid.layers.sigmoid_cross_entropy_with_logits:26
msgid ""
"(Tensor, default Tensor<float>), a 2-D tensor with shape N x D, where N "
"is the batch size and D is the number of classes. This input is a tensor "
"of logits computed by the previous  operator. Logits are unscaled log "
"probabilities given as log(p/(1-p)). Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.sigmoid_cross_entropy_with_logits:28
msgid ""
"(Tensor, default Tensor<float>), a 2-D tensor of the same type and shape "
"as X. This input is a tensor of probabalistic labels for each logit "
"Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.sigmoid_cross_entropy_with_logits:31
msgid ""
"(Tensor, default Tensor<float>), a 2-D tensor with shape N x D  of "
"elementwise logistic losses."
msgstr ""

#: ../../source/api_reference/layers.rst:936
msgid "elementwise_add"
msgstr ""

#: of paddle.fluid.layers.elementwise_add:1
msgid "Limited Elementwise Add Operator"
msgstr ""

#: of paddle.fluid.layers.elementwise_add:5
msgid "$$Out = X + Y$$"
msgstr ""

#: of paddle.fluid.layers.elementwise_add:7
#: paddle.fluid.layers.elementwise_div:7 paddle.fluid.layers.elementwise_max:7
#: paddle.fluid.layers.elementwise_min:7 paddle.fluid.layers.elementwise_mul:7
#: paddle.fluid.layers.elementwise_pow:7 paddle.fluid.layers.elementwise_sub:7
msgid "$X$: a tensor of any dimension."
msgstr ""

#: of paddle.fluid.layers.elementwise_add:8
#: paddle.fluid.layers.elementwise_div:8 paddle.fluid.layers.elementwise_max:8
#: paddle.fluid.layers.elementwise_min:8 paddle.fluid.layers.elementwise_mul:8
#: paddle.fluid.layers.elementwise_pow:8 paddle.fluid.layers.elementwise_sub:8
msgid ""
"$Y$: a tensor whose dimensions must be less than or equal to the "
"dimensions of $X$."
msgstr ""

#: of paddle.fluid.layers.elementwise_add:10
#: paddle.fluid.layers.elementwise_div:10
#: paddle.fluid.layers.elementwise_max:10
#: paddle.fluid.layers.elementwise_min:10
#: paddle.fluid.layers.elementwise_mul:10
#: paddle.fluid.layers.elementwise_pow:10
#: paddle.fluid.layers.elementwise_sub:10
msgid "There are two cases for this operator:"
msgstr ""

#: of paddle.fluid.layers.elementwise_add:12
#: paddle.fluid.layers.elementwise_div:12
#: paddle.fluid.layers.elementwise_max:12
#: paddle.fluid.layers.elementwise_min:12
#: paddle.fluid.layers.elementwise_mul:12
#: paddle.fluid.layers.elementwise_pow:12
#: paddle.fluid.layers.elementwise_sub:12
msgid "The shape of $Y$ is the same with $X$."
msgstr ""

#: of paddle.fluid.layers.elementwise_add:13
#: paddle.fluid.layers.elementwise_div:13
#: paddle.fluid.layers.elementwise_max:13
#: paddle.fluid.layers.elementwise_min:13
#: paddle.fluid.layers.elementwise_mul:13
#: paddle.fluid.layers.elementwise_pow:13
#: paddle.fluid.layers.elementwise_sub:13
msgid "The shape of $Y$ is a continuous subsequence of $X$."
msgstr ""

#: of paddle.fluid.layers.elementwise_add:15
#: paddle.fluid.layers.elementwise_div:15
#: paddle.fluid.layers.elementwise_max:15
#: paddle.fluid.layers.elementwise_min:15
#: paddle.fluid.layers.elementwise_mul:15
#: paddle.fluid.layers.elementwise_pow:15
#: paddle.fluid.layers.elementwise_sub:15
msgid "For case 2:"
msgstr ""

#: of paddle.fluid.layers.elementwise_add:17
#: paddle.fluid.layers.elementwise_div:17
#: paddle.fluid.layers.elementwise_max:17
#: paddle.fluid.layers.elementwise_min:17
#: paddle.fluid.layers.elementwise_mul:17
#: paddle.fluid.layers.elementwise_pow:17
#: paddle.fluid.layers.elementwise_sub:17
msgid ""
"Broadcast $Y$ to match the shape of $X$, where $axis$ is the start "
"dimension index for broadcasting $Y$ onto $X$."
msgstr ""

#: of paddle.fluid.layers.elementwise_add:19
#: paddle.fluid.layers.elementwise_div:19
#: paddle.fluid.layers.elementwise_max:19
#: paddle.fluid.layers.elementwise_min:19
#: paddle.fluid.layers.elementwise_mul:19
#: paddle.fluid.layers.elementwise_pow:19
#: paddle.fluid.layers.elementwise_sub:19
msgid "If $axis$ is -1 (default), $axis = rank(X) - rank(Y)$."
msgstr ""

#: of paddle.fluid.layers.elementwise_add:20
#: paddle.fluid.layers.elementwise_div:20
#: paddle.fluid.layers.elementwise_max:20
#: paddle.fluid.layers.elementwise_min:20
#: paddle.fluid.layers.elementwise_mul:20
#: paddle.fluid.layers.elementwise_pow:20
#: paddle.fluid.layers.elementwise_sub:20
msgid ""
"The trailing dimensions of size 1 for $Y$ will be ignored for the "
"consideration of subsequence, such as shape(Y) = (2, 1) => (2)."
msgstr ""

#: of paddle.fluid.layers.elementwise_add:34
#: paddle.fluid.layers.elementwise_div:34
#: paddle.fluid.layers.elementwise_max:34
#: paddle.fluid.layers.elementwise_min:34
#: paddle.fluid.layers.elementwise_mul:34
#: paddle.fluid.layers.elementwise_pow:34
#: paddle.fluid.layers.elementwise_sub:34
msgid ""
"The inputs $X$ and $Y$ can carry the different LoD information. But the "
"output only shares the LoD information with the input $X$."
msgstr ""

#: of paddle.fluid.layers.elementwise_add:38
#: paddle.fluid.layers.elementwise_div:38
#: paddle.fluid.layers.elementwise_max:38
#: paddle.fluid.layers.elementwise_min:38
#: paddle.fluid.layers.elementwise_mul:38
#: paddle.fluid.layers.elementwise_pow:38
#: paddle.fluid.layers.elementwise_sub:38
msgid ""
"(Tensor), The first input tensor of elementwise op. Duplicable: False  "
"Optional: False"
msgstr ""

#: of paddle.fluid.layers.elementwise_add:40
#: paddle.fluid.layers.elementwise_div:40
#: paddle.fluid.layers.elementwise_max:40
#: paddle.fluid.layers.elementwise_min:40
#: paddle.fluid.layers.elementwise_mul:40
#: paddle.fluid.layers.elementwise_pow:40
#: paddle.fluid.layers.elementwise_sub:40
msgid ""
"(Tensor), The second input tensor of elementwise op. Duplicable: False  "
"Optional: False"
msgstr ""

#: of paddle.fluid.layers.elementwise_add:42
#: paddle.fluid.layers.elementwise_div:42
#: paddle.fluid.layers.elementwise_max:42
#: paddle.fluid.layers.elementwise_min:42
#: paddle.fluid.layers.elementwise_mul:42
#: paddle.fluid.layers.elementwise_pow:42
#: paddle.fluid.layers.elementwise_sub:42
msgid "(int, default -1). The start dimension index for broadcasting Y onto X."
msgstr ""

#: of paddle.fluid.layers.elementwise_add:45
#: paddle.fluid.layers.elementwise_div:45
#: paddle.fluid.layers.elementwise_max:45
#: paddle.fluid.layers.elementwise_min:45
#: paddle.fluid.layers.elementwise_mul:45
#: paddle.fluid.layers.elementwise_pow:45
#: paddle.fluid.layers.elementwise_sub:45
msgid "The output of elementwise op."
msgstr ""

#: ../../source/api_reference/layers.rst:944
msgid "elementwise_div"
msgstr ""

#: of paddle.fluid.layers.elementwise_div:1
msgid "Limited Elementwise Div Operator"
msgstr ""

#: of paddle.fluid.layers.elementwise_div:5
msgid "$$Out = X / Y$$"
msgstr ""

#: ../../source/api_reference/layers.rst:952
msgid "elementwise_sub"
msgstr ""

#: of paddle.fluid.layers.elementwise_sub:1
msgid "Limited Elementwise Sub Operator"
msgstr ""

#: of paddle.fluid.layers.elementwise_sub:5
msgid "$$Out = X - Y$$"
msgstr ""

#: ../../source/api_reference/layers.rst:960
msgid "elementwise_mul"
msgstr ""

#: of paddle.fluid.layers.elementwise_mul:1
msgid "Limited Elementwise Mul Operator"
msgstr ""

#: of paddle.fluid.layers.elementwise_mul:5
msgid "$$Out = X \\odot\\ Y$$"
msgstr ""

#: ../../source/api_reference/layers.rst:968
msgid "elementwise_max"
msgstr ""

#: of paddle.fluid.layers.elementwise_max:1
msgid "Limited Elementwise Max Operator"
msgstr ""

#: of paddle.fluid.layers.elementwise_max:5
msgid "$$Out = max(X, Y)$$"
msgstr ""

#: ../../source/api_reference/layers.rst:976
msgid "elementwise_min"
msgstr ""

#: of paddle.fluid.layers.elementwise_min:1
msgid "Limited Elementwise Min Operator"
msgstr ""

#: of paddle.fluid.layers.elementwise_min:5
msgid "$$Out = min(X, Y)$$"
msgstr ""

#: ../../source/api_reference/layers.rst:984
msgid "elementwise_pow"
msgstr ""

#: of paddle.fluid.layers.elementwise_pow:1
msgid "Limited Elementwise Pow Operator"
msgstr ""

#: of paddle.fluid.layers.elementwise_pow:5
msgid "$$Out = X ^ Y$$"
msgstr ""

#: ../../source/api_reference/layers.rst:992
msgid "clip"
msgstr ""

#: of paddle.fluid.layers.clip:1
msgid "Clip Operator."
msgstr ""

#: of paddle.fluid.layers.clip:3
msgid ""
"The clip operator limits the value of given input within an interval. The"
" interval is specified with arguments 'min' and 'max':"
msgstr ""

#: of paddle.fluid.layers.clip:6
msgid "$$ Out = \\min(\\max(X, min), max) $$"
msgstr ""

#: of paddle.fluid.layers.clip:11
msgid ""
"(Tensor)The input of clip op.The number of dimensions must be between [1,"
" 9]. Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.clip:13
msgid "(float)Minimum value, under which element is replaced by min."
msgstr ""

#: of paddle.fluid.layers.clip:15
msgid "(float)Maximum value, above which element is replaced by max"
msgstr ""

#: of paddle.fluid.layers.clip:18
msgid "(Tensor)The output of clip op with shape as input(X)"
msgstr ""

#: ../../source/api_reference/layers.rst:1000
msgid "clip_by_norm"
msgstr ""

#: of paddle.fluid.layers.clip_by_norm:1
msgid "ClipByNorm Operator."
msgstr ""

#: of paddle.fluid.layers.clip_by_norm:3
msgid ""
"This operator limits the L2 norm of the input $X$ within $max\\_norm$. If"
" the L2 norm of $X$ is less than or equal to $max\\_norm$, $Out$ will be "
"the same as $X$. If the L2 norm of $X$ is greater than $max\\_norm$, $X$ "
"will be linearly scaled to make the L2 norm of $Out$ equal to "
"$max\\_norm$, as shown in the following formula:"
msgstr ""

#: of paddle.fluid.layers.clip_by_norm:9
msgid "$$ Out = \\frac{max\\_norm * X}{norm(X)}, $$"
msgstr ""

#: of paddle.fluid.layers.clip_by_norm:13
msgid "where $norm(X)$ represents the L2 norm of $X$."
msgstr ""

#: of paddle.fluid.layers.clip_by_norm:15
msgid ""
"(Tensor) The input of clip_by_norm op.The number of dimensions must be "
"between [1, 9]. Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.clip_by_norm:17
msgid "(float) The maximum norm value."
msgstr ""

#: of paddle.fluid.layers.clip_by_norm:20
msgid "(Tensor) The output of clip_by_norm op with shape as input(X)"
msgstr ""

#: ../../source/api_reference/layers.rst:1008
msgid "logical_and"
msgstr ""

#: of paddle.fluid.layers.logical_and:1
msgid "logical_and Operator"
msgstr ""

#: of paddle.fluid.layers.logical_and:3
msgid ""
"It operates element-wise on X and Y, and returns the Out. X, Y and Out "
"are N-dim boolean tensors. Each element of Out is calculated by $$Out = X"
" \\&\\& Y$$"
msgstr ""

#: of paddle.fluid.layers.logical_and:6
msgid ""
"(LoDTensor) Left hand operand of logical_and operator Duplicable: False  "
"Optional: False"
msgstr ""

#: of paddle.fluid.layers.logical_and:8
msgid ""
"(LoDTensor) Right hand operand of logical_and operator Duplicable: False"
"  Optional: False"
msgstr ""

#: of paddle.fluid.layers.logical_and:11
msgid "(LoDTensor) n-dim bool tensor. Each element is $$Out = X \\&\\& Y$$"
msgstr ""

#: ../../source/api_reference/layers.rst:1016
msgid "logical_or"
msgstr ""

#: of paddle.fluid.layers.logical_or:1
msgid "logical_or Operator"
msgstr ""

#: of paddle.fluid.layers.logical_or:3
msgid ""
"It operates element-wise on X and Y, and returns the Out. X, Y and Out "
"are N-dim boolean tensors. Each element of Out is calculated by $$Out = X"
" || Y$$"
msgstr ""

#: of paddle.fluid.layers.logical_or:6
msgid ""
"(LoDTensor) Left hand operand of logical_or operator Duplicable: False  "
"Optional: False"
msgstr ""

#: of paddle.fluid.layers.logical_or:8
msgid ""
"(LoDTensor) Right hand operand of logical_or operator Duplicable: False  "
"Optional: False"
msgstr ""

#: of paddle.fluid.layers.logical_or:11
msgid "(LoDTensor) n-dim bool tensor. Each element is $$Out = X || Y$$"
msgstr ""

#: ../../source/api_reference/layers.rst:1024
msgid "logical_xor"
msgstr ""

#: of paddle.fluid.layers.logical_xor:1
msgid "logical_xor Operator"
msgstr ""

#: of paddle.fluid.layers.logical_xor:3
msgid ""
"It operates element-wise on X and Y, and returns the Out. X, Y and Out "
"are N-dim boolean tensors. Each element of Out is calculated by $$Out = "
"(X || Y) \\, \\&\\& \\, !(X \\&\\& Y)$$"
msgstr ""

#: of paddle.fluid.layers.logical_xor:6
msgid ""
"(LoDTensor) Left hand operand of logical_xor operator Duplicable: False  "
"Optional: False"
msgstr ""

#: of paddle.fluid.layers.logical_xor:8
msgid ""
"(LoDTensor) Right hand operand of logical_xor operator Duplicable: False"
"  Optional: False"
msgstr ""

#: of paddle.fluid.layers.logical_xor:11
msgid ""
"(LoDTensor) n-dim bool tensor. Each element is $$Out = (X || Y) \\, "
"\\&\\& \\, !(X \\&\\& Y)$$"
msgstr ""

#: ../../source/api_reference/layers.rst:1032
msgid "logical_not"
msgstr ""

#: of paddle.fluid.layers.logical_not:1
msgid "logical_not Operator"
msgstr ""

#: of paddle.fluid.layers.logical_not:3
msgid ""
"It operates element-wise on X, and returns the Out. X and Out are N-dim "
"boolean tensors. Each element of Out is calculated by $$Out = !X$$"
msgstr ""

#: of paddle.fluid.layers.logical_not:6
msgid ""
"(LoDTensor) Operand of logical_not operator Duplicable: False  Optional: "
"False"
msgstr ""

#: of paddle.fluid.layers.logical_not:9
msgid "(LoDTensor) n-dim bool tensor. Each element is $$Out = !X$$"
msgstr ""

#: ../../source/api_reference/layers.rst:1040
msgid "uniform_random_batch_size_like"
msgstr ""

#: of paddle.fluid.layers.uniform_random_batch_size_like:1
msgid "Uniform random operator"
msgstr ""

#: of paddle.fluid.layers.uniform_random_batch_size_like:5
msgid ""
"This operator initializes a tensor with the same batch_size as the Input "
"tensor"
msgstr ""

#: of paddle.fluid.layers.uniform_random_batch_size_like:4
msgid "with random values sampled from a uniform distribution."
msgstr ""

#: of paddle.fluid.layers.gaussian_random_batch_size_like:5
#: paddle.fluid.layers.uniform_random_batch_size_like:7
msgid ""
"Tensor whose input_dim_idx'th dimension specifies the batch_size "
"Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.gaussian_random_batch_size_like:7
#: paddle.fluid.layers.uniform_random_batch_size_like:9
msgid "The shape of the output"
msgstr ""

#: of paddle.fluid.layers.gaussian_random_batch_size_like:9
#: paddle.fluid.layers.uniform_random_batch_size_like:11
msgid "default 0. The index of input's batch size dimension"
msgstr ""

#: of paddle.fluid.layers.gaussian_random_batch_size_like:11
#: paddle.fluid.layers.uniform_random_batch_size_like:13
msgid "default 0. The index of output's batch size dimension"
msgstr ""

#: of paddle.fluid.layers.uniform_random_batch_size_like:15
msgid "(float, default -1.0) Minimum value of uniform random"
msgstr ""

#: of paddle.fluid.layers.uniform_random_batch_size_like:17
msgid "(float, default 1.0) Maximun value of uniform random"
msgstr ""

#: of paddle.fluid.layers.uniform_random_batch_size_like:19
msgid ""
"(int, default 0) Random seed used for generating samples. 0 means use a "
"seed generated by the system.Note that if seed is not 0, this operator "
"will always generate the same random numbers every time."
msgstr ""

#: of paddle.fluid.layers.uniform_random_batch_size_like:21
msgid "(int, default 5(FP32)) Output tensor data type"
msgstr ""

#: of paddle.fluid.layers.gaussian_random_batch_size_like:22
#: paddle.fluid.layers.uniform_random_batch_size_like:24
msgid "Tensor of specified shape will be filled with the specified value"
msgstr ""

#: ../../source/api_reference/layers.rst:1048
msgid "gaussian_random"
msgstr ""

#: of paddle.fluid.layers.gaussian_random:1
#: paddle.fluid.layers.gaussian_random_batch_size_like:1
msgid "GaussianRandom Operator."
msgstr ""

#: of paddle.fluid.layers.gaussian_random:3
#: paddle.fluid.layers.gaussian_random_batch_size_like:3
msgid "Used to initialize tensors with gaussian random generator."
msgstr ""

#: of paddle.fluid.layers.gaussian_random:6
msgid "(vector<int>) The dimension of random tensor."
msgstr ""

#: of paddle.fluid.layers.gaussian_random:8
#: paddle.fluid.layers.gaussian_random_batch_size_like:13
msgid "(float, default 0.0) mean of random tensor."
msgstr ""

#: of paddle.fluid.layers.gaussian_random:10
#: paddle.fluid.layers.gaussian_random_batch_size_like:15
msgid "(float, default 1.0) std of random tensor."
msgstr ""

#: of paddle.fluid.layers.gaussian_random:12
#: paddle.fluid.layers.gaussian_random_batch_size_like:17
msgid ""
"(int, default 0) Random seed of generator.0 means use system wide "
"seed.Note that if seed is not 0, this operator will always generate the "
"same random numbers every time."
msgstr ""

#: of paddle.fluid.layers.gaussian_random:14
#: paddle.fluid.layers.gaussian_random_batch_size_like:19
msgid "(int, default 5(FP32)) Output data type."
msgstr ""

#: of paddle.fluid.layers.gaussian_random:17
msgid "Output matrix of gaussian random op"
msgstr ""

#: ../../source/api_reference/layers.rst:1056
msgid "gaussian_random_batch_size_like"
msgstr ""

#: ../../source/api_reference/layers.rst:1064
msgid "scatter"
msgstr ""

#: of paddle.fluid.layers.scatter:1
msgid "Scatter Operator."
msgstr ""

#: of paddle.fluid.layers.scatter:3
msgid ""
"This operator obtains output by updating the input on selected indices on"
" the first axis:"
msgstr ""

#: of paddle.fluid.layers.scatter:5
msgid "$$ Out = X \\\\ Out[Ids] = X[Ids] + Updates $$"
msgstr ""

#: of paddle.fluid.layers.scatter:11
msgid "The source input of scatter op Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.scatter:13
msgid ""
"The index input of scatter op where X will be updated Duplicable: False  "
"Optional: False"
msgstr ""

#: of paddle.fluid.layers.scatter:15
msgid "The updated value of updates op Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.scatter:18
msgid "The output of add op"
msgstr ""

#: ../../source/api_reference/layers.rst:1072
msgid "sum"
msgstr ""

#: of paddle.fluid.layers.sum:1
msgid "Sum operator."
msgstr ""

#: of paddle.fluid.layers.sum:3
msgid ""
"This operators sums the input tensors. All the inputs can carry the LoD "
"(Level of Details) information. However, the output only shares the LoD "
"information with the first input."
msgstr ""

#: of paddle.fluid.layers.sum:7
msgid ""
"(vector<Tensor>) The input tensors of sum operator. Duplicable: True  "
"Optional: False"
msgstr ""

#: of paddle.fluid.layers.sum:10
msgid "(Tensor) The output tensor of sum operator."
msgstr ""

#: ../../source/api_reference/layers.rst:1080
msgid "slice"
msgstr ""

#: of paddle.fluid.layers.slice:1
msgid "Slice Operator."
msgstr ""

#: of paddle.fluid.layers.slice:3
msgid ""
"Produces a slice of the input tensor along multiple axes. Similar to "
"numpy: https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html "
"Slice uses `axes`, `starts` and `ends` attributes to specify the start "
"and end dimension for each axis in the list of axes, it uses this "
"information to slice the input data tensor. If a negative value is passed"
" for any of the start or end indices, it represents number of elements "
"before the end of that dimension. If the value passed to start or end is "
"larger than the n (the number of elements in this dimension), it "
"represents n. For slicing to the end of a dimension with unknown size, it"
" is recommended to pass in INT_MAX. If axes are omitted, they are set to "
"[0, ..., ndim-1]."
msgstr ""

#: of paddle.fluid.layers.slice:14
msgid "Example 1: Given:"
msgstr ""

#: of paddle.fluid.layers.slice:16
msgid ""
"data = [ [1, 2, 3, 4], [5, 6, 7, 8], ] axes = [0, 1] starts = [1, 0] ends"
" = [2, 3]"
msgstr ""

#: of paddle.fluid.layers.slice:21 paddle.fluid.layers.slice:29
msgid "Then:"
msgstr ""

#: of paddle.fluid.layers.slice:21
msgid "result = [ [5, 6, 7], ]"
msgstr ""

#: of paddle.fluid.layers.slice:23
msgid "Example 2: Given:"
msgstr ""

#: of paddle.fluid.layers.slice:25
msgid "data = [ [1, 2, 3, 4], [5, 6, 7, 8], ] starts = [0, 1] ends = [-1, 1000]"
msgstr ""

#: of paddle.fluid.layers.slice:29
msgid "result = [ [2, 3, 4], ]"
msgstr ""

#: of paddle.fluid.layers.slice:31
msgid "Tensor of data to extract slices from. Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.slice:33
msgid ""
"(list<int>) Axes that `starts` and `ends` apply to. It's optional.If not "
"present, will be treated as [0, 1, ..., len(`starts`) - 1]."
msgstr ""

#: of paddle.fluid.layers.slice:35
msgid "(list<int>) Starting indices of corresponding axis in `axes`"
msgstr ""

#: of paddle.fluid.layers.slice:37
msgid "(list<int>) Starting indices of corresponding axis in `axes`."
msgstr ""

#: of paddle.fluid.layers.slice:40
msgid "Sliced data tensor."
msgstr ""

#: ../../source/api_reference/layers.rst:1088
msgid "polygon_box_transform"
msgstr ""

#: of paddle.fluid.layers.polygon_box_transform:1
msgid ""
"PolygonBoxTransform Operator. The input is the final geometry output in "
"detection network. We use 2*n numbers to denote the coordinate shift from"
" n corner vertices of the polygon_box to the pixel location. As each "
"distance offset contains two numbers (xi, yi), the geometry output "
"contains 2*n channels. PolygonBoxTransform Operator is used to transform "
"the coordinate shift to the real coordinate."
msgstr ""

#: of paddle.fluid.layers.polygon_box_transform:8
msgid ""
"The input with shape [batch_size, geometry_channels, height, width] "
"Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.polygon_box_transform:11
msgid "The output with the same shape as input"
msgstr ""

#: ../../source/api_reference/layers.rst:1096
msgid "shape"
msgstr ""

#: of paddle.fluid.layers.shape:1
msgid "Shape Operator. Get the shape of input tensor."
msgstr ""

#: of paddle.fluid.layers.shape:4
msgid "(Tensor), The input tensor. Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.shape:7
msgid "(Tensor), The shape of input tensor."
msgstr ""

#: ../../source/api_reference/layers.rst:1104
msgid "maxout"
msgstr ""

#: of paddle.fluid.layers.maxout:1
msgid "MaxOut Operator."
msgstr ""

#: of paddle.fluid.layers.maxout:3
msgid ""
"Assumed the input shape is (N, Ci, H, W). The output shape is (N, Co, H, "
"W). Then $Co = Ci / groups$ and the operator formula is as follows:"
msgstr ""

#: of paddle.fluid.layers.maxout:7
msgid ""
"$$ y_{si+j} = \\max_k x_{gsi + sk + j} \\\\ g = groups \\\\ s = "
"\\frac{input.size}{num\\_channels} \\\\ 0 \\le i < "
"\\frac{num\\_channels}{groups} \\\\ 0 \\le j < s \\\\ 0 \\le k < groups "
"$$"
msgstr ""

#: of paddle.fluid.layers.maxout:21
msgid "Please refer to Paper:"
msgstr ""

#: of paddle.fluid.layers.maxout:17
msgid ""
"Maxout Networks: "
"http://www.jmlr.org/proceedings/papers/v28/goodfellow13.pdf"
msgstr ""

#: of paddle.fluid.layers.maxout:18
msgid ""
"Multi-digit Number Recognition from Street View \\ Imagery using Deep "
"Convolutional Neural Networks: \\ https://arxiv.org/pdf/1312.6082v4.pdf"
msgstr ""

#: of paddle.fluid.layers.maxout:23
msgid ""
"(Tensor) The input tensor of maxout operator. The format of input tensor "
"is NCHW. Where N is batch size, C is the number of channels, H and W is "
"the height and width of feature. Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.maxout:25
msgid ""
"\"Specifies how many groups the input tensor will be split\" \"in the "
"channel dimension. And the number of output channel is \" \"the number of"
" channels divided by groups..\""
msgstr ""

#: of paddle.fluid.layers.maxout:30
msgid ""
"(Tensor) The output tensor of maxout operator.The format of output tensor"
" is also NCHW.Where N is batch size, C is the number of channels, H and W"
" is the height and width of feature."
msgstr ""

#: ../../source/api_reference/layers.rst:1112
msgid "sigmoid"
msgstr ""

#: of paddle.fluid.layers.sigmoid:1
msgid "Sigmoid Activation Operator"
msgstr ""

#: of paddle.fluid.layers.sigmoid:3
msgid "$$out = \\frac{1}{1 + e^{-x}}$$"
msgstr ""

#: of paddle.fluid.layers.sigmoid:6
msgid "Input of Sigmoid operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.abs:8 paddle.fluid.layers.ceil:8
#: paddle.fluid.layers.cos:8 paddle.fluid.layers.exp:8
#: paddle.fluid.layers.floor:8 paddle.fluid.layers.log:10
#: paddle.fluid.layers.logsigmoid:8 paddle.fluid.layers.reciprocal:8
#: paddle.fluid.layers.relu:8 paddle.fluid.layers.round:8
#: paddle.fluid.layers.sigmoid:8 paddle.fluid.layers.sin:8
#: paddle.fluid.layers.softplus:8 paddle.fluid.layers.softsign:8
#: paddle.fluid.layers.sqrt:8 paddle.fluid.layers.square:8
#: paddle.fluid.layers.tanh:8 paddle.fluid.layers.tanh_shrink:8
msgid "(bool, default false) Only used in mkldnn kernel"
msgstr ""

#: of paddle.fluid.layers.sigmoid:11
msgid "Output of Sigmoid operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1120
msgid "logsigmoid"
msgstr ""

#: of paddle.fluid.layers.logsigmoid:1
msgid "Logsigmoid Activation Operator"
msgstr ""

#: of paddle.fluid.layers.logsigmoid:3
msgid "$$out = \\log \\frac{1}{1 + e^{-x}}$$"
msgstr ""

#: of paddle.fluid.layers.logsigmoid:6
msgid "Input of LogSigmoid operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.logsigmoid:11
msgid "Output of LogSigmoid operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1128
msgid "exp"
msgstr ""

#: of paddle.fluid.layers.exp:1
msgid "Exp Activation Operator."
msgstr ""

#: of paddle.fluid.layers.exp:3
msgid "$out = e^x$"
msgstr ""

#: of paddle.fluid.layers.exp:6
msgid "Input of Exp operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.exp:11
msgid "Output of Exp operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1136
msgid "relu"
msgstr ""

#: of paddle.fluid.layers.relu:1
msgid "Relu Activation Operator."
msgstr ""

#: of paddle.fluid.layers.relu:3
msgid "$out = \\max(x, 0)$"
msgstr ""

#: of paddle.fluid.layers.relu:6
msgid "Input of Relu operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.relu:11
msgid "Output of Relu operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1144
msgid "tanh"
msgstr ""

#: of paddle.fluid.layers.tanh:1
msgid "Tanh Activation Operator."
msgstr ""

#: of paddle.fluid.layers.tanh:3
msgid "$$out = \\frac{e^{x} - e^{-x}}{e^{x} + e^{-x}}$$"
msgstr ""

#: of paddle.fluid.layers.tanh:6
msgid "Input of Tanh operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.tanh:11
msgid "Output of Tanh operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1152
msgid "tanh_shrink"
msgstr ""

#: of paddle.fluid.layers.tanh_shrink:1
msgid "TanhShrink Activation Operator."
msgstr ""

#: of paddle.fluid.layers.tanh_shrink:3
msgid "$$out = x - \\frac{e^{x} - e^{-x}}{e^{x} + e^{-x}}$$"
msgstr ""

#: of paddle.fluid.layers.tanh_shrink:6
msgid "Input of TanhShrink operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.tanh_shrink:11
msgid "Output of TanhShrink operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1160
msgid "softshrink"
msgstr ""

#: of paddle.fluid.layers.softshrink:1
msgid ":strong:`Softshrink Activation Operator`"
msgstr ""

#: of paddle.fluid.layers.softshrink:11
msgid "Input of Softshrink operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.softshrink:13
msgid "non-negative offset"
msgstr ""

#: of paddle.fluid.layers.softshrink:16
msgid "Output of Softshrink operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1168
msgid "sqrt"
msgstr ""

#: of paddle.fluid.layers.sqrt:1
msgid "Sqrt Activation Operator."
msgstr ""

#: of paddle.fluid.layers.sqrt:3
msgid "$out = \\sqrt{x}$"
msgstr ""

#: of paddle.fluid.layers.sqrt:6
msgid "Input of Sqrt operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.sqrt:11
msgid "Output of Sqrt operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1176
msgid "abs"
msgstr ""

#: of paddle.fluid.layers.abs:1
msgid "Abs Activation Operator."
msgstr ""

#: of paddle.fluid.layers.abs:3
msgid "$out = |x|$"
msgstr ""

#: of paddle.fluid.layers.abs:6
msgid "Input of Abs operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.abs:11
msgid "Output of Abs operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1184
msgid "ceil"
msgstr ""

#: of paddle.fluid.layers.ceil:1
msgid "Ceil Activation Operator."
msgstr ""

#: of paddle.fluid.layers.ceil:3
msgid "$out = ceil(x)$"
msgstr ""

#: of paddle.fluid.layers.ceil:6
msgid "Input of Ceil operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.ceil:11
msgid "Output of Ceil operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1192
msgid "floor"
msgstr ""

#: of paddle.fluid.layers.floor:1
msgid "Floor Activation Operator."
msgstr ""

#: of paddle.fluid.layers.floor:3
msgid "$out = floor(x)$"
msgstr ""

#: of paddle.fluid.layers.floor:6
msgid "Input of Floor operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.floor:11
msgid "Output of Floor operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1200
msgid "cos"
msgstr ""

#: of paddle.fluid.layers.cos:1
msgid "Cosine Activation Operator."
msgstr ""

#: of paddle.fluid.layers.cos:3
msgid "$out = cos(x)$"
msgstr ""

#: of paddle.fluid.layers.cos:6
msgid "Input of Cos operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.cos:11
msgid "Output of Cos operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1208
msgid "sin"
msgstr ""

#: of paddle.fluid.layers.sin:1
msgid "Sine Activation Operator."
msgstr ""

#: of paddle.fluid.layers.sin:3
msgid "$out = sin(x)$"
msgstr ""

#: of paddle.fluid.layers.sin:6
msgid "Input of Sin operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.sin:11
msgid "Output of Sin operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1216
msgid "round"
msgstr ""

#: of paddle.fluid.layers.round:1
msgid "Round Activation Operator."
msgstr ""

#: of paddle.fluid.layers.round:3
msgid "$out = [x]$"
msgstr ""

#: of paddle.fluid.layers.round:6
msgid "Input of Round operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.round:11
msgid "Output of Round operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1224
msgid "reciprocal"
msgstr ""

#: of paddle.fluid.layers.reciprocal:1
msgid "Reciprocal Activation Operator."
msgstr ""

#: of paddle.fluid.layers.reciprocal:3
msgid "$$out = \\frac{1}{x}$$"
msgstr ""

#: of paddle.fluid.layers.reciprocal:6
msgid "Input of Reciprocal operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.reciprocal:11
msgid "Output of Reciprocal operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1232
msgid "log"
msgstr ""

#: of paddle.fluid.layers.log:1
msgid "Log Activation Operator."
msgstr ""

#: of paddle.fluid.layers.log:3
msgid "$out = \\ln(x)$"
msgstr ""

#: of paddle.fluid.layers.log:5
msgid "Natural logarithm of x."
msgstr ""

#: of paddle.fluid.layers.log:8
msgid "Input of Log operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.log:13
msgid "Output of Log operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1240
msgid "square"
msgstr ""

#: of paddle.fluid.layers.square:1
msgid "Square Activation Operator."
msgstr ""

#: of paddle.fluid.layers.square:3
msgid "$out = x^2$"
msgstr ""

#: of paddle.fluid.layers.square:6
msgid "Input of Square operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.square:11
msgid "Output of Square operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1248
msgid "softplus"
msgstr ""

#: of paddle.fluid.layers.softplus:1
msgid "Softplus Activation Operator."
msgstr ""

#: of paddle.fluid.layers.softplus:3
msgid "$out = \\ln(1 + e^{x})$"
msgstr ""

#: of paddle.fluid.layers.softplus:6
msgid "Input of Softplus operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.softplus:11
msgid "Output of Softplus operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1256
msgid "softsign"
msgstr ""

#: of paddle.fluid.layers.softsign:1
msgid "Softsign Activation Operator."
msgstr ""

#: of paddle.fluid.layers.softsign:3
msgid "$$out = \\frac{x}{1 + |x|}$$"
msgstr ""

#: of paddle.fluid.layers.softsign:6
msgid "Input of Softsign operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.softsign:11
msgid "Output of Softsign operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1264
msgid "brelu"
msgstr ""

#: of paddle.fluid.layers.brelu:1
msgid "BRelu Activation Operator."
msgstr ""

#: of paddle.fluid.layers.brelu:3
msgid "$out = \\max(\\min(x, t_{min}), t_{max})$"
msgstr ""

#: of paddle.fluid.layers.brelu:6
msgid "Input of BRelu operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.brelu:8
msgid "The min marginal value of BRelu"
msgstr ""

#: of paddle.fluid.layers.brelu:10
msgid "The max marginal value of BRelu"
msgstr ""

#: of paddle.fluid.layers.brelu:13
msgid "Output of BRelu operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1272
msgid "leaky_relu"
msgstr ""

#: of paddle.fluid.layers.leaky_relu:1
msgid "LeakyRelu Activation Operator."
msgstr ""

#: of paddle.fluid.layers.leaky_relu:3
msgid "$out = \\max(x, \\alpha * x)$"
msgstr ""

#: of paddle.fluid.layers.leaky_relu:6
msgid "Input of LeakyRelu operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.leaky_relu:8
msgid "The small negative slope"
msgstr ""

#: of paddle.fluid.layers.leaky_relu:11
msgid "Output of LeakyRelu operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1280
msgid "soft_relu"
msgstr ""

#: of paddle.fluid.layers.soft_relu:1
msgid "SoftRelu Activation Operator."
msgstr ""

#: of paddle.fluid.layers.soft_relu:3
msgid "$out = \\ln(1 + \\exp(\\max(\\min(x, threshold), threshold))$"
msgstr ""

#: of paddle.fluid.layers.soft_relu:6
msgid "Input of SoftRelu operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.soft_relu:8
msgid "The threshold value of SoftRelu"
msgstr ""

#: of paddle.fluid.layers.soft_relu:11
msgid "Output of SoftRelu operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1288
msgid "elu"
msgstr ""

#: of paddle.fluid.layers.elu:1
msgid "ELU Activation Operator."
msgstr ""

#: of paddle.fluid.layers.elu:3
msgid ""
"Applies the following element-wise computation on the input according to "
"https://arxiv.org/abs/1511.07289."
msgstr ""

#: of paddle.fluid.layers.elu:6
msgid "$out = \\max(0, x) + \\min(0, \\alpha * (e^x - 1))$"
msgstr ""

#: of paddle.fluid.layers.elu:9
msgid "Input of ELU operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.elu:11
msgid "The alpha value of ELU"
msgstr ""

#: of paddle.fluid.layers.elu:14
msgid "Output of ELU operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1296
msgid "relu6"
msgstr ""

#: of paddle.fluid.layers.relu6:1
msgid "Relu6 Activation Operator."
msgstr ""

#: of paddle.fluid.layers.relu6:3
msgid "$out = \\min(\\max(0, x), 6)$"
msgstr ""

#: of paddle.fluid.layers.relu6:6
msgid "Input of Relu6 operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.relu6:8
msgid "The threshold value of Relu6"
msgstr ""

#: of paddle.fluid.layers.relu6:11
msgid "Output of Relu6 operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1304
msgid "pow"
msgstr ""

#: of paddle.fluid.layers.pow:1
msgid "Pow Activation Operator."
msgstr ""

#: of paddle.fluid.layers.pow:3
msgid "$out = x^{factor}$"
msgstr ""

#: of paddle.fluid.layers.pow:6
msgid "Input of Pow operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.pow:8
msgid "The exponential factor of Pow"
msgstr ""

#: of paddle.fluid.layers.pow:11
msgid "Output of Pow operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1312
msgid "stanh"
msgstr ""

#: of paddle.fluid.layers.stanh:1
msgid "STanh Activation Operator."
msgstr ""

#: of paddle.fluid.layers.stanh:3
msgid "$$out = b * \\frac{e^{a * x} - e^{-a * x}}{e^{a * x} + e^{-a * x}}$$"
msgstr ""

#: of paddle.fluid.layers.stanh:6
msgid "Input of STanh operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.stanh:8
msgid "The scale parameter of a for the input"
msgstr ""

#: of paddle.fluid.layers.stanh:10
msgid "The scale parameter of b for the input"
msgstr ""

#: of paddle.fluid.layers.stanh:13
msgid "Output of STanh operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1320
msgid "hard_sigmoid"
msgstr ""

#: of paddle.fluid.layers.hard_sigmoid:1
msgid "HardSigmoid Activation Operator."
msgstr ""

#: of paddle.fluid.layers.hard_sigmoid:3
msgid ""
"Segment-wise linear approximation of "
"sigmoid(https://arxiv.org/abs/1603.00391), which is much faster than "
"sigmoid."
msgstr ""

#: of paddle.fluid.layers.hard_sigmoid:6
msgid "$out = \\max(0, \\min(1, slope * x + shift))$"
msgstr ""

#: of paddle.fluid.layers.hard_sigmoid:8
msgid ""
"The slope should be positive. The offset can be either positive or "
"negative. The default slope and shift are set according to the above "
"reference. It is recommended to use the defaults for this activation."
msgstr ""

#: of paddle.fluid.layers.hard_sigmoid:13
msgid "Input of HardSigmoid operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.hard_sigmoid:15
msgid "Slope for linear approximation of sigmoid"
msgstr ""

#: of paddle.fluid.layers.hard_sigmoid:17
msgid "Offset for linear approximation of sigmoid"
msgstr ""

#: of paddle.fluid.layers.hard_sigmoid:20
msgid "Output of HardSigmoid operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1328
msgid "swish"
msgstr ""

#: of paddle.fluid.layers.swish:1
msgid "Swish Activation Operator."
msgstr ""

#: of paddle.fluid.layers.swish:3
msgid "$$out = \\frac{x}{1 + e^{- \\beta x}}$$"
msgstr ""

#: of paddle.fluid.layers.swish:6
msgid "Input of Swish operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.swish:8
msgid "Constant beta of swish operator"
msgstr ""

#: of paddle.fluid.layers.swish:11
msgid "Output of Swish operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1336
msgid "uniform_random"
msgstr ""

#: of paddle.fluid.layers.uniform_random:1
msgid ""
"This operator initializes a tensor with random values sampled from a "
"uniform distribution. The random result is in set [min, max]."
msgstr ""

#: of paddle.fluid.layers.uniform_random:5
msgid "The shape of the output tensor"
msgstr ""

#: of paddle.fluid.layers.uniform_random:7
msgid "Minimum value of uniform random. [default -1.0]."
msgstr ""

#: of paddle.fluid.layers.uniform_random:9
msgid "Maximun value of uniform random. [default 1.0]."
msgstr ""

#: of paddle.fluid.layers.uniform_random:11
msgid ""
"Random seed used for generating samples. 0 means use a seed generated by "
"the system.Note that if seed is not 0, this operator will always generate"
" the same random numbers every time. [default 0]."
msgstr ""

#: of paddle.fluid.layers.uniform_random:13
msgid "Output tensor data type. [default 5(FP32)]."
msgstr ""

#: of paddle.fluid.layers.uniform_random:16
msgid "The output tensor of uniform random op"
msgstr ""

#: ../../source/api_reference/layers.rst:1344
msgid "hard_shrink"
msgstr ""

#: of paddle.fluid.layers.hard_shrink:1
msgid ":strong:`HardShrink activation operator`"
msgstr ""

#: of paddle.fluid.layers.hard_shrink:11
msgid "Input of HardShrink operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.hard_shrink:13
msgid "The value of threshold for HardShrink. [default: 0.5]"
msgstr ""

#: of paddle.fluid.layers.hard_shrink:16
msgid "Output of HardShrink operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1352
msgid "cumsum"
msgstr ""

#: of paddle.fluid.layers.cumsum:1
msgid ""
"The cumulative sum of the elements along a given axis. By default, the "
"first element of the result is the same of the first element of the "
"input. If exlusive is true, the first element of the result is 0."
msgstr ""

#: of paddle.fluid.layers.cumsum:5
msgid "Input of cumsum operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.cumsum:7
msgid ""
"The dimenstion to accumulate along. -1 means the last dimenstion [default"
" -1]."
msgstr ""

#: of paddle.fluid.layers.cumsum:9
msgid "Whether to perform exclusive cumsum. [default false]."
msgstr ""

#: of paddle.fluid.layers.cumsum:11
msgid ""
"If true, the cumsum is performed in the reversed direction. [default "
"false]."
msgstr ""

#: of paddle.fluid.layers.cumsum:14
msgid "Output of cumsum operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1360
msgid "thresholded_relu"
msgstr ""

#: of paddle.fluid.layers.thresholded_relu:1
msgid ":strong:`ThresholdedRelu activation operator`"
msgstr ""

#: of paddle.fluid.layers.thresholded_relu:10
msgid "Input of ThresholdedRelu operator Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.thresholded_relu:12
msgid "The threshold location of activation. [default 1.0]."
msgstr ""

#: of paddle.fluid.layers.thresholded_relu:15
msgid "Output of ThresholdedRelu operator"
msgstr ""

#: ../../source/api_reference/layers.rst:1366
#: ../../source/api_reference/layers.rst:1618
msgid "tensor"
msgstr ""

#: ../../source/api_reference/layers.rst:1371
#: ../../source/api_reference/layers.rst:1623
msgid "create_tensor"
msgstr ""

#: ../../source/api_reference/layers.rst:1379
#: ../../source/api_reference/layers.rst:1631
msgid "create_parameter"
msgstr ""

#: of paddle.fluid.layers.create_parameter:1
msgid ""
"Create a parameter. The parameter is a learnable variable, which can have"
" gradient, and can be optimized."
msgstr ""

#: of paddle.fluid.layers.create_parameter:4
msgid ""
"NOTE: this is a very low-level API. This API is useful when you create "
"operator by your self. instead of using layers."
msgstr ""

#: of paddle.fluid.layers.create_parameter:7
msgid "shape of the parameter"
msgstr ""

#: of paddle.fluid.layers.create_parameter:9
msgid "element type of the parameter"
msgstr ""

#: of paddle.fluid.layers.create_parameter:11
msgid "attributes of the parameter"
msgstr ""

#: of paddle.fluid.layers.create_parameter:13
msgid ""
"This can affect which default initializer is chosen when "
"default_initializer is None. If is_bias, initializer.Constant(0.0) will "
"be used. Otherwise, Xavier() will be used."
msgstr ""

#: of paddle.fluid.layers.create_parameter:18
msgid "initializer for the parameter"
msgstr ""

#: of paddle.fluid.layers.create_parameter:21
msgid "the created parameter."
msgstr ""

#: ../../source/api_reference/layers.rst:1387
#: ../../source/api_reference/layers.rst:1639
msgid "create_global_var"
msgstr ""

#: of paddle.fluid.layers.create_global_var:1
msgid ""
"Create a global variable. such as global_step :param shape: shape of the "
"variable :type shape: list[int] :param value: the value of the variable "
":type value: float :param dtype: element type of the parameter :type "
"dtype: string :param persistable: if this variable is persistable :type "
"persistable: bool :param force_cpu: force this variable to be on CPU "
":type force_cpu: bool"
msgstr ""

#: of paddle.fluid.layers.create_global_var:13
msgid "the created Variable"
msgstr ""

#: ../../source/api_reference/layers.rst:1395
#: ../../source/api_reference/layers.rst:1647
msgid "cast"
msgstr ""

#: of paddle.fluid.layers.cast:1
msgid ""
"This function takes in the input with input_dtype and casts it to the "
"output_dtype as the output."
msgstr ""

#: ../../source/api_reference/layers.rst:1403
#: ../../source/api_reference/layers.rst:1655
msgid "concat"
msgstr ""

#: of paddle.fluid.layers.concat:1
msgid "**Concat**"
msgstr ""

#: of paddle.fluid.layers.concat:3
msgid ""
"This function concatenates the input along the axis mentioned and returns"
" that as the output."
msgstr ""

#: of paddle.fluid.layers.concat:6
msgid "List of tensors to be concatenated"
msgstr ""

#: of paddle.fluid.layers.concat:8
msgid "Integer axis along which the tensors will be concatenated"
msgstr ""

#: of paddle.fluid.layers.concat:14
msgid "Output variable of the concatenation"
msgstr ""

#: ../../source/api_reference/layers.rst:1411
#: ../../source/api_reference/layers.rst:1663
msgid "sums"
msgstr ""

#: of paddle.fluid.layers.sums:1
msgid ""
"This function performs the sum operation on the input and returns the "
"result as the output."
msgstr ""

#: of paddle.fluid.layers.sums:4
msgid "The input tensor that has the elements that need to be summed up."
msgstr ""

#: of paddle.fluid.layers.sums:8
msgid ""
"The tensor type variable that has the sum of input           written to "
"it."
msgstr ""

#: of paddle.fluid.layers.sums:10
msgid "The tensor type variable that has the sum of input"
msgstr ""

#: of paddle.fluid.layers.sums:11
msgid "written to it."
msgstr ""

#: ../../source/api_reference/layers.rst:1419
#: ../../source/api_reference/layers.rst:1671
msgid "assign"
msgstr ""

#: of paddle.fluid.layers.assign:1
msgid "**Assign**"
msgstr ""

#: of paddle.fluid.layers.assign:3
msgid "This function copies the *input* Variable to the *output* Variable."
msgstr ""

#: of paddle.fluid.layers.assign:5
msgid "The source variable"
msgstr ""

#: of paddle.fluid.layers.assign:7
msgid "The destination variable"
msgstr ""

#: of paddle.fluid.layers.assign:10
msgid "The destination variable that was supplied as the *output*."
msgstr ""

#: ../../source/api_reference/layers.rst:1427
#: ../../source/api_reference/layers.rst:1679
msgid "fill_constant_batch_size_like"
msgstr ""

#: of paddle.fluid.layers.fill_constant_batch_size_like:1
msgid ""
"This function creates a tensor of specified *shape*, *dtype* and batch "
"size, and initializes this with a constant supplied in *value*. The batch"
" size is obtained from the `input` tensor."
msgstr ""

#: of paddle.fluid.layers.fill_constant_batch_size_like:7
#: paddle.fluid.layers.ones:6 paddle.fluid.layers.zeros:6
msgid "It also sets *stop_gradient* to True."
msgstr ""

#: of paddle.fluid.layers.fill_constant_batch_size_like:12
msgid "Tensor whose input_dim_idx'th dimension specifies the batch_size."
msgstr ""

#: of paddle.fluid.layers.fill_constant_batch_size_like:14
msgid "The shape of the output."
msgstr ""

#: of paddle.fluid.layers.fill_constant_batch_size_like:16
msgid "It could be numpy.dtype. Output data type. Default is float32."
msgstr ""

#: of paddle.fluid.layers.fill_constant_batch_size_like:18
msgid "default 0. The value to be filled."
msgstr ""

#: of paddle.fluid.layers.fill_constant_batch_size_like:20
msgid "default 0. The index of input's batch size dimension."
msgstr ""

#: of paddle.fluid.layers.fill_constant_batch_size_like:22
msgid "default 0. The index of output's batch size dimension."
msgstr ""

#: of paddle.fluid.layers.fill_constant_batch_size_like:25
msgid "Tensor of specified shape will be filled with the specified value."
msgstr ""

#: ../../source/api_reference/layers.rst:1435
#: ../../source/api_reference/layers.rst:1687
msgid "fill_constant"
msgstr ""

#: of paddle.fluid.layers.fill_constant:1
msgid "**fill_constant**"
msgstr ""

#: of paddle.fluid.layers.fill_constant:3
msgid ""
"This function creates a tensor with specified `shape` and `dtype`, and "
"initializes it with a constant specifed by `value`."
msgstr ""

#: of paddle.fluid.layers.fill_constant:6
msgid "The attribute `stop_gradient` of the created tensor is set to True."
msgstr ""

#: of paddle.fluid.layers.fill_constant:8
msgid "Shape of the output tensor."
msgstr ""

#: of paddle.fluid.layers.fill_constant:10
msgid "Data type of the output tensor."
msgstr ""

#: of paddle.fluid.layers.fill_constant:12
msgid "The constant value used to initialize the output tensor."
msgstr ""

#: of paddle.fluid.layers.fill_constant:16
msgid "data should be on CPU if set true."
msgstr ""

#: of paddle.fluid.layers.fill_constant:19
msgid "The tensor variable storing the output."
msgstr ""

#: ../../source/api_reference/layers.rst:1443
#: ../../source/api_reference/layers.rst:1695
msgid "argmin"
msgstr ""

#: of paddle.fluid.layers.argmin:1
msgid "**argmin**"
msgstr ""

#: of paddle.fluid.layers.argmin:3
msgid ""
"This function computes the indices of the min elements of the input "
"tensor's element along the provided axis."
msgstr ""

#: of paddle.fluid.layers.argmin:6
msgid "The input to compute the indices of the min elements."
msgstr ""

#: of paddle.fluid.layers.argmax:9 paddle.fluid.layers.argmin:9
msgid "Axis to compute indices along."
msgstr ""

#: of paddle.fluid.layers.argmax:12 paddle.fluid.layers.argmin:12
#: paddle.fluid.layers.ones:13 paddle.fluid.layers.zeros:13
msgid "The tensor variable storing the output"
msgstr ""

#: ../../source/api_reference/layers.rst:1451
#: ../../source/api_reference/layers.rst:1703
msgid "argmax"
msgstr ""

#: of paddle.fluid.layers.argmax:1
msgid "**argmax**"
msgstr ""

#: of paddle.fluid.layers.argmax:3
msgid ""
"This function computes the indices of the max elements of the input "
"tensor's element along the provided axis."
msgstr ""

#: of paddle.fluid.layers.argmax:6
msgid "The input to compute the indices of the max elements."
msgstr ""

#: ../../source/api_reference/layers.rst:1459
#: ../../source/api_reference/layers.rst:1711
msgid "ones"
msgstr ""

#: of paddle.fluid.layers.ones:1
msgid "**ones**"
msgstr ""

#: of paddle.fluid.layers.ones:3
msgid ""
"This function creates a tensor of specified *shape* and *dtype*, and "
"initializes this with 1."
msgstr ""

#: of paddle.fluid.layers.ones:8 paddle.fluid.layers.zeros:8
msgid "Shape of output tensor"
msgstr ""

#: of paddle.fluid.layers.ones:10 paddle.fluid.layers.zeros:10
msgid "Data type of output tensor"
msgstr ""

#: ../../source/api_reference/layers.rst:1467
#: ../../source/api_reference/layers.rst:1719
msgid "zeros"
msgstr ""

#: of paddle.fluid.layers.zeros:1
msgid "**zeros**"
msgstr ""

#: of paddle.fluid.layers.zeros:3
msgid ""
"This function creates a tensor of specified *shape* and *dtype*, and "
"initializes this with 0."
msgstr ""

#: ../../source/api_reference/layers.rst:1473
msgid "learning_rate_scheduler"
msgstr ""

#: ../../source/api_reference/layers.rst:1478
msgid "exponential_decay"
msgstr ""

#: of paddle.fluid.layers.exponential_decay:1
msgid "Applies exponential decay to the learning rate."
msgstr ""

#: of paddle.fluid.layers.exponential_decay:3
msgid "```python decayed_learning_rate = learning_rate *"
msgstr ""

#: of paddle.fluid.layers.exponential_decay:5
msgid "decay_rate ^ (global_step / decay_steps)"
msgstr ""

#: of paddle.fluid.layers.exponential_decay:6
msgid "``` :param learning_rate: A scalar float32 value or a Variable. This"
msgstr ""

#: of paddle.fluid.layers.exponential_decay:8
msgid "will be the initial learning rate during training"
msgstr ""

#: of paddle.fluid.layers.exponential_decay:9
#: paddle.fluid.layers.inverse_time_decay:10
#: paddle.fluid.layers.natural_exp_decay:10
msgid "A Python `int32` number."
msgstr ""

#: of paddle.fluid.layers.exponential_decay:10
#: paddle.fluid.layers.inverse_time_decay:11
#: paddle.fluid.layers.natural_exp_decay:11
msgid "A Python `float` number."
msgstr ""

#: of paddle.fluid.layers.exponential_decay:11
#: paddle.fluid.layers.inverse_time_decay:12
#: paddle.fluid.layers.natural_exp_decay:12
msgid "Boolean. If set true, decay the learning rate every decay_steps."
msgstr ""

#: of paddle.fluid.layers.exponential_decay:13
#: paddle.fluid.layers.inverse_time_decay:14
#: paddle.fluid.layers.natural_exp_decay:14
#: paddle.fluid.layers.polynomial_decay:17
msgid "The decayed learning rate"
msgstr ""

#: ../../source/api_reference/layers.rst:1486
msgid "natural_exp_decay"
msgstr ""

#: of paddle.fluid.layers.natural_exp_decay:1
msgid "Applies natural exponential decay to the initial learning rate."
msgstr ""

#: of paddle.fluid.layers.natural_exp_decay:8
msgid ""
"A scalar float32 value or a Variable. This will be the initial learning "
"rate during training"
msgstr ""

#: ../../source/api_reference/layers.rst:1494
msgid "inverse_time_decay"
msgstr ""

#: of paddle.fluid.layers.inverse_time_decay:1
msgid "Applies inverse time decay to the initial learning rate."
msgstr ""

#: of paddle.fluid.layers.inverse_time_decay:8
msgid ""
"A scalar float32 value or a Variable. This will be the initial learning "
"rate during training."
msgstr ""

#: ../../source/api_reference/layers.rst:1502
msgid "polynomial_decay"
msgstr ""

#: of paddle.fluid.layers.polynomial_decay:1
msgid "Applies polynomial decay to the initial learning rate."
msgstr ""

#: ../../source/api_reference/layers.rst:1510
msgid "piecewise_decay"
msgstr ""

#: of paddle.fluid.layers.piecewise_decay:1
msgid "Applies piecewise decay to the initial learning rate."
msgstr ""

#: ../../source/api_reference/layers.rst:1518
msgid "noam_decay"
msgstr ""

#: of paddle.fluid.layers.noam_decay:1
msgid "Noam decay method. The numpy implementation of noam decay as follows."
msgstr ""

#: of paddle.fluid.layers.noam_decay:8
msgid ""
"Please reference `attention is all you need "
"<https://arxiv.org/pdf/1706.03762.pdf>`_."
msgstr ""

#: of paddle.fluid.layers.noam_decay:11
msgid "The dimensionality of input and output of model."
msgstr ""

#: of paddle.fluid.layers.noam_decay:13
msgid "A super parameter."
msgstr ""

#: of paddle.fluid.layers.noam_decay:16
msgid "The decayed learning rate."
msgstr ""

#: ../../source/api_reference/layers.rst:1524
msgid "detection"
msgstr ""

#: ../../source/api_reference/layers.rst:1529
msgid "prior_box"
msgstr ""

#: of paddle.fluid.layers.prior_box:1
msgid "**Prior box operator**"
msgstr ""

#: of paddle.fluid.layers.prior_box:3
msgid ""
"Generate prior boxes for SSD(Single Shot MultiBox Detector) algorithm. "
"Each position of the input produce N prior boxes, N is determined by the "
"count of min_sizes, max_sizes and aspect_ratios, The size of the box is "
"in range(min_size, max_size) interval, which is generated in sequence "
"according to the aspect_ratios."
msgstr ""

#: of paddle.fluid.layers.prior_box:9
msgid "The Input Variables, the format is NCHW."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:11 paddle.fluid.layers.prior_box:11
msgid "The input image data of PriorBoxOp, the layout is NCHW."
msgstr ""

#: of paddle.fluid.layers.prior_box:14
msgid "min sizes of generated prior boxes."
msgstr ""

#: of paddle.fluid.layers.prior_box:16
msgid "max sizes of generated prior boxes. Default: None."
msgstr ""

#: of paddle.fluid.layers.prior_box:19
msgid "the aspect ratios of generated prior boxes. Default: [1.]."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:48 paddle.fluid.layers.prior_box:22
msgid "the variances to be encoded in prior boxes. Default:[0.1, 0.1, 0.2, 0.2]."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:51 paddle.fluid.layers.prior_box:25
msgid "Whether to flip aspect ratios. Default:False."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:53 paddle.fluid.layers.prior_box:27
msgid "Whether to clip out-of-boundary boxes. Default: False."
msgstr ""

#: of paddle.fluid.layers.prior_box:29
msgid ""
"Prior boxes step across width and height, If step[0] == 0.0/step[1] == "
"0.0, the prior boxes step across height/weight of the input will be "
"automatically calculated. Default: [0., 0.]"
msgstr ""

#: of paddle.fluid.layers.multi_box_head:46 paddle.fluid.layers.prior_box:34
msgid "Prior boxes center offset. Default: 0.5"
msgstr ""

#: of paddle.fluid.layers.prior_box:36
msgid "Name of the prior box op. Default: None."
msgstr ""

#: of paddle.fluid.layers.prior_box:39
msgid ""
"the output prior boxes of PriorBox.      The layout is [H, W, num_priors,"
" 4].      H is the height of input, W is the width of input,      "
"num_priors is the total      box count of each position of input. "
"Variances(Variable): the expanded variances of PriorBox.      The layout "
"is [H, W, num_priors, 4].      H is the height of input, W is the width "
"of input      num_priors is the total      box count of each position of "
"input"
msgstr ""

#: of paddle.fluid.layers.prior_box:44
msgid "the output prior boxes of PriorBox."
msgstr ""

#: of paddle.fluid.layers.prior_box:42
msgid ""
"The layout is [H, W, num_priors, 4]. H is the height of input, W is the "
"width of input, num_priors is the total box count of each position of "
"input."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:77 paddle.fluid.layers.prior_box:49
msgid "Variances(Variable): the expanded variances of PriorBox."
msgstr ""

#: of paddle.fluid.layers.prior_box:47
msgid ""
"The layout is [H, W, num_priors, 4]. H is the height of input, W is the "
"width of input num_priors is the total box count of each position of "
"input"
msgstr ""

#: ../../source/api_reference/layers.rst:1537
msgid "multi_box_head"
msgstr ""

#: of paddle.fluid.layers.multi_box_head:1
msgid "**Prior_boxes**"
msgstr ""

#: of paddle.fluid.layers.multi_box_head:3
msgid ""
"Generate prior boxes for SSD(Single Shot MultiBox Detector) algorithm. "
"The details of this algorithm, please refer the section 2.2 of SSD paper "
"(SSD: Single Shot MultiBox Detector) <https://arxiv.org/abs/1512.02325>`_"
" ."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:8
msgid "The list of input Variables, the format of all Variables is NCHW."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:14
msgid ""
"the base_size is used to get min_size and max_size according to min_ratio"
" and max_ratio."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:17
msgid "The number of classes."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:19
msgid ""
"the aspect ratios of generated prior boxes. The length of input and "
"aspect_ratios must be equal."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:22
msgid "the min ratio of generated prior boxes."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:24
msgid "the max ratio of generated prior boxes."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:26
msgid ""
"If `len(inputs) <=2`, min_sizes must be set up, and the length of "
"min_sizes should equal to the length of inputs. Default: None."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:30
msgid ""
"If `len(inputs) <=2`, max_sizes must be set up, and the length of "
"min_sizes should equal to the length of inputs. Default: None."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:34
msgid ""
"If step_w and step_h are the same, step_w and step_h can be replaced by "
"steps."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:37
msgid ""
"Prior boxes step across width. If step_w[i] == 0.0, the prior boxes step "
"across width of the inputs[i] will be automatically calculated. Default: "
"None."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:42
msgid ""
"Prior boxes step across height, If step_h[i] == 0.0, the prior boxes step"
" across height of the inputs[i] will be automatically calculated. "
"Default: None."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:55
msgid "The kernel size of conv2d. Default: 1."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:57
msgid "The padding of conv2d. Default:0."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:59
msgid "The stride of conv2d. Default:1,"
msgstr ""

#: of paddle.fluid.layers.multi_box_head:61
msgid "Name of the prior box layer. Default: None."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:64
msgid ""
"The predicted boxes' location of the inputs.      The layout is [N, "
"H*W*Priors, 4]. where Priors      is the number of predicted boxes each "
"position of each input. mbox_conf(Variable): The predicted boxes' "
"confidence of the inputs.      The layout is [N, H*W*Priors, C]. where "
"Priors      is the number of predicted boxes each position of each input"
"      and C is the number of Classes. boxes(Variable): the output prior "
"boxes of PriorBox.      The layout is [num_priors, 4]. num_priors is the "
"total      box count of each position of inputs. Variances(Variable): the"
" expanded variances of PriorBox.      The layout is [num_priors, 4]. "
"num_priors is the total      box count of each position of inputs"
msgstr ""

#: of paddle.fluid.layers.multi_box_head:67
msgid "The predicted boxes' location of the inputs."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:67
msgid ""
"The layout is [N, H*W*Priors, 4]. where Priors is the number of predicted"
" boxes each position of each input."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:71
msgid "mbox_conf(Variable): The predicted boxes' confidence of the inputs."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:70
msgid ""
"The layout is [N, H*W*Priors, C]. where Priors is the number of predicted"
" boxes each position of each input and C is the number of Classes."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:74
msgid "boxes(Variable): the output prior boxes of PriorBox."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:74
msgid ""
"The layout is [num_priors, 4]. num_priors is the total box count of each "
"position of inputs."
msgstr ""

#: of paddle.fluid.layers.multi_box_head:77
msgid ""
"The layout is [num_priors, 4]. num_priors is the total box count of each "
"position of inputs"
msgstr ""

#: ../../source/api_reference/layers.rst:1545
msgid "bipartite_match"
msgstr ""

#: of paddle.fluid.layers.bipartite_match:1
msgid ""
"This operator implements a greedy bipartite matching algorithm, which is "
"used to obtain the matching with the maximum distance based on the input "
"distance matrix. For input 2D matrix, the bipartite matching algorithm "
"can find the matched column for each row (matched means the largest "
"distance), also can find the matched row for each column. And this "
"operator only calculate matched indices from column to row. For each "
"instance, the number of matched indices is the column number of the input"
" distance matrix."
msgstr ""

#: of paddle.fluid.layers.bipartite_match:10
msgid ""
"There are two outputs, matched indices and distance. A simple "
"description, this algorithm matched the best (maximum distance) row "
"entity to the column entity and the matched indices are not duplicated in"
" each row of ColToRowMatchIndices. If the column entity is not matched "
"any row entity, set -1 in ColToRowMatchIndices."
msgstr ""

#: of paddle.fluid.layers.bipartite_match:16
msgid ""
"NOTE: the input DistMat can be LoDTensor (with LoD) or Tensor. If "
"LoDTensor with LoD, the height of ColToRowMatchIndices is batch size. If "
"Tensor, the height of ColToRowMatchIndices is 1."
msgstr ""

#: of paddle.fluid.layers.bipartite_match:20
msgid ""
"NOTE: This API is a very low level API. It is used by :code:`ssd_loss` "
"layer. Please consider to use :code:`ssd_loss` instead."
msgstr ""

#: of paddle.fluid.layers.bipartite_match:23
msgid ""
"This input is a 2-D LoDTensor with shape [K, M]. It is pair-wise distance"
" matrix between the entities represented by each row and each column. For"
" example, assumed one entity is A with shape [K], another entity is B "
"with shape [M]. The dist_matrix[i][j] is the distance between A[i] and "
"B[j]. The bigger the distance is, the better matching the pairs are.  "
"NOTE: This tensor can contain LoD information to represent a batch of "
"inputs. One instance of this batch can contain different numbers of "
"entities."
msgstr ""

#: of paddle.fluid.layers.bipartite_match:23
msgid ""
"This input is a 2-D LoDTensor with shape [K, M]. It is pair-wise distance"
" matrix between the entities represented by each row and each column. For"
" example, assumed one entity is A with shape [K], another entity is B "
"with shape [M]. The dist_matrix[i][j] is the distance between A[i] and "
"B[j]. The bigger the distance is, the better matching the pairs are."
msgstr ""

#: of paddle.fluid.layers.bipartite_match:30
msgid ""
"NOTE: This tensor can contain LoD information to represent a batch of "
"inputs. One instance of this batch can contain different numbers of "
"entities."
msgstr ""

#: of paddle.fluid.layers.bipartite_match:34
msgid ""
"The type of matching method, should be 'bipartite' or 'per_prediction'. "
"[default 'bipartite']."
msgstr ""

#: of paddle.fluid.layers.bipartite_match:37
msgid ""
"If `match_type` is 'per_prediction', this threshold is to determine the "
"extra matching bboxes based on the maximum distance, 0.5 by default."
msgstr ""

#: of paddle.fluid.layers.bipartite_match:42
msgid ""
"a tuple with two elements is returned. The first is matched_indices, the "
"second is matched_distance.  The matched_indices is a 2-D Tensor with "
"shape [N, M] in int type. N is the batch size. If match_indices[i][j] is "
"-1, it means B[j] does not match any entity in i-th instance. Otherwise, "
"it means B[j] is matched to row match_indices[i][j] in i-th instance. The"
" row number of i-th instance is saved in match_indices[i][j].  The "
"matched_distance is a 2-D Tensor with shape [N, M] in float type . N is "
"batch size. If match_indices[i][j] is -1, match_distance[i][j] is also "
"-1.0. Otherwise, assumed match_distance[i][j] = d, and the row offsets of"
" each instance are called LoD. Then match_distance[i][j] = "
"dist_matrix[d+LoD[i]][j]."
msgstr ""

#: of paddle.fluid.layers.bipartite_match:42
msgid ""
"a tuple with two elements is returned. The first is matched_indices, the "
"second is matched_distance."
msgstr ""

#: of paddle.fluid.layers.bipartite_match:45
msgid ""
"The matched_indices is a 2-D Tensor with shape [N, M] in int type. N is "
"the batch size. If match_indices[i][j] is -1, it means B[j] does not "
"match any entity in i-th instance. Otherwise, it means B[j] is matched to"
" row match_indices[i][j] in i-th instance. The row number of i-th "
"instance is saved in match_indices[i][j]."
msgstr ""

#: of paddle.fluid.layers.bipartite_match:52
msgid ""
"The matched_distance is a 2-D Tensor with shape [N, M] in float type . N "
"is batch size. If match_indices[i][j] is -1, match_distance[i][j] is also"
" -1.0. Otherwise, assumed match_distance[i][j] = d, and the row offsets "
"of each instance are called LoD. Then match_distance[i][j] = "
"dist_matrix[d+LoD[i]][j]."
msgstr ""

#: ../../source/api_reference/layers.rst:1553
msgid "target_assign"
msgstr ""

#: of paddle.fluid.layers.target_assign:1
msgid "**Target assigner operator**"
msgstr ""

#: of paddle.fluid.layers.target_assign:3
msgid ""
"This operator can be, for given the target bounding boxes or labels, to "
"assign classification and regression targets to each prediction as well "
"as weights to prediction. The weights is used to specify which prediction"
" would not contribute to training loss."
msgstr ""

#: of paddle.fluid.layers.target_assign:8
msgid ""
"For each instance, the output `out` and`out_weight` are assigned based on"
" `match_indices` and `negative_indices`. Assumed that the row offset for "
"each instance in `input` is called lod, this operator assigns "
"classification/regression targets by performing the following steps:"
msgstr ""

#: of paddle.fluid.layers.target_assign:14
msgid "Assigning all outpts based on `match_indices`:"
msgstr ""

#: of paddle.fluid.layers.target_assign:16
msgid "If id = match_indices[i][j] > 0,"
msgstr ""

#: of paddle.fluid.layers.target_assign:18
msgid "out[i][j][0 : K] = X[lod[i] + id][j % P][0 : K] out_weight[i][j] = 1."
msgstr ""

#: of paddle.fluid.layers.target_assign:21
msgid "Otherwise,"
msgstr ""

#: of paddle.fluid.layers.target_assign:23
msgid ""
"out[j][j][0 : K] = {mismatch_value, mismatch_value, ...} out_weight[i][j]"
" = 0."
msgstr ""

#: of paddle.fluid.layers.target_assign:26
msgid "Assigning out_weight based on `neg_indices` if `neg_indices` is provided:"
msgstr ""

#: of paddle.fluid.layers.target_assign:28
msgid ""
"Assumed that the row offset for each instance in `neg_indices` is called "
"neg_lod, for i-th instance and each `id` of neg_indices in this instance:"
msgstr ""

#: of paddle.fluid.layers.target_assign:31
msgid ""
"out[i][id][0 : K] = {mismatch_value, mismatch_value, ...} "
"out_weight[i][id] = 1.0"
msgstr ""

#: of paddle.fluid.layers.target_assign:34
msgid "This input is a 3D LoDTensor with shape [M, P, K]."
msgstr ""

#: of paddle.fluid.layers.target_assign:36
msgid ""
"Tensor<int>), The input matched indices is 2D Tenosr<int32> with shape "
"[N, P], If MatchIndices[i][j] is -1, the j-th entity of column is not "
"matched to any entity of row in i-th instance."
msgstr ""

#: of paddle.fluid.layers.target_assign:41
msgid ""
"The input negative example indices are an optional input with shape [Neg,"
" 1] and int32 type, where Neg is the total number of negative example "
"indices."
msgstr ""

#: of paddle.fluid.layers.target_assign:45
msgid "Fill this value to the mismatched location."
msgstr ""

#: of paddle.fluid.layers.target_assign:48
msgid ""
"The output is a 3D Tensor with shape [N, P, K],     N and P is the same "
"as they are in `neg_indices`, K is the     same as it in input of X. If "
"`match_indices[i][j]`. out_weight (Variable): The weight for output with "
"the shape of [N, P, 1]."
msgstr ""

#: of paddle.fluid.layers.target_assign:51
msgid "The output is a 3D Tensor with shape [N, P, K],"
msgstr ""

#: of paddle.fluid.layers.target_assign:51
msgid ""
"N and P is the same as they are in `neg_indices`, K is the same as it in "
"input of X. If `match_indices[i][j]`."
msgstr ""

#: of paddle.fluid.layers.target_assign:53
msgid "out_weight (Variable): The weight for output with the shape of [N, P, 1]."
msgstr ""

#: ../../source/api_reference/layers.rst:1561
msgid "detection_output"
msgstr ""

#: of paddle.fluid.layers.detection_output:1
msgid "**Detection Output Layer for Single Shot Multibox Detector (SSD).**"
msgstr ""

#: of paddle.fluid.layers.detection_output:3
msgid ""
"This operation is to get the detection results by performing following "
"two steps:"
msgstr ""

#: of paddle.fluid.layers.detection_output:6
msgid "Decode input bounding box predictions according to the prior boxes."
msgstr ""

#: of paddle.fluid.layers.detection_output:7
msgid ""
"Get the final detection results by applying multi-class non maximum "
"suppression (NMS)."
msgstr ""

#: of paddle.fluid.layers.detection_output:10
msgid ""
"Please note, this operation doesn't clip the final output bounding boxes "
"to the image window."
msgstr ""

#: of paddle.fluid.layers.detection_output:13
msgid ""
"A 3-D Tensor with shape [N, M, 4] represents the predicted locations of M"
" bounding bboxes. N is the batch size, and each bounding box has four "
"coordinate values and the layout is [xmin, ymin, xmax, ymax]."
msgstr ""

#: of paddle.fluid.layers.detection_output:18
msgid ""
"A 3-D Tensor with shape [N, M, C] represents the predicted confidence "
"predictions. N is the batch size, C is the class number, M is number of "
"bounding boxes. For each category there are total M scores which "
"corresponding M bounding boxes."
msgstr ""

#: of paddle.fluid.layers.detection_output:23
msgid ""
"A 2-D Tensor with shape [M, 4] holds M boxes, each box is represented as "
"[xmin, ymin, xmax, ymax], [xmin, ymin] is the left top coordinate of the "
"anchor box, if the input is image feature map, they are close to the "
"origin of the coordinate system. [xmax, ymax] is the right bottom "
"coordinate of the anchor box."
msgstr ""

#: of paddle.fluid.layers.detection_output:30
msgid "A 2-D Tensor with shape [M, 4] holds M group of variance."
msgstr ""

#: of paddle.fluid.layers.detection_output:33
msgid ""
"The index of background label, the background label will be ignored. If "
"set to -1, then all categories will be considered."
msgstr ""

#: of paddle.fluid.layers.detection_output:37
msgid "The threshold to be used in NMS."
msgstr ""

#: of paddle.fluid.layers.detection_output:39
msgid ""
"Maximum number of detections to be kept according to the confidences "
"aftern the filtering detections based on score_threshold."
msgstr ""

#: of paddle.fluid.layers.detection_output:43
msgid ""
"Number of total bboxes to be kept per image after NMS step. -1 means "
"keeping all bboxes after NMS step."
msgstr ""

#: of paddle.fluid.layers.detection_output:46
msgid ""
"Threshold to filter out bounding boxes with low confidence score. If not "
"provided, consider all boxes."
msgstr ""

#: of paddle.fluid.layers.detection_output:49
msgid "The parameter for adaptive NMS."
msgstr ""

#: of paddle.fluid.layers.detection_output:52
msgid ""
"The detection outputs is a LoDTensor with shape [No, 6].     Each row has"
" six values: [label, confidence, xmin, ymin, xmax, ymax].     `No` is the"
" total number of detections in this mini-batch. For each     instance, "
"the offsets in first dimension are called LoD, the offset     number is N"
" + 1, N is the batch size. The i-th image has     `LoD[i + 1] - LoD[i]` "
"detected results, if it is 0, the i-th image     has no detected results."
" If all images have not detected results,     all the elements in LoD are"
" 0, and output tensor only contains one     value, which is -1."
msgstr ""

#: of paddle.fluid.layers.detection_output:61
msgid "The detection outputs is a LoDTensor with shape [No, 6]."
msgstr ""

#: of paddle.fluid.layers.detection_output:55
msgid ""
"Each row has six values: [label, confidence, xmin, ymin, xmax, ymax]. "
"`No` is the total number of detections in this mini-batch. For each "
"instance, the offsets in first dimension are called LoD, the offset "
"number is N + 1, N is the batch size. The i-th image has `LoD[i + 1] - "
"LoD[i]` detected results, if it is 0, the i-th image has no detected "
"results. If all images have not detected results, all the elements in LoD"
" are 0, and output tensor only contains one value, which is -1."
msgstr ""

#: of paddle.fluid.layers.detection_output:69
msgid "pb = layers.data(name='prior_box', shape=[10, 4],"
msgstr ""

#: of paddle.fluid.layers.detection_output:70
#: paddle.fluid.layers.detection_output:72
#: paddle.fluid.layers.detection_output:74
#: paddle.fluid.layers.detection_output:76
msgid "append_batch_size=False, dtype='float32')"
msgstr ""

#: of paddle.fluid.layers.detection_output:71
msgid "pbv = layers.data(name='prior_box_var', shape=[10, 4],"
msgstr ""

#: of paddle.fluid.layers.detection_output:73
msgid "loc = layers.data(name='target_box', shape=[2, 21, 4],"
msgstr ""

#: of paddle.fluid.layers.detection_output:75
msgid "scores = layers.data(name='scores', shape=[2, 21, 10],"
msgstr ""

#: of paddle.fluid.layers.detection_output:79
msgid "nmsed_outs = fluid.layers.detection_output(scores=scores,"
msgstr ""

#: of paddle.fluid.layers.detection_output:78
msgid "loc=loc, prior_box=pb, prior_box_var=pbv)"
msgstr ""

#: ../../source/api_reference/layers.rst:1569
msgid "ssd_loss"
msgstr ""

#: of paddle.fluid.layers.ssd_loss:1
msgid "**Multi-box loss layer for object detection algorithm of SSD**"
msgstr ""

#: of paddle.fluid.layers.ssd_loss:3
msgid ""
"This layer is to compute dection loss for SSD given the location offset "
"predictions, confidence predictions, prior boxes and ground-truth "
"boudding boxes and labels, and the type of hard example mining. The "
"returned loss is a weighted sum of the localization loss (or regression "
"loss) and confidence loss (or classification loss) by performing the "
"following steps:"
msgstr ""

#: of paddle.fluid.layers.ssd_loss:9
msgid "Find matched bounding box by bipartite matching algorithm."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:11
msgid "1.1 Compute IOU similarity between ground-truth boxes and prior boxes."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:13
msgid "1.2 Compute matched boundding box by bipartite matching algorithm."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:15
msgid "Compute confidence for mining hard examples"
msgstr ""

#: of paddle.fluid.layers.ssd_loss:17
msgid "2.1. Get the target label based on matched indices."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:19
msgid "2.2. Compute confidence loss."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:21
msgid ""
"Apply hard example mining to get the negative example indices and update "
"the matched indices."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:24
msgid "Assign classification and regression targets"
msgstr ""

#: of paddle.fluid.layers.ssd_loss:26
msgid "4.1. Encoded bbox according to the prior boxes."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:28
msgid "4.2. Assign regression targets."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:30
msgid "4.3. Assign classification targets."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:32
msgid "Compute the overall objective loss."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:34
msgid "5.1 Compute confidence loss."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:36
msgid "5.1 Compute localization loss."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:38
msgid "5.3 Compute the overall weighted loss."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:40
msgid ""
"The location predictions are a 3D Tensor with shape [N, Np, 4], N is the "
"batch size, Np is total number of predictions for each instance. 4 is the"
" number of coordinate values, the layout is [xmin, ymin, xmax, ymax]."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:45
msgid ""
"The confidence predictions are a 3D Tensor with shape [N, Np, C], N and "
"Np are the same as they are in `location`, C is the class number."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:49
msgid ""
"The ground-truth boudding boxes (bboxes) are a 2D LoDTensor with shape "
"[Ng, 4], Ng is the total number of ground-truth bboxes of mini-batch "
"input."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:53
msgid "The ground-truth labels are a 2D LoDTensor with shape [Ng, 1]."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:56
msgid "The prior boxes are a 2D Tensor with shape [Np, 4]."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:58
msgid "The variance of prior boxes are a 2D Tensor with shape [Np, 4]."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:61
msgid "The index of background label, 0 by default."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:63
msgid ""
"If match_type is 'per_prediction', use `overlap_threshold` to determine "
"the extra matching bboxes when  finding matched boxes. 0.5 by default."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:63
msgid ""
"If match_type is 'per_prediction', use `overlap_threshold` to determine "
"the extra matching bboxes when"
msgstr ""

#: of paddle.fluid.layers.ssd_loss:65
msgid "finding matched boxes. 0.5 by default."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:67
msgid ""
"The ratio of the negative boxes to the positive boxes, used only when "
"mining_type is 'max_negative', 3.0 by defalut."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:70
msgid ""
"The negative overlap upper bound for the unmatched predictions. Use only "
"when mining_type is 'max_negative', 0.5 by default."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:74
msgid "Weight for localization loss, 1.0 by default."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:76
msgid "Weight for confidence loss, 1.0 by default."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:78
msgid ""
"The type of matching method during training, should be 'bipartite' or "
"'per_prediction', 'per_prediction' by defalut."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:81
msgid ""
"The hard example mining type, should be 'hard_example' or 'max_negative',"
" now only support `max_negative`."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:84
msgid ""
"Whether to normalize the SSD loss by the total number of output "
"locations, True by default."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:87
msgid ""
"The max sample size of negative box, used only when mining_type is "
"'hard_example'."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:91
msgid ""
"The weighted sum of the localization loss and confidence loss, with"
"         shape [N * Np, 1], N and Np are the same as they are in "
"`location`."
msgstr ""

#: of paddle.fluid.layers.ssd_loss:93
msgid ""
":exc:`ValueError` -- If mining_type is 'hard_example', now only support "
"mining         type of `max_negative`."
msgstr ""

#: ../../source/api_reference/layers.rst:1577
msgid "detection_map"
msgstr ""

#: of paddle.fluid.layers.detection_map:1
msgid ""
"Detection mAP evaluate operator. The general steps are as follows. First,"
" calculate the true positive and"
msgstr ""

#: of paddle.fluid.layers.detection_map:3
msgid ""
"false positive according to the input of detection and labels, then "
"calculate the mAP evaluate value. Supporting '11 point' and 'integral' "
"mAP algorithm. Please get more information from the following articles: "
"https://sanchom.wordpress.com/tag/average-precision/ "
"https://arxiv.org/abs/1512.02325"
msgstr ""

#: of paddle.fluid.layers.detection_map:11
msgid ""
"(LoDTensor) A 2-D LoDTensor with shape [M, 6] represents the detections. "
"Each row has 6 values: [label, confidence, xmin, ymin, xmax, ymax], M is "
"the total number of detect results in this mini-batch. For each instance,"
" the offsets in first dimension are called LoD, the number of offset is N"
" + 1, if LoD[i + 1] - LoD[i] == 0, means there is no detected data. "
"Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.detection_map:13
msgid ""
"(LoDTensor) A 2-D LoDTensor represents theLabeled ground-truth data. Each"
" row has 6 values: [label, xmin, ymin, xmax, ymax, is_difficult] or 5 "
"values: [label, xmin, ymin, xmax, ymax], where N is the total number of "
"ground-truth data in this mini-batch. For each instance, the offsets in "
"first dimension are called LoD, the number of offset is N + 1, if LoD[i +"
" 1] - LoD[i] == 0, means there is no ground-truth data. Duplicable: False"
"  Optional: False"
msgstr ""

#: of paddle.fluid.layers.detection_map:15
msgid ""
"(Tensor<int>) A tensor with shape [1], 0 means ignoring input states, "
"which including PosCount, TruePos, FalsePos. Duplicable: False  Optional:"
" True"
msgstr ""

#: of paddle.fluid.layers.detection_map:17
msgid ""
"(Tensor) A tensor with shape [Ncls, 1], store the input positive example "
"count of each class, Ncls is the count of input classification. This "
"input is used to pass the AccumPosCount generated by the previous mini-"
"batch when the multi mini-batches cumulative calculation carried out. "
"When the input(PosCount) is empty, the cumulative calculation is not "
"carried out, and only the results of the current mini-batch are "
"calculated. Duplicable: False  Optional: True"
msgstr ""

#: of paddle.fluid.layers.detection_map:19
msgid ""
"(LoDTensor) A 2-D LoDTensor with shape [Ntp, 2], store the input true "
"positive example of each class.This input is used to pass the "
"AccumTruePos generated by the previous mini-batch when the multi mini-"
"batches cumulative calculation carried out. Duplicable: False  Optional: "
"True"
msgstr ""

#: of paddle.fluid.layers.detection_map:21
msgid ""
"(LoDTensor) A 2-D LoDTensor with shape [Nfp, 2], store the input false "
"positive example of each class.This input is used to pass the "
"AccumFalsePos generated by the previous mini-batch when the multi mini-"
"batches cumulative calculation carried out. Duplicable: False  Optional: "
"True"
msgstr ""

#: of paddle.fluid.layers.detection_map:23
msgid "(int) The class number."
msgstr ""

#: of paddle.fluid.layers.detection_map:25
msgid ""
"(int, defalut: 0) The index of background label, the background label "
"will be ignored. If set to -1, then all categories will be considered."
msgstr ""

#: of paddle.fluid.layers.detection_map:27
msgid ""
"(float) The lower bound jaccard overlap threshold of detection output and"
" ground-truth data."
msgstr ""

#: of paddle.fluid.layers.detection_map:29
msgid ""
"(bool, default true) Switch to control whether the difficult data is "
"evaluated."
msgstr ""

#: of paddle.fluid.layers.detection_map:31
msgid ""
"(string, default 'integral') The AP algorithm type, 'integral' or "
"'11point'."
msgstr ""

#: of paddle.fluid.layers.detection_map:34
msgid ""
"(Tensor) A tensor with shape [Ncls, 1], store the positive example count "
"of each class. It combines the input input(PosCount) and the positive "
"example count computed from input(Detection) and input(Label)."
msgstr ""

#: ../../source/api_reference/layers.rst:1585
msgid "iou_similarity"
msgstr ""

#: of paddle.fluid.layers.iou_similarity:1
msgid ""
"IOU Similarity Operator. Computes intersection-over-union (IOU) between "
"two box lists."
msgstr ""

#: of paddle.fluid.layers.iou_similarity:3
msgid ""
"Box list 'X' should be a LoDTensor and 'Y' is a common Tensor, boxes in "
"'Y' are shared by all instance of the batched inputs of X. Given two "
"boxes A and B, the calculation of IOU is as follows:"
msgstr ""

#: of paddle.fluid.layers.iou_similarity:7
msgid "$$ IOU(A, B) = \\frac{area(A\\cap B)}{area(A)+area(B)-area(A\\cap B)} $$"
msgstr ""

#: of paddle.fluid.layers.iou_similarity:13
msgid ""
"(LoDTensor, default LoDTensor<float>) Box list X is a 2-D LoDTensor with "
"shape [N, 4] holds N boxes, each box is represented as [xmin, ymin, xmax,"
" ymax], the shape of X is [N, 4]. [xmin, ymin] is the left top coordinate"
" of the box if the input is image feature map, they are close to the "
"origin of the coordinate system. [xmax, ymax] is the right bottom "
"coordinate of the box. This tensor can contain LoD information to "
"represent a batch of inputs. One instance of this batch can contain "
"different numbers of entities. Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.iou_similarity:15
msgid ""
"(Tensor, default Tensor<float>) Box list Y holds M boxes, each box is "
"represented as [xmin, ymin, xmax, ymax], the shape of X is [N, 4]. [xmin,"
" ymin] is the left top coordinate of the box if the input is image "
"feature map, and [xmax, ymax] is the right bottom coordinate of the box. "
"Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.iou_similarity:18
msgid ""
"(LoDTensor, the lod is same as input X) The output of iou_similarity op, "
"a tensor with shape [N, M] representing pairwise iou scores."
msgstr ""

#: ../../source/api_reference/layers.rst:1593
msgid "box_coder"
msgstr ""

#: of paddle.fluid.layers.box_coder:1
msgid ""
"Bounding Box Coder Operator. Encode/Decode the target bounding box with "
"the priorbox information. The Encoding schema described below: ox = (tx -"
" px) / pw / pxv oy = (ty - py) / ph / pyv ow = log(abs(tw / pw)) / pwv oh"
" = log(abs(th / ph)) / phv The Decoding schema described below: ox = (pw "
"* pxv * tx * + px) - tw / 2 oy = (ph * pyv * ty * + py) - th / 2 ow = "
"exp(pwv * tw) * pw + tw / 2 oh = exp(phv * th) * ph + th / 2 where tx, "
"ty, tw, th denote the target box's center coordinates, width and height "
"respectively. Similarly, px, py, pw, ph denote the priorbox's(anchor) "
"center coordinates, width and height. pxv, pyv, pwv, phv denote the "
"variance of the priorbox and ox, oy, ow, oh denote the encoded/decoded "
"coordinates, width and height."
msgstr ""

#: of paddle.fluid.layers.box_coder:19
msgid ""
"(Tensor, default Tensor<float>) Box list PriorBox is a 2-D Tensor with "
"shape [M, 4] holds M boxes, each box is represented as [xmin, ymin, xmax,"
" ymax], [xmin, ymin] is the left top coordinate of the anchor box, if the"
" input is image feature map, they are close to the origin of the "
"coordinate system. [xmax, ymax] is the right bottom coordinate of the "
"anchor box. Duplicable: False  Optional: False"
msgstr ""

#: of paddle.fluid.layers.box_coder:21
msgid ""
"(Tensor, default Tensor<float>, optional) PriorBoxVar is a 2-D Tensor "
"with shape [M, 4] holds M group of variance. PriorBoxVar will set all "
"elements to 1 by default. Duplicable: False  Optional: True"
msgstr ""

#: of paddle.fluid.layers.box_coder:23
msgid ""
"(LoDTensor or Tensor) This input can be a 2-D LoDTensor with shape [N, 4]"
" when code_type is 'encode_center_size'. This input also can be a 3-D "
"Tensor with shape [N, M, 4] when code_type is 'decode_center_size'. [N, "
"4], each box is represented as [xmin, ymin, xmax, ymax], [xmin, ymin] is "
"the left top coordinate of the box if the input is image feature map, "
"they are close to the origin of the coordinate system. [xmax, ymax] is "
"the right bottom coordinate of the box. This tensor can contain LoD "
"information to represent a batch of inputs. One instance of this batch "
"can contain different numbers of entities. Duplicable: False  Optional: "
"False"
msgstr ""

#: of paddle.fluid.layers.box_coder:25
msgid ""
"(string, default encode_center_size) the code type used with the target "
"box"
msgstr ""

#: of paddle.fluid.layers.box_coder:27
msgid "(bool, default true) whether treat the priorbox as a noramlized box"
msgstr ""

#: of paddle.fluid.layers.box_coder:30
msgid ""
"(LoDTensor or Tensor) When code_type is 'encode_center_size', the output "
"tensor of box_coder_op with shape [N, M, 4] representing the result of N "
"target boxes encoded with M Prior boxes and variances. When code_type is "
"'decode_center_size', N represents the batch size and M represents the "
"number of deocded boxes."
msgstr ""

#: ../../source/api_reference/layers.rst:1599
msgid "metric"
msgstr ""

#: ../../source/api_reference/layers.rst:1604
msgid "accuracy"
msgstr ""

#: of paddle.fluid.layers.accuracy:1
msgid ""
"This function computes the accuracy using the input and label. The output"
" is the top k inputs and their indices."
msgstr ""

#: ../../source/api_reference/layers.rst:1612
msgid "auc"
msgstr ""

#~ msgid "layers"
#~ msgstr ""

#~ msgid ""
#~ "Returns a list of places based on"
#~ " flags. The list will be used "
#~ "for parallel execution."
#~ msgstr ""

#~ msgid ""
#~ "If :attr:`None`, it makes no effect "
#~ "to lookup. Otherwise the given "
#~ ":attr:`padding_idx` indicates padding the "
#~ "output with zeros whenever lookup "
#~ "encounters it in :attr:`input`. If "
#~ ":math:`padding_idx < 0`, the padding_idx "
#~ "to use in lookup is :math:`size[0] "
#~ "+ dim`."
#~ msgstr ""

#~ msgid "**Convlution2D Layer**"
#~ msgstr ""

#~ msgid ""
#~ "The convolution2D layer calculates the "
#~ "output based on the input, filter "
#~ "and strides, paddings, dilations, groups "
#~ "parameters. Input(Input) and Output(Output) "
#~ "are in NCHW format. Where N is "
#~ "batch size, C is the number of "
#~ "channels, H is the height of the"
#~ " feature, and W is the width of"
#~ " the feature. The details of "
#~ "convolution layer, please refer UFLDL's "
#~ "`convolution, "
#~ "<http://ufldl.stanford.edu/tutorial/supervised/FeatureExtractionUsingConvolution/>`_"
#~ " . If bias attribution and activation"
#~ " type are provided, bias is added "
#~ "to the output of the convolution, "
#~ "and the corresponding activation function "
#~ "is applied to the final result."
#~ msgstr ""

#~ msgid "Output: Output shape: :math:`(N, C_{out}, H_{out}, W_{out})`"
#~ msgstr ""

#~ msgid ""
#~ "The input image with [N, C, H, "
#~ "W] format. num_filters(int): The number "
#~ "of filter. It is as same as "
#~ "the output image channel."
#~ msgstr ""

#~ msgid "Mean Operator."
#~ msgstr ""

#~ msgid "Out is a scalar which is the mean of all elements in X."
#~ msgstr ""

#~ msgid "The input of mean op Duplicable: False  Optional: False"
#~ msgstr ""

#~ msgid "The output of mean op"
#~ msgstr ""

#~ msgid "Softshrink Activation Operator."
#~ msgstr ""

#~ msgid "$$ out = \\begin{cases}"
#~ msgstr ""

#~ msgid ""
#~ "x - \\lambda, \\text{if } x > "
#~ "\\lambda \\\\ x + \\lambda, \\text{if"
#~ " } x < -\\lambda \\\\ 0,  "
#~ "\\text{otherwise} \\end{cases}"
#~ msgstr ""

#~ msgid "$$"
#~ msgstr ""

